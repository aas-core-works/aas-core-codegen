SymbolTable(
  our_types=[
    ConstrainedPrimitive(
      name='Non_empty_XML_serializable_string',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent a string with at least one character.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The string should also be serializable to XML, which is the background for
            the following constraint.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-130',
            textwrap.dedent("""\
              <field_body><paragraph>An attribute with data type "string" shall consist of these characters only:
              <literal>^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\u00010000-\\u0010FFFF]*$</literal>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Date_time_UTC',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='The value must match the pattern of xs:dateTime with the time zone fixed to UTC.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_date_time_UTC',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Date_time_UTC',
          parsed=...),
        Invariant(
          description='The value must represent a valid xs:dateTime with the time zone fixed to UTC.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_xs_date_time_UTC',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Date_time_UTC',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent an <literal>xs:dateTime</literal> with the time zone fixed to UTC.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Duration',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='The value must match the pattern of xs:duration.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_duration',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Duration',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent an <literal>xs:duration</literal>.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Blob_type',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='BYTEARRAY',
      is_implementation_specific=False,
      invariants=[],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Group of bytes to represent file content (binaries and non-binaries)</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Identifier',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Identifier shall have a maximum length of 2000 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=2000,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Identifier',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Value_type_IEC_61360',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Value type IEC 61360 shall have a maximum length of 2000 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=2000,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Value_type_IEC_61360',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Name_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Name type shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Name_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string with length 128 maximum and 1 minimum</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Version_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Version type shall match the version pattern.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_version_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Version_type',
          parsed=...),
        Invariant(
          description='Version type shall have a maximum length of 4 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=4,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Version_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string with length 4 maximum and 1 minimum</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Revision_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Revision type shall match the revision pattern.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_revision_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Revision_type',
          parsed=...),
        Invariant(
          description='Revision type shall have a maximum length of 4 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=4,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Revision_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string with length 4 maximum and 1 minimum</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Label_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Label type shall have a maximum length of 64 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=64,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Label_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string with length 64 maximum and 1 minimum characters</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Message_topic_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Message topic type shall have a maximum length of 255 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=255,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Message_topic_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string with length 255 maximum and minimum 1 characters</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='BCP_47_language_tag',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='The value must represent a value language tag conformant to BCP 47.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_BCP_47',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive BCP_47_language_tag',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent a language tag conformant to BCP 47.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://tools.ietf.org/rfc/bcp/bcp47.txt">https://tools.ietf.org/rfc/bcp/bcp47.txt</reference></paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Content_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Content type shall have a maximum length of 100 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=100,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Content_type',
          parsed=...),
        Invariant(
          description='The value must represent a valid content MIME type according to RFC 2046.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_MIME_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Content_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>String with length 100 maximum and minimum 1 characters</paragraph>',
        remarks=[
          '<note><paragraph>Any content type as in RFC2046.</paragraph></note>',
          textwrap.dedent("""\
            <paragraph>A media type (also MIME type and content type) […] is a two-part
            identifier for file formats and format contents transmitted on
            the Internet. The Internet Assigned Numbers Authority (IANA) is
            the official authority for the standardization and publication of
            these classifications. Media types were originally defined in
            Request for Comments 2045 in November 1996 as a part of MIME
            (Multipurpose Internet Mail Extensions) specification, for denoting
            type of email message content and attachments.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Path_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Identifier'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
        'Reference to ConstrainedPrimitive Identifier'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Identifier shall have a maximum length of 2000 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=2000,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Identifier',
          parsed=...),
        Invariant(
          description='The value must represent a valid file URI scheme according to RFC 8089.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_RFC_8089_path',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Path_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Identifier</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>Any string conformant to RFC8089 , the “file” URI scheme (for
            relative and absolute file paths)</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Qualifier_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Name_type'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
        'Reference to ConstrainedPrimitive Name_type'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Name type shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Name_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Value_data_type',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>any XSD simple type as specified via <ReferenceToOurType refuri="Data_type_def_XSD">Data_type_def_XSD</ReferenceToOurType></paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='ID_short_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Name_type'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
        'Reference to ConstrainedPrimitive Name_type'],
      ancestor_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_XML_serializable_string',
          parsed=...),
        Invariant(
          description='Name type shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Name_type',
          parsed=...),
        Invariant(
          description='ID-short of Referables shall only feature letters, digits, underscore (``_``); starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_ID_short',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive ID_short_type',
          parsed=...)],
      invariant_id_set=...,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent a short ID of an <ReferenceToOurType refuri="Referable">Referable</ReferenceToOurType>.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-002',
            textwrap.dedent("""\
              <field_body><paragraph>ID-short of <ReferenceToOurType refuri="Referable">Referable</ReferenceToOurType>'s shall only feature letters, digits,
              underscore (<literal>_</literal>); starting mandatory with a letter.
              <emphasis>I.e.</emphasis> <literal>[a-zA-Z][a-zA-Z0-9_]*</literal>.</paragraph></field_body>""")],
          [
            'AASd-117',
            textwrap.dedent("""\
              <field_body><paragraph>Constraint AASd-117: <ReferenceToAttribute refuri="Referable.ID_short">Referable.ID_short</ReferenceToAttribute> of
              non-identifiable <ReferenceToOurType refuri="Referable">Referable</ReferenceToOurType> not being a direct child of
              a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> shall be specified.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...),
    AbstractClass(
      name='Has_semantics',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_semantics',
        name='Has_semantics',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass Extension',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Qualifier',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Specific_asset_ID',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>Element that can have a semantic definition plus some supplemental semantic
            definitions.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-118',
              textwrap.dedent("""\
                <field_body><paragraph>If there are ID <ReferenceToAttribute refuri="Has_semantics.supplemental_semantic_IDs">Has_semantics.supplemental_semantic_IDs</ReferenceToAttribute> defined
                then there shall be also a main semantic ID <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>.</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to AbstractClass Submodel_element',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to AbstractClass Event_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to AbstractClass Data_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass Extension',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Qualifier',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Specific_asset_ID',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass Extension',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Qualifier',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Specific_asset_ID',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Element that can have a semantic definition plus some supplemental semantic
          definitions.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-118',
            textwrap.dedent("""\
              <field_body><paragraph>If there are ID <ReferenceToAttribute refuri="Has_semantics.supplemental_semantic_IDs">Has_semantics.supplemental_semantic_IDs</ReferenceToAttribute> defined
              then there shall be also a main semantic ID <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Extension',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Name_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of the extension.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-077',
                textwrap.dedent("""\
                  <field_body><paragraph>The name of an extension (Extension/name) within <ReferenceToOurType refuri="Has_extensions">Has_extensions</ReferenceToOurType> needs
                  to be unique.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Type of the value of the extension.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="Data_type_def_XSD.String">Data_type_def_XSD.String</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value of the extension</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='refers_to',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to an element the extension refers to.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='value_type_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Extension',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Data_type_def_XSD',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='refers_to',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_semantics')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='refers_to',
              argument='refers_to',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='refers_to',
              argument='refers_to',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Refers-to must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='refers_to',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='refers_to',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Invariant(
          description='The value must match the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_or_default',
                      original_node=...),
                    args=[],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Single extension of an element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_extensions',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_extensions',
        name='Has_extensions',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
          remarks=[
            '<note><paragraph>Extensions are proprietary, i.e. they do not support global interoperability.</paragraph></note>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Submodel_element',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to AbstractClass Identifiable',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to AbstractClass Event_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to AbstractClass Data_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
        remarks=[
          '<note><paragraph>Extensions are proprietary, i.e. they do not support global interoperability.</paragraph></note>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Referable',
      inheritances=[
        'Reference to AbstractClass Has_extensions'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_extensions'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Referable',
        name='Referable',
        inheritances=[
          'Reference to Interface Has_extensions'],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>An element that is referable by its <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute>.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <paragraph>This ID is not globally unique.
              This ID is unique within the name space of the element.</paragraph>""")],
          constraints_by_identifier=[
            [
              'AASd-022',
              textwrap.dedent("""\
                <field_body><paragraph><ReferenceToAttribute refuri="Referable.ID_short">Referable.ID_short</ReferenceToAttribute> of non-identifiable referables
                within the same name space shall be unique (case-sensitive).</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to AbstractClass Submodel_element',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to AbstractClass Identifiable',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to AbstractClass Event_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to AbstractClass Data_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_extensions')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>An element that is referable by its <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>This ID is not globally unique.
            This ID is unique within the name space of the element.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-022',
            textwrap.dedent("""\
              <field_body><paragraph><ReferenceToAttribute refuri="Referable.ID_short">Referable.ID_short</ReferenceToAttribute> of non-identifiable referables
              within the same name space shall be unique (case-sensitive).</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Identifiable',
      inheritances=[
        'Reference to AbstractClass Referable'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Identifiable',
        name='Identifiable',
        inheritances=[
          'Reference to Interface Referable'],
        implementers=[
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Submodel'],
        properties=[
          Property(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>Some of the administrative information like the version number might need to
                  be part of the identification.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...),
          Property(
            name='ID',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>The globally unique identification of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Submodel'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Submodel'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Referable')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID',
              argument='ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID',
              argument='ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Modelling_kind',
      literals=[
        EnumerationLiteral(
          name='Template',
          value='Template',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Specification of the common features of a structured element in sufficient detail
              that such a instance can be instantiated using it</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Concrete, clearly identifiable element instance. Its creation and validation
              may be guided by a corresponding element template.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration for denoting whether an element is a template or an instance.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    AbstractClass(
      name='Has_kind',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_kind',
        name='Has_kind',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Submodel'],
        properties=[
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modelling_kind',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <ReferenceToAttribute refuri="Modelling_kind.Instance">Modelling_kind.Instance</ReferenceToAttribute></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...)],
        signatures=[
          Signature(
            name='kind_or_default',
            arguments=[],
            returns=OurTypeAnnotation(
              our_type='Reference to our type Modelling_kind',
              parsed=...),
            description=None,
            contracts=Contracts(
              preconditions=[],
              snapshots=[],
              postconditions=[]),
            parsed=...,
            arguments_by_name=...)],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>An element with a kind is an element that can either represent a template or an
            instance.</paragraph>"""),
          remarks=[
            '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Submodel'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Submodel'],
      properties=[
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modelling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="Modelling_kind.Instance">Modelling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modelling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modelling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>An element with a kind is an element that can either represent a template or an
          instance.</paragraph>"""),
        remarks=[
          '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_data_specification',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_data_specification',
        name='Has_data_specification',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Administrative_information',
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Embedded data specification.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <paragraph>A data specification template defines a named set of additional attributes an
              element may or shall have. The data specifications used are explicitly specified
              with their global ID.</paragraph>""")],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Administrative_information',
        'Reference to AbstractClass Submodel_element',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to AbstractClass Event_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to AbstractClass Data_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Administrative_information',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>A data specification template defines a named set of additional attributes an
            element may or shall have. The data specifications used are explicitly specified
            with their global ID.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Administrative_information',
      inheritances=[
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_data_specification'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='version',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Version_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Version of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...),
        Property(
          name='revision',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Revision_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Revision of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...),
        Property(
          name='creator',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The subject ID of the subject responsible for making the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...),
        Property(
          name='template_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Identifier of the template that guided the creation of the element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case of a submodel the <ReferenceToAttribute refuri="template_ID">template_ID</ReferenceToAttribute> is the identifier
                of the submodel template ID that guided the creation of the submodel</paragraph></note>"""),
              textwrap.dedent("""\
                <note><paragraph>The <ReferenceToAttribute refuri="template_ID">template_ID</ReferenceToAttribute> is not relevant for validation in Submodels.
                For validation the <ReferenceToAttribute refuri="Submodel.semantic_ID">Submodel.semantic_ID</ReferenceToAttribute> shall be used.</paragraph></note>"""),
              textwrap.dedent("""\
                <note><paragraph>Usage of <ReferenceToAttribute refuri="template_ID">template_ID</ReferenceToAttribute> is not restricted to submodel instances. So also
                the creation of submodel templates can be guided by another submodel template.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='version',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Version_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='revision',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Revision_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='creator',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='template_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Identifier',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_data_specification')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='version',
              argument='version',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='revision',
              argument='revision',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='creator',
              argument='creator',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='template_ID',
              argument='template_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='version',
              argument='version',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='revision',
              argument='revision',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='creator',
              argument='creator',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='template_ID',
              argument='template_ID',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-005: If version is not specified then also revision shall be unspecified. This means, a revision requires a version. If there is no version there is no revision either. Revision is optional.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='revision',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='version',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Administrative meta-information for an element like version
          information.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-005',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="version">version</ReferenceToAttribute> is not specified then also <ReferenceToAttribute refuri="revision">revision</ReferenceToAttribute> shall be
              unspecified. This means, a revision requires a version. If there is no version
              there is no revision neither. Revision is optional.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Qualifiable',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Qualifiable',
        name='Qualifiable',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>The value of a qualifiable element may be further qualified by one or more
            qualifiers.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-119',
              textwrap.dedent("""\
                <field_body><paragraph>If any <ReferenceToAttribute refuri="Qualifier.kind">Qualifier.kind</ReferenceToAttribute> value of <ReferenceToAttribute refuri="Qualifiable.qualifiers">Qualifiable.qualifiers</ReferenceToAttribute> is
                equal to <ReferenceToAttribute refuri="Qualifier_kind.Template_qualifier">Qualifier_kind.Template_qualifier</ReferenceToAttribute> and the qualified element
                inherits from <ReferenceToOurType refuri="Has_kind">Has_kind</ReferenceToOurType> then the qualified element shall be of
                kind Template (<ReferenceToAttribute refuri="Has_kind.kind">Has_kind.kind</ReferenceToAttribute> = <ReferenceToAttribute refuri="Modelling_kind.Template">Modelling_kind.Template</ReferenceToAttribute>).</paragraph><note><paragraph>This constraint is checked at <ReferenceToOurType refuri="Submodel">Submodel</ReferenceToOurType>.</paragraph></note></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to AbstractClass Submodel_element',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to AbstractClass Event_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to AbstractClass Data_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>The value of a qualifiable element may be further qualified by one or more
          qualifiers.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-119',
            textwrap.dedent("""\
              <field_body><paragraph>If any <ReferenceToAttribute refuri="Qualifier.kind">Qualifier.kind</ReferenceToAttribute> value of <ReferenceToAttribute refuri="Qualifiable.qualifiers">Qualifiable.qualifiers</ReferenceToAttribute> is
              equal to <ReferenceToAttribute refuri="Qualifier_kind.Template_qualifier">Qualifier_kind.Template_qualifier</ReferenceToAttribute> and the qualified element
              inherits from <ReferenceToOurType refuri="Has_kind">Has_kind</ReferenceToOurType> then the qualified element shall be of
              kind Template (<ReferenceToAttribute refuri="Has_kind.kind">Has_kind.kind</ReferenceToAttribute> = <ReferenceToAttribute refuri="Modelling_kind.Template">Modelling_kind.Template</ReferenceToAttribute>).</paragraph><note><paragraph>This constraint is checked at <ReferenceToOurType refuri="Submodel">Submodel</ReferenceToOurType>.</paragraph></note></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Qualifier_kind',
      literals=[
        EnumerationLiteral(
          name='Value_qualifier',
          value='ValueQualifier',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>qualifies the value of the element and can change during run-time.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Value qualifiers are only applicable to elements with kind
                <ReferenceToAttribute refuri="Modelling_kind.Instance">Modelling_kind.Instance</ReferenceToAttribute>.</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Concept_qualifier',
          value='ConceptQualifier',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>qualifies the semantic definition the element is referring to
              (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>)</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Template_qualifier',
          value='TemplateQualifier',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>qualifies the elements within a specific submodel on concept level.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Template qualifiers are only applicable to elements with kind
                <ReferenceToAttribute refuri="Modelling_kind.Template">Modelling_kind.Template</ReferenceToAttribute>.</paragraph>""")],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration for kinds of qualifiers.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>This element is experimental and therefore may be subject to change or may be
            removed completely in future versions of the meta-model.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Qualifier',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Qualifier_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The qualifier kind describes the kind of the qualifier that is applied to the
              element.</paragraph>"""),
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="Qualifier_kind.Concept_qualifier">Qualifier_kind.Concept_qualifier</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Qualifier_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The qualifier <emphasis>type</emphasis> describes the type of the qualifier that is applied to
              the element.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data type of the qualifier value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The qualifier value is the value of the qualifier.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Qualifier_kind',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Qualifier',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Qualifier_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Qualifier_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_semantics')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-020: The value shall be consistent to the data type as defined in value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A qualifier is a type-value-pair that makes additional statements w.r.t. the value
          of the element.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-006',
            textwrap.dedent("""\
              <field_body><paragraph>If both the <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> and the <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute> of
              a <ReferenceToOurType refuri="Qualifier">Qualifier</ReferenceToOurType> are present then the <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> needs
              to be identical to the value of the referenced coded value
              in <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-020',
            textwrap.dedent("""\
              <field_body><paragraph>The value of <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> shall be consistent to the data type as
              defined in <ReferenceToAttribute refuri="value_type">value_type</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_administration_shell',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='derived_from',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The reference to the AAS the AAS was derived from.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='asset_information',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Asset_information',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Meta-information about the asset the AAS is representing.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>References to submodels of the AAS.</paragraph>',
            remarks=[
              '<paragraph>A submodel is a description of an aspect of the asset the AAS is representing.</paragraph>',
              '<paragraph>The asset of an AAS is typically described by one or more submodels.</paragraph>',
              '<paragraph>Temporarily no submodel might be assigned to the AAS.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='asset_information',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Asset_information',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='derived_from',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Identifiable')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_data_specification')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='derived_from',
              argument='derived_from',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='asset_information',
              argument='asset_information',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID',
              argument='ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='derived_from',
              argument='derived_from',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='asset_information',
              argument='asset_information',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Submodels must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodels',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Invariant(
          description='Derived-from must be a model reference to an asset administration shell.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='derived_from',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='derived_from',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='Key_types',
                      original_node=...),
                    name='Asset_administration_shell',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Invariant(
          description='All submodels must be model references to a submodel.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='reference',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodels',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Name(
                      identifier='reference',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>An asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_information',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Asset_kind',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Denotes whether the Asset is of kind <ReferenceToAttribute refuri="Asset_kind.Type">Asset_kind.Type</ReferenceToAttribute> or
              <ReferenceToAttribute refuri="Asset_kind.Instance">Asset_kind.Instance</ReferenceToAttribute>.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='global_asset_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Global identifier of the asset the AAS is representing.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>This attribute is required as soon as the AAS is exchanged via partners in the life
                cycle of the asset. In a first phase of the life cycle the asset might not yet have
                a global ID but already an internal identifier. The internal identifier would be
                modelled via <ReferenceToAttribute refuri="specific_asset_IDs">specific_asset_IDs</ReferenceToAttribute>.</paragraph>"""),
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='specific_asset_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Specific_asset_ID',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Additional domain-specific, typically proprietary identifier for the asset like
              e.g., serial number etc.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='asset_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case <ReferenceToAttribute refuri="asset_kind">asset_kind</ReferenceToAttribute> is applicable the <ReferenceToAttribute refuri="asset_type">asset_type</ReferenceToAttribute> is the asset ID
              of the type asset of the asset under consideration
              as identified by <ReferenceToAttribute refuri="global_asset_ID">global_asset_ID</ReferenceToAttribute>.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case <ReferenceToAttribute refuri="asset_kind">asset_kind</ReferenceToAttribute> is "Instance" than the <ReferenceToAttribute refuri="asset_type">asset_type</ReferenceToAttribute> denotes
                which "Type" the asset is of. But it is also possible
                to have an <ReferenceToAttribute refuri="asset_type">asset_type</ReferenceToAttribute> of an asset of kind "Type".</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='default_thumbnail',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Resource',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Thumbnail of the asset represented by the Asset Administration Shell.</paragraph>',
            remarks=[
              '<paragraph>Used as default.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_kind',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Asset_kind',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='global_asset_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Identifier',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Specific_asset_ID',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='asset_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Identifier',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='default_thumbnail',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Resource',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_kind',
              argument='asset_kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_ID',
              argument='global_asset_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_IDs',
              argument='specific_asset_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='asset_type',
              argument='asset_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='default_thumbnail',
              argument='default_thumbnail',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_kind',
              argument='asset_kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_ID',
              argument='global_asset_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_IDs',
              argument='specific_asset_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='asset_type',
              argument='asset_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='default_thumbnail',
              argument='default_thumbnail',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-116: ``globalAssetId`` is a reserved key. If used as value for the name of specific asset ID then the value of specific asset ID shall be identical to the global asset ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_IDs',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='specific_asset_ID',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='specific_asset_IDs',
                    original_node=...),
                  original_node=...),
                condition=Or(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='specific_asset_ID',
                          original_node=...),
                        name='name',
                        original_node=...),
                      op='NE',
                      right=Constant(
                        value='globalAssetId',
                        original_node=...),
                      original_node=...),
                    And(
                      values=[
                        IsNotNone(
                          value=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='global_asset_ID',
                            original_node=...),
                          original_node=...),
                        Comparison(
                          left=Member(
                            instance=Name(
                              identifier='specific_asset_ID',
                              original_node=...),
                            name='name',
                            original_node=...),
                          op='EQ',
                          right=Constant(
                            value='globalAssetId',
                            original_node=...),
                          original_node=...),
                        Comparison(
                          left=Member(
                            instance=Name(
                              identifier='specific_asset_ID',
                              original_node=...),
                            name='value',
                            original_node=...),
                          op='EQ',
                          right=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='global_asset_ID',
                            original_node=...),
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Invariant(
          description='Constraint AASd-131: Either the global asset ID shall be defined or at least one specific asset ID.',
          body=textwrap.dedent("""\
            And(
              values=[
                Or(
                  values=[
                    IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_ID',
                        original_node=...),
                      original_node=...),
                    IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_IDs',
                        original_node=...),
                      original_node=...)],
                  original_node=...),
                Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_IDs',
                      original_node=...),
                    original_node=...),
                  consequent=Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='specific_asset_IDs',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Invariant(
          description='Specific asset IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>In <ReferenceToOurType refuri="Asset_information">Asset_information</ReferenceToOurType> identifying meta data of the asset that is
          represented by an AAS is defined.</paragraph>"""),
        remarks=[
          '<paragraph>The asset may either represent an asset type or an asset instance.</paragraph>',
          textwrap.dedent("""\
            <paragraph>The asset has a globally unique identifier plus – if needed – additional domain
            specific (proprietary) identifiers. However, to support the corner case of very
            first phase of lifecycle where a stabilised/constant_set global asset identifier
            does not already exist, the corresponding attribute <ReferenceToAttribute refuri="global_asset_ID">global_asset_ID</ReferenceToAttribute> is
            optional.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-116',
            textwrap.dedent("""\
              <field_body><paragraph><literal>globalAssetId</literal> is a reserved key. If used as value for
              <ReferenceToAttribute refuri="Specific_asset_ID.name">Specific_asset_ID.name</ReferenceToAttribute> then <ReferenceToAttribute refuri="Specific_asset_ID.value">Specific_asset_ID.value</ReferenceToAttribute> shall be
              identical to <ReferenceToAttribute refuri="global_asset_ID">global_asset_ID</ReferenceToAttribute>.</paragraph><note><paragraph><ReferenceToConstraint refuri="AASd-116">AASd-116</ReferenceToConstraint> is important to enable a generic search across
              global and specific asset IDs.</paragraph></note><note><paragraph>In the book, <ReferenceToConstraint refuri="AASd-116">AASd-116</ReferenceToConstraint> imposes a
              case-insensitive equality against <literal>globalAssetId</literal>. This is
              culturally-dependent, and depends on the system settings.
              For example, the case-folding for the letters "i" and "I" is
              different in Turkish from English.</paragraph><paragraph>We implement the constraint as case-sensitive instead to allow
              for interoperability across different culture settings.</paragraph></note></field_body>""")],
          [
            'AASd-131',
            textwrap.dedent("""\
              <field_body><paragraph>For <ReferenceToOurType refuri="Asset_information">Asset_information</ReferenceToOurType> either the <ReferenceToAttribute refuri="global_asset_ID">global_asset_ID</ReferenceToAttribute> shall be
              defined or at least one item in <ReferenceToAttribute refuri="specific_asset_IDs">specific_asset_IDs</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Resource',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='path',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Path_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Path and name of the resource (with file extension).</paragraph>',
            remarks=[
              '<paragraph>The path can be absolute or relative.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Resource',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Content_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Content type of the content of the file.</paragraph>',
            remarks=[
              '<paragraph>The content type states which file extensions the file can have.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Resource',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='path',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Path_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='content_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Content_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='path',
              argument='path',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='path',
              argument='path',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Resource represents an address to a file (a locator). The value is an URI that
          can represent an absolute or relative path</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Asset_kind',
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Type asset</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Instance asset</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Not_applicable',
          value='NotApplicable',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Neither a type asset nor an instance asset</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration for denoting whether an asset is a type asset or an instance asset.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Specific_asset_ID',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Label_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of the identifier</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_ID',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the specific asset identifier with the corresponding name.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_ID',
          parsed=...),
        Property(
          name='external_subject_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The (external) subject the key belongs to or has meaning to.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_ID',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Label_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='external_subject_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_semantics')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='external_subject_ID',
              argument='external_subject_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='external_subject_ID',
              argument='external_subject_ID',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-133: External subject ID shall be an external reference.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='external_subject_ID',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=Member(
                  instance=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='external_subject_ID',
                    original_node=...),
                  name='type',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Reference_types',
                    original_node=...),
                  name='External_reference',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Specific_asset_ID',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A specific asset ID describes a generic supplementary identifying attribute of the
          asset.</paragraph>"""),
        remarks=[
          '<paragraph>The specific asset ID is not necessarily globally unique.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-133',
            textwrap.dedent("""\
              <field_body><paragraph><ReferenceToAttribute refuri="external_subject_ID">external_subject_ID</ReferenceToAttribute> shall be an external reference,
              i.e. <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.External_reference">Reference_types.External_reference</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modelling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="Modelling_kind.Instance">Modelling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='submodel_elements',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>A submodel consists of zero or more submodel elements.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modelling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modelling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodel_elements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Identifiable')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_kind')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_semantics')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Qualifiable')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_data_specification')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodel_elements',
              argument='submodel_elements',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID',
              argument='ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodel_elements',
              argument='submodel_elements',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Submodel elements must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodel_elements',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of submodel elements according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-022: ID-short of non-identifiable referables within the same name space shall be unique (case-sensitive).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='ID_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-129: If any qualifier kind value of a Submodel element qualifier (attribute qualifier inherited via Qualifiable) is equal to Template Qualifier then the submodel element shall be part of a submodel template, i.e. a Submodel with submodel kind (attribute kind inherited via Has-Kind) value is equal to Template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='NE',
                  right=Member(
                    instance=Name(
                      identifier='Modelling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                consequent=All(
                  generator=ForEach(
                    variable=Name(
                      identifier='submodel_element',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodel_elements',
                      original_node=...),
                    original_node=...),
                  condition=Implication(
                    antecedent=IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='submodel_element',
                          original_node=...),
                        name='qualifiers',
                        original_node=...),
                      original_node=...),
                    consequent=All(
                      generator=ForEach(
                        variable=Name(
                          identifier='qualifier',
                          original_node=...),
                        iteration=Member(
                          instance=Name(
                            identifier='submodel_element',
                            original_node=...),
                          name='qualifiers',
                          original_node=...),
                        original_node=...),
                      condition=Comparison(
                        left=MethodCall(
                          member=Member(
                            instance=Name(
                              identifier='qualifier',
                              original_node=...),
                            name='kind_or_default',
                            original_node=...),
                          args=[],
                          original_node=...),
                        op='NE',
                        right=Member(
                          instance=Name(
                            identifier='Qualifier_kind',
                            original_node=...),
                          name='Template_qualifier',
                          original_node=...),
                        original_node=...),
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=MethodCall(
                      member=Member(
                        instance=Name(
                          identifier='qualifier',
                          original_node=...),
                        name='kind_or_default',
                        original_node=...),
                      args=[],
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modelling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A submodel defines a specific aspect of the asset represented by the AAS.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>A submodel is used to structure the digital representation and technical
            functionality of an Administration Shell into distinguishable parts. Each submodel
            refers to a well-defined domain or subject matter. Submodels can become
            standardized and, thus, become submodels templates.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Submodel_element',
      inheritances=[
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Submodel_element',
        name='Submodel_element',
        inheritances=[
          'Reference to Interface Referable',
          'Reference to Interface Has_semantics',
          'Reference to Interface Qualifiable',
          'Reference to Interface Has_data_specification'],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>A submodel element is an element suitable for the description and differentiation of
            assets.</paragraph>"""),
          remarks=[
            '<paragraph>It is recommended to add a <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> to a submodel element.</paragraph>'],
          constraints_by_identifier=[
            [
              'AASd-129',
              textwrap.dedent("""\
                <field_body><paragraph>If any <ReferenceToAttribute refuri="Qualifier.kind">Qualifier.kind</ReferenceToAttribute> value of <ReferenceToAttribute refuri="qualifiers">qualifiers</ReferenceToAttribute> (attribute qualifier
                inherited via Qualifiable) is equal to <ReferenceToAttribute refuri="Qualifier_kind.Template_qualifier">Qualifier_kind.Template_qualifier</ReferenceToAttribute>
                then the submodel element shall be part of a submodel template, i.e.
                a Submodel with <ReferenceToAttribute refuri="Submodel.kind">Submodel.kind</ReferenceToAttribute> (attribute kind inherited via
                <ReferenceToOurType refuri="Has_kind">Has_kind</ReferenceToOurType>) value is equal to <ReferenceToAttribute refuri="Modelling_kind.Template">Modelling_kind.Template</ReferenceToAttribute>.</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to AbstractClass Event_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to AbstractClass Data_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Referable')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_semantics')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Qualifiable')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_data_specification')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A submodel element is an element suitable for the description and differentiation of
          assets.</paragraph>"""),
        remarks=[
          '<paragraph>It is recommended to add a <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> to a submodel element.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-129',
            textwrap.dedent("""\
              <field_body><paragraph>If any <ReferenceToAttribute refuri="Qualifier.kind">Qualifier.kind</ReferenceToAttribute> value of <ReferenceToAttribute refuri="qualifiers">qualifiers</ReferenceToAttribute> (attribute qualifier
              inherited via Qualifiable) is equal to <ReferenceToAttribute refuri="Qualifier_kind.Template_qualifier">Qualifier_kind.Template_qualifier</ReferenceToAttribute>
              then the submodel element shall be part of a submodel template, i.e.
              a Submodel with <ReferenceToAttribute refuri="Submodel.kind">Submodel.kind</ReferenceToAttribute> (attribute kind inherited via
              <ReferenceToOurType refuri="Has_kind">Has_kind</ReferenceToOurType>) value is equal to <ReferenceToAttribute refuri="Modelling_kind.Template">Modelling_kind.Template</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Relationship_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to ConcreteClass Relationship_element',
        name='Relationship_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Relationship_element'],
        properties=[
          Property(
            name='first',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to ConcreteClass Relationship_element',
            parsed=...),
          Property(
            name='second',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to ConcreteClass Relationship_element',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>A relationship element is used to define a relationship between two elements
            being either referable (model reference) or external (global reference).</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Annotated_relationship_element'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A relationship element is used to define a relationship between two elements
          being either referable (model reference) or external (global reference).</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='AAS_submodel_elements',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=None,
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration of all possible elements of a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType>.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Submodel_element_list',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='order_relevant',
          type_annotation=OptionalTypeAnnotation(
            value=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Defines whether order in list is relevant. If <ReferenceToAttribute refuri="order_relevant">order_relevant</ReferenceToAttribute> = <literal>False</literal>
              then the list is representing a set or a bag.</paragraph>"""),
            remarks=[
              '<paragraph>Default: <literal>True</literal></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='semantic_ID_list_element',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Semantic ID the submodel elements contained in the list match to.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='type_value_list_element',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type AAS_submodel_elements',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The submodel element type of the submodel elements contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value_type_list_element',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value type of the submodel element contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Submodel element contained in the list.</paragraph>',
            remarks=[
              '<paragraph>The list is ordered.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='order_relevant_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Submodel_element_list',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type_value_list_element',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type AAS_submodel_elements',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='order_relevant',
            type_annotation=OptionalTypeAnnotation(
              value=PrimitiveTypeAnnotation(
                a_type='BOOL',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID_list_element',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type_list_element',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Data_type_def_XSD',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type_value_list_element',
              argument='type_value_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='order_relevant',
              argument='order_relevant',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID_list_element',
              argument='semantic_ID_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type_list_element',
              argument='value_type_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type_value_list_element',
              argument='type_value_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='order_relevant',
              argument='order_relevant',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID_list_element',
              argument='semantic_ID_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type_list_element',
              argument='value_type_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Value must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-107: If a first level child element has a semantic ID it shall be identical to semantic ID list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='semantic_ID_list_element',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='child',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='child',
                        original_node=...),
                      name='semantic_ID',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='reference_key_values_equal',
                    args=[
                      Member(
                        instance=Name(
                          identifier='child',
                          original_node=...),
                        name='semantic_ID',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='semantic_ID_list_element',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-114: If two first level child elements have a semantic ID then they shall be identical.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='submodel_elements_have_identical_semantic_IDs',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-108: All first level child elements shall have the same submodel element type as specified in type value list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='submodel_element_is_of_type',
                  args=[
                    Name(
                      identifier='element',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type_value_list_element',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-109: If type value list element is equal to Property or Range value type list element shall be set and all first level child elements shall have the value type as specified in value type list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Property',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Range',
                          original_node=...),
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              consequent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_list_element',
                      original_node=...),
                    original_node=...),
                  FunctionCall(
                    name='properties_or_ranges_have_value_type',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_type_list_element',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-120: ID-short of submodel elements being a direct child of a  Submodel element list shall not be specified.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A submodel element list is an ordered list of submodel elements.</paragraph>',
        remarks=[
          '<paragraph>The numbering starts with zero (0).</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-107',
            textwrap.dedent("""\
              <field_body><paragraph>If a first level child element in a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> has
              a <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> it
              shall be identical to <ReferenceToAttribute refuri="Submodel_element_list.semantic_ID_list_element">Submodel_element_list.semantic_ID_list_element</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-114',
            textwrap.dedent("""\
              <field_body><paragraph>If two first level child elements in a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> have
              a <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> then they shall be identical.</paragraph></field_body>""")],
          [
            'AASd-115',
            textwrap.dedent("""\
              <field_body><paragraph>If a first level child element in a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> does not
              specify a <ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> then the value is assumed to be
              identical to <ReferenceToAttribute refuri="Submodel_element_list.semantic_ID_list_element">Submodel_element_list.semantic_ID_list_element</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-120',
            textwrap.dedent("""\
              <field_body><paragraph>The <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> of a <ReferenceToOurType refuri="Submodel_element">Submodel_element</ReferenceToOurType> being a direct child of a
              <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> shall not be specified.</paragraph></field_body>""")],
          [
            'AASd-108',
            textwrap.dedent("""\
              <field_body><paragraph>All first level child elements in a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> shall have
              the same submodel element type as specified in <ReferenceToAttribute refuri="type_value_list_element">type_value_list_element</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-109',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="type_value_list_element">type_value_list_element</ReferenceToAttribute> is equal to
              <ReferenceToAttribute refuri="AAS_submodel_elements.Property">AAS_submodel_elements.Property</ReferenceToAttribute> or
              <ReferenceToAttribute refuri="AAS_submodel_elements.Range">AAS_submodel_elements.Range</ReferenceToAttribute>
              <ReferenceToAttribute refuri="value_type_list_element">value_type_list_element</ReferenceToAttribute> shall be set and all first
              level child elements in the <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType> shall have
              the value type as specified in <ReferenceToAttribute refuri="value_type_list_element">value_type_list_element</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel_element_collection',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Submodel element contained in the collection.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Value must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of value according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...),
        Invariant(
          description='ID-shorts of the value must be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='ID_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A submodel element collection is a kind of struct, i.e. a a logical encapsulation
          of multiple named values. It has a fixed number of submodel elements.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_element',
        name='Data_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element'],
        properties=[],
        signatures=[
          Signature(
            name='category_or_default',
            arguments=[],
            returns=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            description=None,
            contracts=Contracts(
              preconditions=[],
              snapshots=[],
              postconditions=[
                Contract(
                  args=[
                    'result'],
                  description=None,
                  body=textwrap.dedent("""\
                    IsIn(
                      member=Name(
                        identifier='result',
                        original_node=...),
                      container=Name(
                        identifier='Valid_categories_for_data_element',
                        original_node=...),
                      original_node=...)"""),
                  parsed=...)]),
            parsed=...,
            arguments_by_name=...)],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>A data element is a submodel element that is not further composed out of
            other submodel elements.</paragraph>"""),
          remarks=[
            textwrap.dedent("""\
              <paragraph>A data element is a submodel element that has a value. The type of value differs
              for different subtypes of data elements.</paragraph>""")],
          constraints_by_identifier=[
            [
              'AASd-090',
              textwrap.dedent("""\
                <field_body><paragraph>For data elements <ReferenceToAttribute refuri="category">category</ReferenceToAttribute> shall be one of the following
                values: <literal>CONSTANT</literal>, <literal>PARAMETER</literal> or <literal>VARIABLE</literal>.</paragraph><paragraph>Default: <literal>VARIABLE</literal></paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A data element is a submodel element that is not further composed out of
          other submodel elements.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>A data element is a submodel element that has a value. The type of value differs
            for different subtypes of data elements.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-090',
            textwrap.dedent("""\
              <field_body><paragraph>For data elements <ReferenceToAttribute refuri="category">category</ReferenceToAttribute> shall be one of the following
              values: <literal>CONSTANT</literal>, <literal>PARAMETER</literal> or <literal>VARIABLE</literal>.</paragraph><paragraph>Default: <literal>VARIABLE</literal></paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Data_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data type of the value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Data_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description='Value must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A property is a data element that has a single value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-007',
            textwrap.dedent("""\
              <field_body><paragraph>If both, the <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> and the <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute> are
              present then the value of <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> needs to be identical to
              the value of the referenced coded value in <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Multi_language_property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Data_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Data_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description='Value must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...),
        Invariant(
          description='Value must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A property is a data element that has a multi-language value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-012',
            textwrap.dedent("""\
              <field_body><paragraph>If both the <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> and the <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute> are present then for each
              string in a specific language the meaning must be the same as specified in
              <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Range',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Data_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data type of the min und max</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='min',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The minimum value of the range.</paragraph>',
            remarks=[
              '<paragraph>If the min value is missing, then the value is assumed to be negative infinite.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='max',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The maximum value of the range.</paragraph>',
            remarks=[
              '<paragraph>If the max value is missing, then the value is assumed to be positive infinite.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Data_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min',
              argument='min',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max',
              argument='max',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min',
              argument='min',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max',
              argument='max',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description='Max must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='max',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Invariant(
          description='Min must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='min',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='min',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A range data element is a data element that defines a range with min and max.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Reference_element',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Data_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Global reference to an external object or entity or a logical reference to
              another element within the same or another AAS (i.e. a model reference to
              a Referable).</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Data_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A reference element is a data element that defines a logical reference to another
          element within the same or another AAS or a reference to an external object or
          entity.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Blob',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Data_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Blob_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the <ReferenceToOurType refuri="Blob">Blob</ReferenceToOurType> instance of a blob data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In contrast to the file property the file content is stored directly as value
                in the <ReferenceToOurType refuri="Blob">Blob</ReferenceToOurType> data element.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Content_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Content type of the content of the <ReferenceToOurType refuri="Blob">Blob</ReferenceToOurType>.</paragraph>',
            remarks=[
              '<paragraph>The content type (MIME type) states which file extensions the file can have.</paragraph>',
              textwrap.dedent("""\
                <paragraph>Valid values are content types like e.g. <literal>application/json</literal>, <literal>application/xls</literal>,
                <literal>image/jpg</literal>.</paragraph>"""),
              '<paragraph>The allowed values are defined as in RFC2046.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='content_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Content_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Blob_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Data_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A <ReferenceToOurType refuri="Blob">Blob</ReferenceToOurType> is a data element that represents a file that is contained with its
          source code in the value attribute.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='File',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Data_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Path_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Path and name of the referenced file (with file extension).</paragraph>',
            remarks=[
              '<paragraph>The path can be absolute or relative.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Content_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Content type of the content of the file.</paragraph>',
            remarks=[
              '<paragraph>The content type states which file extensions the file can have.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          non_mutating=True,
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='content_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Content_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Path_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Data_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A File is a data element that represents an address to a file (a locator).</paragraph>',
        remarks=[
          '<paragraph>The value is an URI that can represent an absolute or relative path.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      inheritances=[
        'Reference to ConcreteClass Relationship_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to ConcreteClass Relationship_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='annotations',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Data_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>A data element that represents an annotation that holds for the relationship
              between the two elements</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='annotations',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Data_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Relationship_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='annotations',
              argument='annotations',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='annotations',
              argument='annotations',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Annotations must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='annotations',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='annotations',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of annotations according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='annotations',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='annotations',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>An annotated relationship element is a relationship element that can be annotated
          with additional data elements.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Entity',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='statements',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Describes statements applicable to the entity by a set of submodel elements,
              typically with a qualified value.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='entity_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Entity_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Describes whether the entity is a co-managed entity or a self-managed entity.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='global_asset_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Global identifier of the asset the entity is representing.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='specific_asset_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Specific_asset_ID',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to a specific asset ID representing a supplementary identifier
              of the asset represented by the Asset Administration Shell.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='entity_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Entity_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='statements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='global_asset_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Identifier',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Specific_asset_ID',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='statements',
              argument='statements',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='entity_type',
              argument='entity_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_ID',
              argument='global_asset_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_IDs',
              argument='specific_asset_IDs',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='statements',
              argument='statements',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='entity_type',
              argument='entity_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_ID',
              argument='global_asset_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_IDs',
              argument='specific_asset_IDs',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Statements must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='statements',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='statements',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of statements according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='statements',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='statements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Invariant(
          description='Constraint AASd-014: Either the attribute global asset ID or specific asset ID must be set if entity type is set to self-managed entity. They are not existing otherwise.',
          body=textwrap.dedent("""\
            Or(
              values=[
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='EQ',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    Or(
                      values=[
                        And(
                          values=[
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_ID',
                                original_node=...),
                              original_node=...),
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_IDs',
                                original_node=...),
                              original_node=...)],
                          original_node=...),
                        And(
                          values=[
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_ID',
                                original_node=...),
                              original_node=...),
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_IDs',
                                original_node=...),
                              original_node=...),
                            Comparison(
                              left=FunctionCall(
                                name='len',
                                args=[
                                  Member(
                                    instance=Name(
                                      identifier='self',
                                      original_node=...),
                                    name='specific_asset_IDs',
                                    original_node=...)],
                                original_node=...),
                              op='GE',
                              right=Constant(
                                value=1,
                                original_node=...),
                              original_node=...)],
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='NE',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_ID',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_IDs',
                        original_node=...),
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Invariant(
          description='Specific asset IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>An entity is a submodel element that is used to model entities.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-014',
            textwrap.dedent("""\
              <field_body><paragraph>Either the attribute <ReferenceToAttribute refuri="global_asset_ID">global_asset_ID</ReferenceToAttribute> or <ReferenceToAttribute refuri="specific_asset_IDs">specific_asset_IDs</ReferenceToAttribute>
              of an <ReferenceToOurType refuri="Entity">Entity</ReferenceToOurType> must be set if <ReferenceToAttribute refuri="entity_type">entity_type</ReferenceToAttribute> is set to
              <ReferenceToAttribute refuri="Entity_type.Self_managed_entity">Entity_type.Self_managed_entity</ReferenceToAttribute>. They are not existing otherwise.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Entity_type',
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='CoManagedEntity',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>For co-managed entities there is no separate AAS. Co-managed entities need to be
              part of a self-managed entity.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SelfManagedEntity',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Self-Managed Entities have their own AAS but can be part of the bill of material of
              a composite self-managed entity.</paragraph>"""),
            remarks=[
              '<paragraph>The asset of an I4.0 Component is a self-managed entity per definition.</paragraph>'],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Enumeration for denoting whether an entity is a self-managed entity or a co-managed
          entity.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Direction',
      literals=[
        EnumerationLiteral(
          name='Input',
          value='input',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Input direction.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Output',
          value='output',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Output direction</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Direction</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>This element is experimental and therefore may be subject to change or may be
            removed completely in future versions of the meta-model.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='State_of_event',
      literals=[
        EnumerationLiteral(
          name='On',
          value='on',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Event is on</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Off',
          value='off',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Event is off.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>State of an event</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>This element is experimental and therefore may be subject to change or may be
            removed completely in future versions of the meta-model.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Event_payload',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='source',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to the source event element, including identification of
              <ReferenceToOurType refuri="Asset_administration_shell">Asset_administration_shell</ReferenceToOurType>, <ReferenceToOurType refuri="Submodel">Submodel</ReferenceToOurType>,
              <ReferenceToOurType refuri="Submodel_element">Submodel_element</ReferenceToOurType>'s.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='source_semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph><ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> of the source event element, if available</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='observable_reference',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the referable, which defines the scope of the event.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Can be <ReferenceToOurType refuri="Asset_administration_shell">Asset_administration_shell</ReferenceToOurType>, <ReferenceToOurType refuri="Submodel">Submodel</ReferenceToOurType> or
                <ReferenceToOurType refuri="Submodel_element">Submodel_element</ReferenceToOurType>.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='observable_semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph><ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> of the referable which defines the scope of
              the event, if available.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='topic',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Message_topic_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Information for the outer message infrastructure for scheduling the event to
              the respective communication channel.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='subject_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Subject, who/which initiated the creation.</paragraph>',
            remarks=[
              '<note><paragraph>This is an external reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='time_stamp',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Date_time_UTC',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Timestamp in UTC, when this event was triggered.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='payload',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Blob_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Event specific payload.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='source',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='observable_reference',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='time_stamp',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Date_time_UTC',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='source_semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='observable_semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='topic',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Message_topic_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='subject_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='payload',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Blob_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='source',
              argument='source',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_reference',
              argument='observable_reference',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='time_stamp',
              argument='time_stamp',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_semantic_ID',
              argument='source_semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_semantic_ID',
              argument='observable_semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='topic',
              argument='topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='subject_ID',
              argument='subject_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='payload',
              argument='payload',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='source',
              argument='source',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_reference',
              argument='observable_reference',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='time_stamp',
              argument='time_stamp',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_semantic_ID',
              argument='source_semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_semantic_ID',
              argument='observable_semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='topic',
              argument='topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='subject_ID',
              argument='subject_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='payload',
              argument='payload',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Source must be a model reference to an Event element.',
          body=textwrap.dedent("""\
            Or(
              values=[
                FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='source',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Event_element',
                      original_node=...)],
                  original_node=...),
                FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='source',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Basic_event_element',
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Invariant(
          description='Observable reference must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observable_reference',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Defines the necessary information of an event instance sent out or received.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>This element is experimental and therefore may be subject to change or may be
            removed completely in future versions of the meta-model.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Event_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Event_element',
        name='Event_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Basic_event_element'],
        properties=[],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>An event element.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <note><paragraph>This element is experimental and therefore may be subject to change or may be
              removed completely in future versions of the meta-model.</paragraph></note>""")],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Basic_event_element'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Basic_event_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>An event element.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>This element is experimental and therefore may be subject to change or may be
            removed completely in future versions of the meta-model.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Basic_event_element',
      inheritances=[
        'Reference to AbstractClass Event_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element',
        'Reference to AbstractClass Event_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='observed',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to the <ReferenceToOurType refuri="Referable">Referable</ReferenceToOurType>, which defines the scope of the event.
              Can be <ReferenceToOurType refuri="Asset_administration_shell">Asset_administration_shell</ReferenceToOurType>, <ReferenceToOurType refuri="Submodel">Submodel</ReferenceToOurType>, or
              <ReferenceToOurType refuri="Submodel_element">Submodel_element</ReferenceToOurType>.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>Reference to a referable, e.g., a data element or
                a submodel, that is being observed.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='direction',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Direction',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Direction of event.</paragraph>',
            remarks=[
              '<paragraph>Can be <literal>{ Input, Output }</literal>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='state',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type State_of_event',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>State of event.</paragraph>',
            remarks=[
              '<paragraph>Can be <literal>{ On, Off }</literal>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='message_topic',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Message_topic_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Information for the outer message infrastructure for scheduling the event to the
              respective communication channel.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='message_broker',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Information, which outer message infrastructure shall handle messages for
              the <ReferenceToOurType refuri="Event_element">Event_element</ReferenceToOurType>. Refers to a <ReferenceToOurType refuri="Submodel">Submodel</ReferenceToOurType>,
              <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType>, <ReferenceToOurType refuri="Submodel_element_collection">Submodel_element_collection</ReferenceToOurType> or
              <ReferenceToOurType refuri="Entity">Entity</ReferenceToOurType>, which contains <ReferenceToOurType refuri="Data_element">Data_element</ReferenceToOurType>'s describing
              the proprietary specification for the message broker.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
                proprietary specification could be standardized by having respective Submodels.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='last_update',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Date_time_UTC',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Timestamp in UTC, when the last event was received (input direction) or sent
              (output direction).</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='min_interval',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Duration',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>For input direction, reports on the maximum frequency, the software entity behind
              the respective Referable can handle input events.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>For output events, specifies the maximum frequency of outputting this event to
                an outer infrastructure.</paragraph>"""),
              '<paragraph>Might be not specified, that is, there is no minimum interval.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='max_interval',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Duration',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>For input direction: not applicable.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>For output direction: maximum interval in time, the respective Referable shall send
                an update of the status of the event, even if no other trigger condition for
                the event was not met.</paragraph>"""),
              '<paragraph>Might be not specified, that is, there is no maximum interval</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='observed',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='direction',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Direction',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='state',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type State_of_event',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='message_topic',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Message_topic_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='message_broker',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='last_update',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Date_time_UTC',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min_interval',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Duration',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max_interval',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Duration',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Event_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observed',
              argument='observed',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='direction',
              argument='direction',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='state',
              argument='state',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_topic',
              argument='message_topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_broker',
              argument='message_broker',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='last_update',
              argument='last_update',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min_interval',
              argument='min_interval',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max_interval',
              argument='max_interval',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observed',
              argument='observed',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='direction',
              argument='direction',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='state',
              argument='state',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_topic',
              argument='message_topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_broker',
              argument='message_broker',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='last_update',
              argument='last_update',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min_interval',
              argument='min_interval',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max_interval',
              argument='max_interval',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Max. interval is not applicable for input direction.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='direction',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Direction',
                    original_node=...),
                  name='Input',
                  original_node=...),
                original_node=...),
              consequent=IsNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max_interval',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Invariant(
          description='Observed must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observed',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Invariant(
          description='Message broker must be a model reference to a referable.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='message_broker',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to_referable',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='message_broker',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>A basic event element.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>This element is experimental and therefore may be subject to change or may be
            removed completely in future versions of the meta-model.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='input_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Input parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='output_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Output parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='inoutput_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Parameter that is input and output of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='input_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='output_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='inoutput_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='input_variables',
              argument='input_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='output_variables',
              argument='output_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='inoutput_variables',
              argument='inoutput_variables',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='input_variables',
              argument='input_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='output_variables',
              argument='output_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='inoutput_variables',
              argument='inoutput_variables',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-134: For an Operation the ID-short of all values of input, output and in/output variables.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='ID_shorts_of_variables_are_unique',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='input_variables',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='output_variables',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='inoutput_variables',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Invariant(
          description='Input variables must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='input_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='input_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Invariant(
          description='Output variables must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='output_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='output_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Invariant(
          description='Inoutput variables must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='inoutput_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='inoutput_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary='<paragraph>An operation is a submodel element with input and output variables.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-134',
            textwrap.dedent("""\
              <field_body><paragraph>For an <ReferenceToOurType refuri="Operation">Operation</ReferenceToOurType> the <ReferenceToAttribute refuri="Referable.ID_short">Referable.ID_short</ReferenceToAttribute> of all
              <ReferenceToAttribute refuri="Operation_variable.value">Operation_variable.value</ReferenceToAttribute>'s in
              <ReferenceToAttribute refuri="input_variables">input_variables</ReferenceToAttribute>, <ReferenceToAttribute refuri="output_variables">output_variables</ReferenceToAttribute>
              and <ReferenceToAttribute refuri="inoutput_variables">inoutput_variables</ReferenceToAttribute> shall be unique.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation_variable',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Submodel_element',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Describes an argument or result of an operation via a submodel element</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation_variable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Submodel_element',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Value must have the ID-short specified according to Constraint AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            IsNotNone(
              value=Member(
                instance=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                name='ID_short',
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation_variable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>The value of an operation variable is a submodel element that is used as input
          and/or output variable of an operation.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Capability',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_data_specification',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Submodel_element'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_IDs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Submodel_element')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_ID',
              argument='semantic_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_IDs',
              argument='supplemental_semantic_IDs',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A capability is the implementation-independent description of the potential of an
          asset to achieve a certain effect in the physical or virtual world.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>The <ReferenceToAttribute refuri="semantic_ID">semantic_ID</ReferenceToAttribute> of a capability is typically an ontology.
            Thus, reasoning on capabilities is enabled.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Concept_description',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Has_extensions',
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Name_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri="Has_semantics">Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type ID_short_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="ID_short">ID_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_name_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_text_type',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='is_case_of',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to an external definition the concept is compatible to or was derived
              from.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>',
              '<note><paragraph>Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Name_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type ID_short_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_name_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_text_type',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='is_case_of',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Identifiable')"""),
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Has_data_specification')"""),
          textwrap.dedent("""\
            AssignArgument(
              name='is_case_of',
              argument='is_case_of',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID_short',
              argument='ID_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ID',
              argument='ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='is_case_of',
              argument='is_case_of',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Is-case-of must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='is_case_of',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='is_case_of',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-3a-008: For a concept description using data specification template IEC 61360, the definition is mandatory and shall be defined at least in English. Exception: The concept description describes a value.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  FunctionCall(
                    name='data_specification_IEC_61360s_have_definition_at_least_in_english',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='embedded_data_specifications',
                        original_node=...)],
                    original_node=...),
                  FunctionCall(
                    name='data_specification_IEC_61360s_have_value',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='embedded_data_specifications',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-3a-007: For a concept description with category QUALIFIER_TYPE using data specification IEC 61360, the data type of the data specification is mandatory and shall be defined.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='QUALIFIER_TYPE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_have_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-3a-006: For a concept description with category DOCUMENT using data specification IEC 61360, the data type of the data specification shall be one of: FILE, BLOB, HTML.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='DOCUMENT',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_document_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-3a-005: For a concept description with category REFERENCE using data specification IEC 61360, the data type of the data specification shall be one of: STRING, IRI, IRDI.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='REFERENCE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_reference_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-3a-004: For a concept description with category PROPERTY or VALUE using data specification IEC 61360, the data type of the data specification is mandatory and shall be one of: DATE, STRING, STRING_TRANSLATABLE, INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, RATIONAL_MEASURE, TIME, TIMESTAMP.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='category',
                          original_node=...),
                        op='EQ',
                        right=Constant(
                          value='PROPERTY',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='category',
                          original_node=...),
                        op='EQ',
                        right=Constant(
                          value='VALUE',
                          original_node=...),
                        original_node=...)],
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_property_or_value_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>The semantics of a property or other elements that may have a semantic description
          is defined by a concept description.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>The description of the concept should follow a standardized schema (realized as
            data specification template).</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASc-3a-004',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="category">category</ReferenceToAttribute> <literal>PROPERTY</literal> or
              <literal>VALUE</literal> using data specification IEC61360,
              the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> is mandatory and shall be
              one of: <literal>DATE</literal>, <literal>STRING</literal>, <literal>STRING_TRANSLATABLE</literal>, <literal>INTEGER_MEASURE</literal>,
              <literal>INTEGER_COUNT</literal>, <literal>INTEGER_CURRENCY</literal>, <literal>REAL_MEASURE</literal>, <literal>REAL_COUNT</literal>,
              <literal>REAL_CURRENCY</literal>, <literal>BOOLEAN</literal>, <literal>RATIONAL</literal>, <literal>RATIONAL_MEASURE</literal>,
              <literal>TIME</literal>, <literal>TIMESTAMP</literal>.</paragraph><note><paragraph>Note: categories are deprecated since V3.0 of Part 1a of the document series
              "Details of the Asset Administration Shell".</paragraph></note></field_body>""")],
          [
            'AASc-3a-005',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="category">category</ReferenceToAttribute> <literal>REFERENCE</literal>
              using data specification template IEC61360,
              the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> shall be
              one of: <literal>STRING</literal>, <literal>IRI</literal>, <literal>IRDI</literal>.</paragraph><note><paragraph>Note: categories are deprecated since V3.0 of Part 1a of the document series
              "Details of the Asset Administration Shell".</paragraph></note></field_body>""")],
          [
            'AASc-3a-006',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="category">category</ReferenceToAttribute> <literal>DOCUMENT</literal>
              using data specification IEC61360,
              the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> shall be one of <literal>FILE</literal>,
              <literal>BLOB</literal>, <literal>HTML</literal></paragraph><note><paragraph>Categories are deprecated since V3.0 of Part 1a of the document series
              "Details of the Asset Administration Shell".</paragraph></note></field_body>""")],
          [
            'AASc-3a-007',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="category">category</ReferenceToAttribute> <literal>QUALIFIER_TYPE</literal>
              using data specification IEC61360,
              the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> is mandatory and shall be
              defined.</paragraph><note><paragraph>Categories are deprecated since V3.0 of Part 1a of the document series
              "Details of the Asset Administration Shell".</paragraph></note></field_body>""")],
          [
            'AASc-3a-008',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> using data specification template IEC61360,
              <ReferenceToAttribute refuri="Data_specification_IEC_61360.definition">Data_specification_IEC_61360.definition</ReferenceToAttribute> is mandatory and shall be
              defined at least in English.</paragraph><paragraph>Exception: The concept description describes a value, i.e.
              <ReferenceToAttribute refuri="Data_specification_IEC_61360.value">Data_specification_IEC_61360.value</ReferenceToAttribute> is defined.</paragraph></field_body>""")],
          [
            'AASc-3a-003',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> using data specification template IEC61360,
              referenced via <ReferenceToAttribute refuri="Data_specification_IEC_61360.value_list">Data_specification_IEC_61360.value_list</ReferenceToAttribute>
              <ReferenceToAttribute refuri="Value_reference_pair.value_ID">Value_reference_pair.value_ID</ReferenceToAttribute>
              the <ReferenceToAttribute refuri="Data_specification_IEC_61360.value">Data_specification_IEC_61360.value</ReferenceToAttribute> shall be set.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Reference_types',
      literals=[
        EnumerationLiteral(
          name='External_reference',
          value='ExternalReference',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>External reference.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Model_reference',
          value='ModelReference',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Model reference.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Reference types</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Reference',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference_types',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Type of the reference.</paragraph>',
            remarks=[
              '<paragraph>Denotes, whether reference is an external reference or a model reference.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Property(
          name='referred_semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph><ReferenceToAttribute refuri="Has_semantics.semantic_ID">Has_semantics.semantic_ID</ReferenceToAttribute> of the referenced model element
              (<ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.Model_reference">Reference_types.Model_reference</ReferenceToAttribute>).</paragraph>"""),
            remarks=[
              '<paragraph>For external references there typically is no semantic ID.</paragraph>',
              '<note><paragraph>It is recommended to use a external reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Property(
          name='keys',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Key',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Unique references in their name space.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference_types',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='keys',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Key',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='referred_semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='keys',
              argument='keys',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='referred_semantic_ID',
              argument='referred_semantic_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='keys',
              argument='keys',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='referred_semantic_ID',
              argument='referred_semantic_ID',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Keys must contain at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='keys',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-121: For References the value of type of the first key of keys shall be one of Globally Identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-122: For external references the value of type of the first key of keys shall be one of Generic Globally Identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='External_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Generic_globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-123: For model references the value of type of the first key of keys shall be one of AAS identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='AAS_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-124: For external references the last key of keys shall be either one of Generic Globally Identifiables or one of Generic Fragment Keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='External_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_globally_identifiables',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-125: For model references with more than one key in keys the value of type of each of the keys following the first key of keys shall be one of Fragment Keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=1,
                    original_node=...),
                  end=FunctionCall(
                    name='len',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                condition=IsIn(
                  member=Member(
                    instance=Index(
                      collection=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...),
                      index=Name(
                        identifier='i',
                        original_node=...),
                      original_node=...),
                    name='type',
                    original_node=...),
                  container=Name(
                    identifier='Fragment_keys',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-126: For model references with more than one key in keys the value of type of the last key in the reference key chain may be one of Generic Fragment Keys or no key at all shall have a value out of Generic Fragment Keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Not(
                  operand=IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-127: For model references, with more than one key in keys a key with type Fragment Reference shall be preceded by a key with type File or Blob.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Fragment_reference',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='File',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Blob',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-128: For model references, the value of a key preceded by a key with type Submodel element list is an integer number denoting the position in the array of the submodel element list.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=2,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel_element_list',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='matches_xs_positive_integer',
                    args=[
                      Member(
                        instance=Index(
                          collection=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='keys',
                            original_node=...),
                          index=Add(
                            left=Name(
                              identifier='i',
                              original_node=...),
                            right=Constant(
                              value=1,
                              original_node=...),
                            original_node=...),
                          original_node=...),
                        name='value',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Reference to either a model element of the same or another AAS or to an external
          entity.</paragraph>"""),
        remarks=[
          '<paragraph>A reference is an ordered list of keys.</paragraph>',
          textwrap.dedent("""\
            <paragraph>A model reference is an ordered list of keys, each key referencing an element. The
            complete list of keys may for example be concatenated to a path that then gives
            unique access to an element.</paragraph>"""),
          '<paragraph>An external reference is a reference to an external entity.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-121',
            textwrap.dedent("""\
              <field_body><paragraph>For <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s the value of <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute> of the first key of "
              <ReferenceToAttribute refuri="keys">keys</ReferenceToAttribute> shall be one of <ReferenceToConstant refuri="Globally_identifiables">Globally_identifiables</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-122',
            textwrap.dedent("""\
              <field_body><paragraph>For external references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.External_reference">Reference_types.External_reference</ReferenceToAttribute>, the value
              of <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute> of the first key of <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> shall be one of
              <ReferenceToConstant refuri="Generic_globally_identifiables">Generic_globally_identifiables</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-123',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.Model_reference">Reference_types.Model_reference</ReferenceToAttribute>, the value
              of <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute> of the first key of <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> shall be one of
              <ReferenceToConstant refuri="AAS_identifiables">AAS_identifiables</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-124',
            textwrap.dedent("""\
              <field_body><paragraph>For external references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.External_reference">Reference_types.External_reference</ReferenceToAttribute>, the last
              key of <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> shall be either one of
              <ReferenceToConstant refuri="Generic_globally_identifiables">Generic_globally_identifiables</ReferenceToConstant> or one of
              <ReferenceToConstant refuri="Generic_fragment_keys">Generic_fragment_keys</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-125',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.Model_reference">Reference_types.Model_reference</ReferenceToAttribute>, with more
              than one key in <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> the value of <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute>
              of each of the keys following the first
              key of <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> shall be one of <ReferenceToConstant refuri="Fragment_keys">Fragment_keys</ReferenceToConstant>.</paragraph><note><paragraph><ReferenceToConstraint refuri="AASd-125">AASd-125</ReferenceToConstraint> ensures that the shortest path is used.</paragraph></note></field_body>""")],
          [
            'AASd-126',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.Model_reference">Reference_types.Model_reference</ReferenceToAttribute>, with more
              than one key in <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> the value of <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute>
              of the last key in the reference key chain may be
              one of <ReferenceToConstant refuri="Generic_fragment_keys">Generic_fragment_keys</ReferenceToConstant> or no key at all
              shall have a value out of <ReferenceToConstant refuri="Generic_fragment_keys">Generic_fragment_keys</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-127',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.Model_reference">Reference_types.Model_reference</ReferenceToAttribute>, with more
              than one key in <ReferenceToAttribute refuri="Reference.keys">Reference.keys</ReferenceToAttribute> a key with <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute>
              <ReferenceToAttribute refuri="Key_types.Fragment_reference">Key_types.Fragment_reference</ReferenceToAttribute> shall be preceded by a key with
              <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute> <ReferenceToAttribute refuri="Key_types.File">Key_types.File</ReferenceToAttribute> or <ReferenceToAttribute refuri="Key_types.Blob">Key_types.Blob</ReferenceToAttribute>. All other
              AAS fragments, i.e. <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute> values
              out of <ReferenceToConstant refuri="AAS_submodel_elements_as_keys">AAS_submodel_elements_as_keys</ReferenceToConstant>, do not support fragments.</paragraph><note><paragraph>Which kind of fragments are supported depends on the content type and the
              specification of allowed fragment identifiers for the corresponding resource
              being referenced via the reference.</paragraph></note></field_body>""")],
          [
            'AASd-128',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="Reference.type">Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Reference_types.Model_reference">Reference_types.Model_reference</ReferenceToAttribute>, the
              <ReferenceToAttribute refuri="Key.value">Key.value</ReferenceToAttribute> of a <ReferenceToOurType refuri="Key">Key</ReferenceToOurType> preceded by a <ReferenceToOurType refuri="Key">Key</ReferenceToOurType> with
              <ReferenceToAttribute refuri="Key.type">Key.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Key_types.Submodel_element_list">Key_types.Submodel_element_list</ReferenceToAttribute> is an integer
              number denoting the position in the array of the submodel element list.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Key',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Key_types',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Denotes which kind of entity is referenced.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>In case <ReferenceToAttribute refuri="type">type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Key_types.Global_reference">Key_types.Global_reference</ReferenceToAttribute>,
                the key represents a reference to a source that can be globally identified.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>In case <ReferenceToAttribute refuri="type">type</ReferenceToAttribute> = <ReferenceToAttribute refuri="Key_types.Fragment_reference">Key_types.Fragment_reference</ReferenceToAttribute> the key represents
                a bookmark or a similar local identifier within its parent element as specified
                by the key that precedes this key.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>In all other cases the key references a model element of the same or of another AAS.
                The name of the model element is explicitly listed.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Key',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The key value, for example an IRDI or an URI</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Key',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Key_types',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>A key is a reference to an element by its ID.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Key_types',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <ReferenceToAttribute refuri="Data_element">Data_element</ReferenceToAttribute>
                the reference may be a Property, a File etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Event.</paragraph>',
            remarks=[
              '<note><paragraph><ReferenceToOurType refuri="Event_element">Event_element</ReferenceToOurType> is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Bookmark or a similar local identifier of a subordinate part of
              a primary resource</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Identifiable',
          value='Identifiable',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Identifiable.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Identifiable is abstract, i.e. if a key uses “Identifiable” the reference
                may be an Asset Administration Shell, a Submodel or a Concept Description.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Referable',
          value='Referable',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Submodel Element is abstract, <emphasis>i.e.</emphasis> if a key uses <ReferenceToAttribute refuri="Submodel_element">Submodel_element</ReferenceToAttribute>
                the reference may be a <ReferenceToOurType refuri="Property">Property</ReferenceToOurType>, an <ReferenceToOurType refuri="Operation">Operation</ReferenceToOurType> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Data_type_def_XSD',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:nonNegativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          parsed=...)],
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration listing all XSD anySimpleTypes</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    AbstractClass(
      name='Abstract_lang_string',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Abstract_lang_string',
        name='Abstract_lang_string',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Lang_string_definition_type_IEC_61360',
          'Reference to ConcreteClass Lang_string_name_type',
          'Reference to ConcreteClass Lang_string_preferred_name_type_IEC_61360',
          'Reference to ConcreteClass Lang_string_short_name_type_IEC_61360',
          'Reference to ConcreteClass Lang_string_text_type'],
        properties=[
          Property(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Abstract_lang_string',
            parsed=...),
          Property(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Abstract_lang_string',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>Strings with language tags</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Lang_string_definition_type_IEC_61360',
        'Reference to ConcreteClass Lang_string_name_type',
        'Reference to ConcreteClass Lang_string_preferred_name_type_IEC_61360',
        'Reference to ConcreteClass Lang_string_short_name_type_IEC_61360',
        'Reference to ConcreteClass Lang_string_text_type'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Lang_string_definition_type_IEC_61360',
        'Reference to ConcreteClass Lang_string_name_type',
        'Reference to ConcreteClass Lang_string_preferred_name_type_IEC_61360',
        'Reference to ConcreteClass Lang_string_short_name_type_IEC_61360',
        'Reference to ConcreteClass Lang_string_text_type'],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_XML_serializable_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Strings with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Lang_string_name_type',
      inheritances=[
        'Reference to AbstractClass Abstract_lang_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Abstract_lang_string'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_XML_serializable_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Abstract_lang_string')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[
        Invariant(
          description='String shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_name_type',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>String with length 128 maximum and minimum 1 characters and with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Lang_string_text_type',
      inheritances=[
        'Reference to AbstractClass Abstract_lang_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Abstract_lang_string'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_XML_serializable_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Abstract_lang_string')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[
        Invariant(
          description='String shall have a maximum length of 1023 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=1023,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_text_type',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>String with length 1023 maximum and minimum 1 characters and with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Environment',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Asset_administration_shell',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Asset administration shell</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Submodel</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='concept_descriptions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Concept_description',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Concept description</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_administration_shells',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Asset_administration_shell',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='concept_descriptions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Concept_description',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_administration_shells',
              argument='asset_administration_shells',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='concept_descriptions',
              argument='concept_descriptions',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_administration_shells',
              argument='asset_administration_shells',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='concept_descriptions',
              argument='concept_descriptions',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Concept descriptions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='concept_descriptions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='concept_descriptions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Invariant(
          description='Submodels must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodels',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Invariant(
          description='Asset administration shells must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='asset_administration_shells',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='asset_administration_shells',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Container for the sets of different identifiables.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>w.r.t. file exchange: There is exactly one environment independent on how many
            files the contained elements are split. If the file is split then there
            shall be no element with the same identifier in two different files.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_specification_content',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_specification_content',
        name='Data_specification_content',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Data_specification_IEC_61360'],
        properties=[],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>Data specification content is part of a data specification template and defines
            which additional attributes shall be added to the element instance that references
            the data specification template and meta information about the template itself.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASc-3a-050',
              textwrap.dedent("""\
                <field_body><paragraph>If the <ReferenceToOurType refuri="Data_specification_IEC_61360">Data_specification_IEC_61360</ReferenceToOurType> is used
                for an element, the value of
                <ReferenceToAttribute refuri="Has_data_specification.embedded_data_specifications">Has_data_specification.embedded_data_specifications</ReferenceToAttribute>
                shall contain the global reference to the IRI of the corresponding
                data specification template
                <reference refuri="https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0">https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0</reference></paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      descendants=[
        'Reference to ConcreteClass Data_specification_IEC_61360'],
      concrete_descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Data_specification_IEC_61360'],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[],
        inlined_statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Data specification content is part of a data specification template and defines
          which additional attributes shall be added to the element instance that references
          the data specification template and meta information about the template itself.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASc-3a-050',
            textwrap.dedent("""\
              <field_body><paragraph>If the <ReferenceToOurType refuri="Data_specification_IEC_61360">Data_specification_IEC_61360</ReferenceToOurType> is used
              for an element, the value of
              <ReferenceToAttribute refuri="Has_data_specification.embedded_data_specifications">Has_data_specification.embedded_data_specifications</ReferenceToAttribute>
              shall contain the global reference to the IRI of the corresponding
              data specification template
              <reference refuri="https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0">https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0</reference></paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Embedded_data_specification',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='data_specification_content',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_specification_content',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Actual content of the data specification</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Embedded_data_specification',
          parsed=...),
        Property(
          name='data_specification',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the data specification</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Embedded_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='data_specification_content',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_specification_content',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='data_specification',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification_content',
              argument='data_specification_content',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification',
              argument='data_specification',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification_content',
              argument='data_specification_content',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification',
              argument='data_specification',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>Embed the content of a data specification.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    Enumeration(
      name='Data_type_IEC_61360',
      literals=[
        EnumerationLiteral(
          name='Date',
          value='DATE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
              Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
              "31 May 1999".</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='STRING',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values consisting of sequence of characters but cannot be translated into other
              languages</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='String_translatable',
          value='STRING_TRANSLATABLE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing string but shall be represented as different string in different
              languages</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_measure',
          value='INTEGER_MEASURE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing values that are measure of type INTEGER. In addition such a value
              comes with a physical unit.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_count',
          value='INTEGER_COUNT',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type INTEGER but are no currencies or measures</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_currency',
          value='INTEGER_CURRENCY',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type INTEGER that are currencies</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_measure',
          value='REAL_MEASURE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing values that are measures of type REAL. In addition such a value
              comes with a physical unit.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_count',
          value='REAL_COUNT',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing numbers that can be written as a terminating or non-terminating
              decimal; a rational or irrational number but are no currencies or measures</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_currency',
          value='REAL_CURRENCY',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type REAL that are currencies</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='BOOLEAN',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values representing truth of logic or Boolean algebra (TRUE, FALSE)</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='IRI',
          value='IRI',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type STRING conformant to Rfc 3987</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In IEC61360-1 (2017) only URI is supported.
                An IRI type allows in particular to express an URL or an URI.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='IRDI',
          value='IRDI',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values conforming to ISO/IEC 11179 series global identifier sequences</paragraph>',
            remarks=[
              '<paragraph>IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.</paragraph>',
              textwrap.dedent("""\
                <paragraph>ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
                is “#” while the delimiter between DI and VI is confined to “##”</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>ISO29002_IRDI values are values containing a global identifier that identifies an
                administrated item in a registry. The structure of this identifier complies with
                identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
                requirements specified in ISO/TS 29002-5 for an "international registration data
                identifier" (IRDI).</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Rational',
          value='RATIONAL',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type rational</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Rational_measure',
          value='RATIONAL_MEASURE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing values of type rational. In addition such a value comes with a
              physical unit.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='TIME',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing a time, conformant to ISO 8601:2004 but restricted to what is
              allowed in the corresponding type in xml.</paragraph>"""),
            remarks=[
              '<paragraph>Format hh:mm (ECLASS)</paragraph>',
              textwrap.dedent("""\
                <paragraph>Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
                1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
                Universal Time (UTC).</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Timestamp',
          value='TIMESTAMP',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing a time, conformant to ISO 8601:2004 but restricted to what is
              allowed in the corresponding type in xml.</paragraph>"""),
            remarks=[
              '<paragraph>Format yyyy-mm-dd hh:mm (ECLASS)</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='FILE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing an address to a file. The values are of type URI and can represent
              an absolute or relative path.</paragraph>"""),
            remarks=[
              '<note><paragraph>IEC61360 does not support the file type.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='HTML',
          value='HTML',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Values containing string with any sequence of characters, using the syntax of HTML5
              (see W3C Recommendation 28:2014)</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='BLOB',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing the content of a file. Values may be binaries.</paragraph>',
            remarks=[
              '<paragraph>HTML conformant to HTML5 is a special blob.</paragraph>',
              textwrap.dedent("""\
                <paragraph>In IEC61360 binary is for a sequence of bits, each bit being represented by “0” and
                “1” only. A binary is a blob but a blob may also contain other source code.</paragraph>""")],
            parsed=...),
          parsed=...)],
      description=None,
      literals_by_name=...,
      literals_by_value=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Level_type',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='min',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Minimum of the value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Level_type',
          parsed=...),
        Property(
          name='nom',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Nominal value (value as designated)</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Level_type',
          parsed=...),
        Property(
          name='typ',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value as typically present</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Level_type',
          parsed=...),
        Property(
          name='max',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Maximum of the value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Level_type',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='min',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='nom',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='typ',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='max',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='min',
              argument='min',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='nom',
              argument='nom',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='typ',
              argument='typ',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max',
              argument='max',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='min',
              argument='min',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='nom',
              argument='nom',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='typ',
              argument='typ',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max',
              argument='max',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Value represented by up to four variants of a numeric value in a specific role:
          <literal>MIN</literal>, <literal>NOM</literal>, <literal>TYP</literal> and <literal>MAX</literal>. True means that the value is available,
          false means the value is not available.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>EXAMPLE from [IEC61360-1]: In the case of having a property which is
            of the LEVEL_TYPE min/max − expressing a range − only those two values
            need to be provided.</paragraph>"""),
          textwrap.dedent("""\
            <note><paragraph>This is how AAS deals with the following combinations of level types:</paragraph><bullet_list bullet="-"><list_item><paragraph>Either all attributes are false. In this case the concept is mapped
            to a <ReferenceToOurType refuri="Property">Property</ReferenceToOurType> and level type is ignored.</paragraph></list_item><list_item><paragraph>At most one of the attributes is set to true. In this case
            the concept is mapped to a <ReferenceToOurType refuri="Property">Property</ReferenceToOurType>.</paragraph></list_item><list_item><paragraph>Min and max are set to true. In this case the concept is mapped
            to a <ReferenceToOurType refuri="Range">Range</ReferenceToOurType>.</paragraph></list_item><list_item><paragraph>More than one attribute is set to true but not min and max only
            (see second case). In this case the concept is mapped
            to a <ReferenceToOurType refuri="Submodel_element_collection">Submodel_element_collection</ReferenceToOurType> with the corresponding
            number of Properties.
            Example: If attribute <ReferenceToAttribute refuri="min">min</ReferenceToAttribute> and <ReferenceToAttribute refuri="nom">nom</ReferenceToAttribute> are set to true
            then the concept is mapped to a <ReferenceToOurType refuri="Submodel_element_collection">Submodel_element_collection</ReferenceToOurType>
            with two Properties within: min and nom.
            The data type of both Properties is the same.</paragraph></list_item></bullet_list></note>"""),
          textwrap.dedent("""\
            <note><paragraph>In the cases 2. and 4. the <ReferenceToAttribute refuri="Property.semantic_ID">Property.semantic_ID</ReferenceToAttribute> of the Property
            or Properties within the <ReferenceToOurType refuri="Submodel_element_collection">Submodel_element_collection</ReferenceToOurType> needs to include
            information about the level type. Otherwise, the semantics is not described
            in a unique way. Please refer to the specification.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Value_reference_pair',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Value_type_IEC_61360',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the referenced concept definition of the value in <ReferenceToAttribute refuri="value_ID">value_ID</ReferenceToAttribute>.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_reference_pair',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Global unique id of the value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_reference_pair',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Value_type_IEC_61360',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_ID',
              argument='value_ID',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A value reference pair within a value list. Each value has a global unique id
          defining its semantic.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Value_list',
      inheritances=[],
      inheritance_id_set=...,
      ancestors=[],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value_reference_pairs',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Value_reference_pair',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>A pair of a value together with its global unique id.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_list',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_reference_pairs',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Value_reference_pair',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value_reference_pairs',
              argument='value_reference_pairs',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value_reference_pairs',
              argument='value_reference_pairs',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Value reference pair types must contain at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_reference_pairs',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Value_list',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>A set of value reference pairs.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Lang_string_preferred_name_type_IEC_61360',
      inheritances=[
        'Reference to AbstractClass Abstract_lang_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Abstract_lang_string'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_XML_serializable_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Abstract_lang_string')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[
        Invariant(
          description='String shall have a maximum length of 255 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=255,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_preferred_name_type_IEC_61360',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>String with length 255 maximum and minimum 1 characters and with language tags</paragraph>',
        remarks=[
          '<note><paragraph>It is advised to keep the length of the name limited to 35 characters.</paragraph></note>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Lang_string_short_name_type_IEC_61360',
      inheritances=[
        'Reference to AbstractClass Abstract_lang_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Abstract_lang_string'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_XML_serializable_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Abstract_lang_string')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[
        Invariant(
          description='String shall have a maximum length of 18 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=18,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_short_name_type_IEC_61360',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>String with length 18 maximum and minimum 1 characters and with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Lang_string_definition_type_IEC_61360',
      inheritances=[
        'Reference to AbstractClass Abstract_lang_string'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Abstract_lang_string'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_XML_serializable_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="language">language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Abstract_lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            CallSuperConstructor(
              super_name='Abstract_lang_string')""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[
        Invariant(
          description='String shall have a maximum length of 1023 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=1023,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_definition_type_IEC_61360',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      description=DescriptionOfOurType(
        summary='<paragraph>String with length 1023 maximum and minimum 1 characters and with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Data_specification_IEC_61360',
      inheritances=[
        'Reference to AbstractClass Data_specification_content'],
      inheritance_id_set=...,
      ancestors=[
        'Reference to AbstractClass Data_specification_content'],
      ancestor_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      descendants=[],
      concrete_descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='preferred_name',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Lang_string_preferred_name_type_IEC_61360',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Preferred name</paragraph>',
            remarks=[
              '<note><paragraph>It is advised to keep the length of the name limited to 35 characters.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASc-3a-002',
                '<field_body><paragraph><ReferenceToAttribute refuri="preferred_name">preferred_name</ReferenceToAttribute> shall be provided at least in English.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='short_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_short_name_type_IEC_61360',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Short name</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='unit',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='unit_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Unique unit id</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph><ReferenceToAttribute refuri="unit">unit</ReferenceToAttribute> and <ReferenceToAttribute refuri="unit_ID">unit_ID</ReferenceToAttribute> need to be consistent if both attributes
                are set</paragraph>"""),
              '<note><paragraph>It is recommended to use an external reference ID.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='source_of_definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Source of definition</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='symbol',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Symbol</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='data_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Data_type_IEC_61360',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data Type</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='definition',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_definition_type_IEC_61360',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Definition in different languages</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='value_format',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_XML_serializable_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value Format</paragraph>',
            remarks=[
              '<note><paragraph>The value format is based on ISO 13584-42 and IEC 61360-2.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='value_list',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_list',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>List of allowed values</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_type_IEC_61360',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='level_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Level_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Set of levels.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='preferred_name',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string_preferred_name_type_IEC_61360',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='short_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_short_name_type_IEC_61360',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_XML_serializable_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='source_of_definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_XML_serializable_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='symbol',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_XML_serializable_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Data_type_IEC_61360',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='definition',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string_definition_type_IEC_61360',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_format',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_XML_serializable_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_list',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_list',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_type_IEC_61360',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='level_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Level_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='preferred_name',
              argument='preferred_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='short_name',
              argument='short_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit',
              argument='unit',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit_ID',
              argument='unit_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_of_definition',
              argument='source_of_definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='symbol',
              argument='symbol',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_type',
              argument='data_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='definition',
              argument='definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_format',
              argument='value_format',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_list',
              argument='value_list',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='level_type',
              argument='level_type',
              default=None)""")],
        inlined_statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='preferred_name',
              argument='preferred_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='short_name',
              argument='short_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit',
              argument='unit',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit_ID',
              argument='unit_ID',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_of_definition',
              argument='source_of_definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='symbol',
              argument='symbol',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_type',
              argument='data_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='definition',
              argument='definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_format',
              argument='value_format',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_list',
              argument='value_list',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='level_type',
              argument='level_type',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASc-3a-010: If value is not empty then value list shall be empty and vice versa.',
          body=textwrap.dedent("""\
            Not(
              operand=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_list',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Constraint AASc-3a-009: If data type is a an integer, real or rational with a measure or currency, unit or unit ID shall be defined.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='data_type',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='data_type',
                      original_node=...),
                    container=Name(
                      identifier='IEC_61360_data_types_with_unit',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='unit',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='unit_ID',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Definition must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='definition',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Definition must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='definition',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Short name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='short_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='short_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Short name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='short_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='short_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Preferred name must have at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='preferred_name',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Preferred name must specify unique languages.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='lang_strings_have_unique_languages',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='preferred_name',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Constraint AASc-002: preferred name shall be provided at least in English.',
          body=textwrap.dedent("""\
            Any(
              generator=ForEach(
                variable=Name(
                  identifier='lang_string',
                  original_node=...),
                iteration=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='preferred_name',
                  original_node=...),
                original_node=...),
              condition=FunctionCall(
                name='is_BCP_47_for_english',
                args=[
                  Member(
                    instance=Name(
                      identifier='lang_string',
                      original_node=...),
                    name='language',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Content of data specification template for concept descriptions for properties,
          values and value lists conformant to IEC 61360.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>IEC61360 requires also a globally unique identifier for a concept
            description. This ID is not part of the data specification template.
            Instead the <ReferenceToAttribute refuri="Concept_description.ID">Concept_description.ID</ReferenceToAttribute> as inherited via
            <ReferenceToOurType refuri="Identifiable">Identifiable</ReferenceToOurType> is used. Same holds for administrative
            information like the version and revision.</paragraph></note>"""),
          textwrap.dedent("""\
            <note><paragraph><ReferenceToAttribute refuri="Concept_description.ID_short">Concept_description.ID_short</ReferenceToAttribute> and <ReferenceToAttribute refuri="short_name">short_name</ReferenceToAttribute> are very
            similar. However, in this case the decision was to add
            <ReferenceToAttribute refuri="short_name">short_name</ReferenceToAttribute> explicitly to the data specification. Same holds for
            <ReferenceToAttribute refuri="Concept_description.display_name">Concept_description.display_name</ReferenceToAttribute> and
            <ReferenceToAttribute refuri="preferred_name">preferred_name</ReferenceToAttribute>. Same holds for
            <ReferenceToAttribute refuri="Concept_description.description">Concept_description.description</ReferenceToAttribute> and <ReferenceToAttribute refuri="definition">definition</ReferenceToAttribute>.</paragraph></note>""")],
        constraints_by_identifier=[
          [
            'AASc-3a-010',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> is not empty then <ReferenceToAttribute refuri="value_list">value_list</ReferenceToAttribute> shall be empty
              and vice versa.</paragraph><note><paragraph>It is also possible that both <ReferenceToAttribute refuri="value">value</ReferenceToAttribute> and <ReferenceToAttribute refuri="value_list">value_list</ReferenceToAttribute> are
              empty. This is the case for concept descriptions that define the semantics
              of a property but do not have an enumeration (<ReferenceToAttribute refuri="value_list">value_list</ReferenceToAttribute>) as
              data type.</paragraph></note><note><paragraph>Although it is possible to define a <ReferenceToOurType refuri="Concept_description">Concept_description</ReferenceToOurType> for a
              :attr:´value_list`,
              it is not possible to reuse this <ReferenceToAttribute refuri="value_list">value_list</ReferenceToAttribute>.
              It is only possible to directly add a <ReferenceToAttribute refuri="value_list">value_list</ReferenceToAttribute> as data type
              to a specific semantic definition of a property.</paragraph></note></field_body>""")],
          [
            'AASc-3a-009',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="data_type">data_type</ReferenceToAttribute> one of:
              <ReferenceToAttribute refuri="Data_type_IEC_61360.Integer_measure">Data_type_IEC_61360.Integer_measure</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="Data_type_IEC_61360.Real_measure">Data_type_IEC_61360.Real_measure</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="Data_type_IEC_61360.Rational_measure">Data_type_IEC_61360.Rational_measure</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="Data_type_IEC_61360.Integer_currency">Data_type_IEC_61360.Integer_currency</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="Data_type_IEC_61360.Real_currency">Data_type_IEC_61360.Real_currency</ReferenceToAttribute>, then <ReferenceToAttribute refuri="unit">unit</ReferenceToAttribute> or
              <ReferenceToAttribute refuri="unit_ID">unit_ID</ReferenceToAttribute> shall be defined.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      method_id_set=...,
      invariant_id_set=...)],
  our_types_topologically_sorted=[
    'Reference to our type Abstract_lang_string',
    'Reference to our type Has_data_specification',
    'Reference to our type Administrative_information',
    'Reference to our type Has_extensions',
    'Reference to our type Referable',
    'Reference to our type Has_semantics',
    'Reference to our type Qualifiable',
    'Reference to our type Submodel_element',
    'Reference to our type Relationship_element',
    'Reference to our type Annotated_relationship_element',
    'Reference to our type Identifiable',
    'Reference to our type Asset_administration_shell',
    'Reference to our type Asset_information',
    'Reference to our type BCP_47_language_tag',
    'Reference to our type Event_element',
    'Reference to our type Basic_event_element',
    'Reference to our type Data_element',
    'Reference to our type Blob',
    'Reference to our type Blob_type',
    'Reference to our type Capability',
    'Reference to our type Concept_description',
    'Reference to our type Non_empty_XML_serializable_string',
    'Reference to our type Content_type',
    'Reference to our type Data_specification_content',
    'Reference to our type Data_specification_IEC_61360',
    'Reference to our type Date_time_UTC',
    'Reference to our type Duration',
    'Reference to our type Embedded_data_specification',
    'Reference to our type Entity',
    'Reference to our type Environment',
    'Reference to our type Event_payload',
    'Reference to our type Extension',
    'Reference to our type File',
    'Reference to our type Has_kind',
    'Reference to our type Name_type',
    'Reference to our type ID_short_type',
    'Reference to our type Identifier',
    'Reference to our type Key',
    'Reference to our type Label_type',
    'Reference to our type Lang_string_definition_type_IEC_61360',
    'Reference to our type Lang_string_name_type',
    'Reference to our type Lang_string_preferred_name_type_IEC_61360',
    'Reference to our type Lang_string_short_name_type_IEC_61360',
    'Reference to our type Lang_string_text_type',
    'Reference to our type Level_type',
    'Reference to our type Message_topic_type',
    'Reference to our type Multi_language_property',
    'Reference to our type Operation',
    'Reference to our type Operation_variable',
    'Reference to our type Path_type',
    'Reference to our type Property',
    'Reference to our type Qualifier',
    'Reference to our type Qualifier_type',
    'Reference to our type Range',
    'Reference to our type Reference',
    'Reference to our type Reference_element',
    'Reference to our type Resource',
    'Reference to our type Revision_type',
    'Reference to our type Specific_asset_ID',
    'Reference to our type Submodel',
    'Reference to our type Submodel_element_collection',
    'Reference to our type Submodel_element_list',
    'Reference to our type Value_data_type',
    'Reference to our type Value_list',
    'Reference to our type Value_reference_pair',
    'Reference to our type Value_type_IEC_61360',
    'Reference to our type Version_type'],
  enumerations=[
    'Reference to our type Modelling_kind',
    'Reference to our type Qualifier_kind',
    'Reference to our type Asset_kind',
    'Reference to our type AAS_submodel_elements',
    'Reference to our type Entity_type',
    'Reference to our type Direction',
    'Reference to our type State_of_event',
    'Reference to our type Reference_types',
    'Reference to our type Key_types',
    'Reference to our type Data_type_def_XSD',
    'Reference to our type Data_type_IEC_61360'],
  constrained_primitives=[
    'Reference to our type Non_empty_XML_serializable_string',
    'Reference to our type Date_time_UTC',
    'Reference to our type Duration',
    'Reference to our type Blob_type',
    'Reference to our type Identifier',
    'Reference to our type Value_type_IEC_61360',
    'Reference to our type Name_type',
    'Reference to our type Version_type',
    'Reference to our type Revision_type',
    'Reference to our type Label_type',
    'Reference to our type Message_topic_type',
    'Reference to our type BCP_47_language_tag',
    'Reference to our type Content_type',
    'Reference to our type Path_type',
    'Reference to our type Qualifier_type',
    'Reference to our type Value_data_type',
    'Reference to our type ID_short_type'],
  classes=[
    'Reference to our type Has_semantics',
    'Reference to our type Extension',
    'Reference to our type Has_extensions',
    'Reference to our type Referable',
    'Reference to our type Identifiable',
    'Reference to our type Has_kind',
    'Reference to our type Has_data_specification',
    'Reference to our type Administrative_information',
    'Reference to our type Qualifiable',
    'Reference to our type Qualifier',
    'Reference to our type Asset_administration_shell',
    'Reference to our type Asset_information',
    'Reference to our type Resource',
    'Reference to our type Specific_asset_ID',
    'Reference to our type Submodel',
    'Reference to our type Submodel_element',
    'Reference to our type Relationship_element',
    'Reference to our type Submodel_element_list',
    'Reference to our type Submodel_element_collection',
    'Reference to our type Data_element',
    'Reference to our type Property',
    'Reference to our type Multi_language_property',
    'Reference to our type Range',
    'Reference to our type Reference_element',
    'Reference to our type Blob',
    'Reference to our type File',
    'Reference to our type Annotated_relationship_element',
    'Reference to our type Entity',
    'Reference to our type Event_payload',
    'Reference to our type Event_element',
    'Reference to our type Basic_event_element',
    'Reference to our type Operation',
    'Reference to our type Operation_variable',
    'Reference to our type Capability',
    'Reference to our type Concept_description',
    'Reference to our type Reference',
    'Reference to our type Key',
    'Reference to our type Abstract_lang_string',
    'Reference to our type Lang_string_name_type',
    'Reference to our type Lang_string_text_type',
    'Reference to our type Environment',
    'Reference to our type Data_specification_content',
    'Reference to our type Embedded_data_specification',
    'Reference to our type Level_type',
    'Reference to our type Value_reference_pair',
    'Reference to our type Value_list',
    'Reference to our type Lang_string_preferred_name_type_IEC_61360',
    'Reference to our type Lang_string_short_name_type_IEC_61360',
    'Reference to our type Lang_string_definition_type_IEC_61360',
    'Reference to our type Data_specification_IEC_61360'],
  concrete_classes=[
    'Reference to our type Extension',
    'Reference to our type Administrative_information',
    'Reference to our type Qualifier',
    'Reference to our type Asset_administration_shell',
    'Reference to our type Asset_information',
    'Reference to our type Resource',
    'Reference to our type Specific_asset_ID',
    'Reference to our type Submodel',
    'Reference to our type Relationship_element',
    'Reference to our type Submodel_element_list',
    'Reference to our type Submodel_element_collection',
    'Reference to our type Property',
    'Reference to our type Multi_language_property',
    'Reference to our type Range',
    'Reference to our type Reference_element',
    'Reference to our type Blob',
    'Reference to our type File',
    'Reference to our type Annotated_relationship_element',
    'Reference to our type Entity',
    'Reference to our type Event_payload',
    'Reference to our type Basic_event_element',
    'Reference to our type Operation',
    'Reference to our type Operation_variable',
    'Reference to our type Capability',
    'Reference to our type Concept_description',
    'Reference to our type Reference',
    'Reference to our type Key',
    'Reference to our type Lang_string_name_type',
    'Reference to our type Lang_string_text_type',
    'Reference to our type Environment',
    'Reference to our type Embedded_data_specification',
    'Reference to our type Level_type',
    'Reference to our type Value_reference_pair',
    'Reference to our type Value_list',
    'Reference to our type Lang_string_preferred_name_type_IEC_61360',
    'Reference to our type Lang_string_short_name_type_IEC_61360',
    'Reference to our type Lang_string_definition_type_IEC_61360',
    'Reference to our type Data_specification_IEC_61360'],
  constants=[
    ConstantSetOfPrimitives(
      name='Valid_categories_for_data_element',
      a_type='STR',
      literals=[
        PrimitiveSetLiteral(
          value='CONSTANT',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='PARAMETER',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='VARIABLE',
          a_type='STR',
          parsed=...)],
      literal_value_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>Categories for <ReferenceToOurType refuri="Data_element">Data_element</ReferenceToOurType> as defined in <ReferenceToConstraint refuri="AASd-090">AASd-090</ReferenceToConstraint></paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Generic_fragment_keys',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Fragment_reference'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of all identifiable elements within an asset administration shell.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Generic_globally_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Global_reference'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Asset_administration_shell',
        'Reference to EnumerationLiteral Concept_description',
        'Reference to EnumerationLiteral Identifiable',
        'Reference to EnumerationLiteral Submodel'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_submodel_elements_as_keys',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_collection',
        'Reference to EnumerationLiteral Submodel_element_list'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of all submodel elements within an asset administration shell.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_referable_non_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_collection',
        'Reference to EnumerationLiteral Submodel_element_list'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_submodel_elements_as_keys'],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different fragment key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_referables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Asset_administration_shell',
        'Reference to EnumerationLiteral Concept_description',
        'Reference to EnumerationLiteral Identifiable',
        'Reference to EnumerationLiteral Submodel',
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Referable',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_collection',
        'Reference to EnumerationLiteral Submodel_element_list'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_referable_non_identifiables',
        'Reference to ConstantSetOfEnumerationLiterals AAS_identifiables'],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of referables. We need this to check that model references refer to a Referable. For example, the observed attribute of the Basic Event Element object must be a model reference to a Referable.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Globally_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Global_reference',
        'Reference to EnumerationLiteral Asset_administration_shell',
        'Reference to EnumerationLiteral Concept_description',
        'Reference to EnumerationLiteral Identifiable',
        'Reference to EnumerationLiteral Submodel'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_identifiables',
        'Reference to ConstantSetOfEnumerationLiterals Generic_globally_identifiables'],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Fragment_keys',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Fragment_reference',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_collection',
        'Reference to EnumerationLiteral Submodel_element_list'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_referable_non_identifiables',
        'Reference to ConstantSetOfEnumerationLiterals Generic_fragment_keys'],
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Data_type_IEC_61360_for_property_or_value',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral Date',
        'Reference to EnumerationLiteral String',
        'Reference to EnumerationLiteral String_translatable',
        'Reference to EnumerationLiteral Integer_measure',
        'Reference to EnumerationLiteral Integer_count',
        'Reference to EnumerationLiteral Integer_currency',
        'Reference to EnumerationLiteral Real_measure',
        'Reference to EnumerationLiteral Real_count',
        'Reference to EnumerationLiteral Real_currency',
        'Reference to EnumerationLiteral Boolean',
        'Reference to EnumerationLiteral Rational',
        'Reference to EnumerationLiteral Rational_measure',
        'Reference to EnumerationLiteral Time',
        'Reference to EnumerationLiteral Timestamp'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>IEC 61360 data types for concept descriptions categorized with PROPERTY or VALUE.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Data_type_IEC_61360_for_reference',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral String',
        'Reference to EnumerationLiteral IRI',
        'Reference to EnumerationLiteral IRDI'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>IEC 61360 data types for concept descriptions categorized with REFERENCE.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Data_type_IEC_61360_for_document',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral HTML'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>IEC 61360 data types for concept descriptions categorized with DOCUMENT.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='IEC_61360_data_types_with_unit',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral Integer_measure',
        'Reference to EnumerationLiteral Real_measure',
        'Reference to EnumerationLiteral Rational_measure',
        'Reference to EnumerationLiteral Integer_currency',
        'Reference to EnumerationLiteral Real_currency'],
      literal_id_set=...,
      subsets=[],
      description=DescriptionOfConstant(
        summary='<paragraph>These data types imply that the unit is defined in the data specification.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...)],
  constants_by_name=...,
  verification_functions=[
    PatternVerification(
      name='matches_ID_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid short ID.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[a-zA-Z][a-zA-Z0-9_]*$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_version_type',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid version string.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(0|[1-9][0-9]*)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_revision_type',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid revision string.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(0|[1-9][0-9]*)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_date_time_UTC',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:dateTime</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The time zone must be fixed to UTC. We verify only that the <literal>text</literal> matches
            a pre-defined pattern. We <emphasis>do not</emphasis> verify that the day of month is
            correct nor do we check for leap seconds.</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#dateTime">https://www.w3.org/TR/xmlschema-2/#dateTime</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|\\+00:00|-00:00)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    ImplementationSpecificVerification(
      name='is_xs_date_time_UTC',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a <literal>xs:dateTime</literal> with time zone set to UTC.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The <literal>text</literal> is assumed to match a pre-defined pattern for <literal>xs:dateTime</literal> with
            the time zone set to UTC. In this function, we check for days of month (e.g.,
            February 29th).</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#dateTime">https://www.w3.org/TR/xmlschema-2/#dateTime</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid <literal>xs:dateTime</literal> in UTC</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_MIME_type',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of MIME type.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The definition has been taken from:
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1">https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1</reference>,
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3">https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3</reference> and
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6">https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6</reference>.</paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+|"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*"))*$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='media_type',
          original_node=...)""")),
    PatternVerification(
      name='matches_RFC_8089_path',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a path conforming to the pattern of RFC 8089.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The definition has been taken from:
            <reference refuri="https://datatracker.ietf.org/doc/html/rfc8089">https://datatracker.ietf.org/doc/html/rfc8089</reference></paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern="^file:(//((localhost|(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)))?/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?)$",
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_BCP_47',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid BCP 47 language tag.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://en.wikipedia.org/wiki/IETF_language_tag">https://en.wikipedia.org/wiki/IETF_language_tag</reference></paragraph>'],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    ImplementationSpecificVerification(
      name='lang_strings_have_unique_languages',
      arguments=[
        Argument(
          name='lang_strings',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Abstract_lang_string',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToArgument refuri="lang_strings">lang_strings</ReferenceToArgument> do not have overlapping
          <ReferenceToAttribute refuri="Abstract_lang_string.language">Abstract_lang_string.language</ReferenceToAttribute>'s</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='qualifier_types_are_unique',
      arguments=[
        Argument(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Qualifier',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>\'s of <ReferenceToArgument refuri="qualifiers">qualifiers</ReferenceToArgument> are unique.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'qualifiers',
            '<field_body><paragraph>to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if all <ReferenceToAttribute refuri="Qualifier.type">Qualifier.type</ReferenceToAttribute>\'s are unique</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_XML_serializable_string',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of the Constraint AASd-130.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>Ensures that encoding is possible and interoperability between different
            serializations is possible.</paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_any_URI',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:anyURI</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#anyURI">https://www.w3.org/TR/xmlschema-2/#anyURI</reference> and
            <reference refuri="https://datatracker.ietf.org/doc/html/rfc3987">https://datatracker.ietf.org/doc/html/rfc3987</reference></paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern="^([a-zA-Z][a-zA-Z0-9+\\-.]*:(//((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|:)*@)?(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)(:[0-9]*)?(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|/(((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])){0})(\\?((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]|[/?])*)?(\\#((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[/?])*)?|(//((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|:)*@)?(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)(:[0-9]*)?(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|/(((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|@)+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])){0})(\\?((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]|[/?])*)?(\\#((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[/?])*)?)$",
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_base_64_binary',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:base64Binary</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#base64Binary">https://www.w3.org/TR/xmlschema-2/#base64Binary</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?)*(([A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/])|[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[AEIMQUYcgkosw048]\\x20?=|[A-Za-z0-9+/]\\x20?[AQgw]\\x20?= ?=))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_boolean',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:boolean</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#boolean">https://www.w3.org/TR/xmlschema-2/#boolean</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(true|false|1|0)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_date',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:date</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#date">https://www.w3.org/TR/xmlschema-2/#date</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_date_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:dateTime</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#dateTime">https://www.w3.org/TR/xmlschema-2/#dateTime</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    ImplementationSpecificVerification(
      name='is_xs_date_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a <literal>xs:dateTime</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The <literal>text</literal> is assumed to match a pre-defined pattern for <literal>xs:dateTime</literal>.
            In this function, we check for days of month (e.g., February 29th).</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#dateTime">https://www.w3.org/TR/xmlschema-2/#dateTime</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid <literal>xs:dateTime</literal></paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_xs_decimal',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:decimal</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#decimal">https://www.w3.org/TR/xmlschema-2/#decimal</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^((\\+|-)?([0-9]+\\.[0-9]+|\\.[0-9]+)|(\\+|-)?[0-9]+)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_double',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:double</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#double">https://www.w3.org/TR/xmlschema-2/#double</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:duration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#duration">https://www.w3.org/TR/xmlschema-2/#duration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_float',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:float</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#float">https://www.w3.org/TR/xmlschema-2/#float</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_g_day',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gDay</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#gDay">https://www.w3.org/TR/xmlschema-2/#gDay</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_g_month',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gMonth</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#gMonth">https://www.w3.org/TR/xmlschema-2/#gMonth</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_g_month_day',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gMonthDay</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#gMonthDay">https://www.w3.org/TR/xmlschema-2/#gMonthDay</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_g_year',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gYear</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#gYear">https://www.w3.org/TR/xmlschema-2/#gYear</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_g_year_month',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gYearMonth</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#gYearMonth">https://www.w3.org/TR/xmlschema-2/#gYearMonth</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_hex_binary',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:hexBinary</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#hexBinary">https://www.w3.org/TR/xmlschema-2/#hexBinary</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^([0-9a-fA-F]{2})*$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:time</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#time">https://www.w3.org/TR/xmlschema-2/#time</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:integer</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#integer">https://www.w3.org/TR/xmlschema-2/#integer</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?[0-9]+$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_long',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:long</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#long">https://www.w3.org/TR/xmlschema-2/#long</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,20}$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_int',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:int</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#int">https://www.w3.org/TR/xmlschema-2/#int</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,10}$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:short</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#short">https://www.w3.org/TR/xmlschema-2/#short</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,5}$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_byte',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:byte</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#byte">https://www.w3.org/TR/xmlschema-2/#byte</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,3}$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_non_negative_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:nonNegativeInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger">https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?[0-9]+)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_positive_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:positiveInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#positiveInteger">https://www.w3.org/TR/xmlschema-2/#positiveInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^\\+?0*[1-9][0-9]*$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_unsigned_long',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedLong</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#unsignedLong">https://www.w3.org/TR/xmlschema-2/#unsignedLong</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,20})$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_unsigned_int',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedInt</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#unsignedInt">https://www.w3.org/TR/xmlschema-2/#unsignedInt</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,10})$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_unsigned_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedShort</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#unsignedShort">https://www.w3.org/TR/xmlschema-2/#unsignedShort</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,5})$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_unsigned_byte',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedByte</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#unsignedByte">https://www.w3.org/TR/xmlschema-2/#unsignedByte</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,3})$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_non_positive_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:nonPositiveInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger">https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+0|0|-[0-9]+)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_negative_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:negativeInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#negativeInteger">https://www.w3.org/TR/xmlschema-2/#negativeInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0*[1-9][0-9]*)$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    PatternVerification(
      name='matches_xs_string',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:string</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema-2/#string">https://www.w3.org/TR/xmlschema-2/#string</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)""")),
    ImplementationSpecificVerification(
      name='value_consistent_with_XSD_type',
      arguments=[
        Argument(
          name='value',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the <ReferenceToArgument refuri="value">value</ReferenceToArgument> conforms to its <ReferenceToArgument refuri="value_type">value_type</ReferenceToArgument>.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'value',
            '<field_body><paragraph>which needs to conform</paragraph></field_body>'],
          [
            'value_type',
            '<field_body><paragraph>pre-defined value type</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="value">value</ReferenceToArgument> conforms</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    TranspilableVerification(
      name='is_model_reference_to',
      arguments=[
        Argument(
          name='reference',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='expected_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Key_types',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the target of the model reference matches the <ReferenceToArgument refuri="expected_type">expected_type</ReferenceToArgument>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    TranspilableVerification(
      name='is_model_reference_to_referable',
      arguments=[
        Argument(
          name='reference',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the target of the reference matches a <ReferenceToConstant refuri="AAS_referables">AAS_referables</ReferenceToConstant>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='ID_shorts_are_unique',
      arguments=[
        Argument(
          name='referables',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Referable',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Referable.ID_short">Referable.ID_short</ReferenceToAttribute>'s among the <ReferenceToArgument refuri="referables">referables</ReferenceToArgument> are
          unique.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='ID_shorts_of_variables_are_unique',
      arguments=[
        Argument(
          name='input_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='output_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='inoutput_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Referable.ID_short">Referable.ID_short</ReferenceToAttribute>'s among all the
          <ReferenceToArgument refuri="input_variables">input_variables</ReferenceToArgument>, <ReferenceToArgument refuri="output_variables">output_variables</ReferenceToArgument>
          and <ReferenceToArgument refuri="inoutput_variables">inoutput_variables</ReferenceToArgument> are unique.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='extension_names_are_unique',
      arguments=[
        Argument(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Extension',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the extension names are unique.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='submodel_elements_have_identical_semantic_IDs',
      arguments=[
        Argument(
          name='elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Submodel_element',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that all semantic IDs are identical, if specified.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='submodel_element_is_of_type',
      arguments=[
        Argument(
          name='element',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Submodel_element',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='element_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type AAS_submodel_elements',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the run-time type of the <ReferenceToArgument refuri="element">element</ReferenceToArgument> coincides with
          <ReferenceToArgument refuri="element_type">element_type</ReferenceToArgument>.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='properties_or_ranges_have_value_type',
      arguments=[
        Argument(
          name='elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Submodel_element',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that all the <ReferenceToArgument refuri="elements">elements</ReferenceToArgument> have the <ReferenceToArgument refuri="value_type">value_type</ReferenceToArgument>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='reference_key_values_equal',
      arguments=[
        Argument(
          name='that',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='other',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the two references are equal by comparing their key values.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_for_property_or_value_have_appropriate_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined
          appropriately for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_for_reference_have_appropriate_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined
          appropriately for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_for_document_have_appropriate_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined
          appropriately for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_have_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Data_specification_IEC_61360.data_type">Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined for all
          data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_have_value',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Data_specification_IEC_61360.value">Data_specification_IEC_61360.value</ReferenceToAttribute> is defined
          for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_have_definition_at_least_in_english',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="Data_specification_IEC_61360.definition">Data_specification_IEC_61360.definition</ReferenceToAttribute> is defined
          for all data specifications whose content is given as IEC 61360 at least in English.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='is_BCP_47_for_english',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the <ReferenceToArgument refuri="text">text</ReferenceToArgument> corresponds to a BCP47 code for english.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(en|EN)(-.*)?$',
      pattern_expr=textwrap.dedent("""\
        Name(
          identifier='pattern',
          original_node=...)"""))],
  verification_functions_by_name=...,
  meta_model=MetaModel(
    description=DescriptionOfMetaModel(
      summary='<paragraph>Provide an implementation of the Asset Administration Shell (AAS) V3.0.</paragraph>',
      remarks=[
        textwrap.dedent("""\
          <paragraph>The presented version of the Metamodel is related to the work of
          aas-core-works, which can be found here: <reference refuri="https://github.com/aas-core-works">https://github.com/aas-core-works</reference>.</paragraph>"""),
        textwrap.dedent("""\
          <paragraph>The presented content is neither related to the IDTA nor
          Plattform Industrie 4.0 and does not represent an official publication.</paragraph>"""),
        '<paragraph>We diverge from the book in the following points.</paragraph>',
        textwrap.dedent("""\
          <paragraph>We did not implement the following constraints as they are too general and can not
          be formalized as part of the core library, but affects external components such as
          AAS registry or AAS server:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ReferenceToConstraint refuri="AASd-022">AASd-022</ReferenceToConstraint></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>We did not implement the following constraints since they depend on registry and
          de-referencing of <ReferenceToOurType refuri="Reference">Reference</ReferenceToOurType> objects:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ReferenceToConstraint refuri="AASd-006">AASd-006</ReferenceToConstraint></paragraph></list_item><list_item><paragraph><ReferenceToConstraint refuri="AASd-007">AASd-007</ReferenceToConstraint></paragraph></list_item><list_item><paragraph><ReferenceToConstraint refuri="AASc-3a-003">AASc-3a-003</ReferenceToConstraint></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>Some constraints are not enforceable as they depend on the wider context
          such as language understanding, so we could not formalize them:</paragraph>"""),
        textwrap.dedent("""\
          <bullet_list bullet="*"><list_item><paragraph><ReferenceToConstraint refuri="AASd-012">AASd-012</ReferenceToConstraint>: This constraint requires that the texts inside
          <literal>Multi_language_property</literal> shall have the same meanings in the separate languages.
          This cannot be tested.</paragraph></list_item><list_item><paragraph><ReferenceToConstraint refuri="AASd-116">AASd-116</ReferenceToConstraint>: In the book, <ReferenceToConstraint refuri="AASd-116">AASd-116</ReferenceToConstraint> imposes a
          case-insensitive equality against <literal>globalAssetId</literal>. This is culturally-dependent,
          and depends on the system settings. For example, the case-folding
          for the letters "i" and "I" is different in Turkish from English.</paragraph><paragraph>We implement the constraint as case-sensitive instead to allow for interoperability
          across different culture settings.</paragraph></list_item></bullet_list>"""),
        textwrap.dedent("""\
          <paragraph>Furthermore, we diverge from the book in the following points regarding
          the enumerations. We have to implement subsets of enumerations as sets as common
          programming languages do not support inheritance of enumerations. The relationship
          between the properties and the sets is defined through invariants. This causes
          the following divergences:</paragraph>"""),
        textwrap.dedent("""\
          <bullet_list bullet="*"><list_item><paragraph>We decided therefore to remove the enumeration <literal>DataTypeDefRDF</literal>
          and keep only <ReferenceToOurType refuri="Data_type_def_XSD">Data_type_def_XSD</ReferenceToOurType> as enumeration. Otherwise, we would have
          to write redundant invariants all over the meta-model because <literal>DataTypeDefRDF</literal>
          is actually never used in any type definition.</paragraph></list_item><list_item><paragraph>The enumeration <ReferenceToOurType refuri="AAS_submodel_elements">AAS_submodel_elements</ReferenceToOurType> is used in two different contexts.
          One context is the definition of key types in a reference. Another context is
          the definition of element types in a <ReferenceToOurType refuri="Submodel_element_list">Submodel_element_list</ReferenceToOurType>.</paragraph><paragraph>To avoid confusion, we introduce two separate enumerations for the separate contexts.
          Firstly, a set of <ReferenceToOurType refuri="Key_types">Key_types</ReferenceToOurType>, <ReferenceToConstant refuri="AAS_submodel_elements_as_keys">AAS_submodel_elements_as_keys</ReferenceToConstant> to
          represent the first context (key type in a reference).
          Secondly, the enumeration <ReferenceToOurType refuri="AAS_submodel_elements">AAS_submodel_elements</ReferenceToOurType> is kept as designator
          for <ReferenceToAttribute refuri="Submodel_element_list.type_value_list_element">Submodel_element_list.type_value_list_element</ReferenceToAttribute>.</paragraph></list_item><list_item><paragraph>The specification introduces several types of <literal>Lang_string_set</literal>.
          These types differ between the allowed length of their text inside the singular
          <literal>Lang_string</literal> objects. Since the native representation of <literal>Lang_string_set</literal> as
          <literal>List</literal> of <literal>Lang_string</literal> is required by specification, it is impossible to
          introduce separate <literal>Lang_string_set</literal> types. Therefore, the distinction is drawn here
          between the <literal>Lang_string</literal> types.</paragraph><paragraph><literal>DefinitionTypeIEC61360</literal> is represented as a
          <literal>List</literal> of <ReferenceToOurType refuri="Lang_string_definition_type_IEC_61360">Lang_string_definition_type_IEC_61360</ReferenceToOurType></paragraph><paragraph><literal>MultiLanguageNameType</literal> is represented as a
          <literal>List</literal> of <ReferenceToOurType refuri="Lang_string_name_type">Lang_string_name_type</ReferenceToOurType></paragraph><paragraph><literal>PreferredNameTypeIEC61360</literal> is represented as a
          <literal>List</literal> of <ReferenceToOurType refuri="Lang_string_preferred_name_type_IEC_61360">Lang_string_preferred_name_type_IEC_61360</ReferenceToOurType></paragraph><paragraph><literal>ShortNameTypeIEC61360</literal> is represented as a
          <literal>List</literal> of <ReferenceToOurType refuri="Lang_string_short_name_type_IEC_61360">Lang_string_short_name_type_IEC_61360</ReferenceToOurType></paragraph><paragraph><literal>MultiLanguageTextType</literal> is represented as a
          <literal>List</literal> of <ReferenceToOurType refuri="Lang_string_text_type">Lang_string_text_type</ReferenceToOurType></paragraph><paragraph>Furthermore, since <literal>Lang_string</literal> is not used anywhere, we rename it to
          <ReferenceToOurType refuri="Abstract_lang_string">Abstract_lang_string</ReferenceToOurType>.</paragraph></list_item></bullet_list>"""),
        textwrap.dedent("""\
          <paragraph>Concerning the data specifications, we embed them within
          <ReferenceToOurType refuri="Has_data_specification">Has_data_specification</ReferenceToOurType> instead of referencing them <emphasis>via</emphasis> an external reference.
          The working group decided to change the rules for serialization <emphasis>after</emphasis> the book was
          published. The data specifications are critical in applications, but there is no
          possibility to access them through a data channel as they are not part of
          an environment.</paragraph>""")],
      constraints_by_identifier=[],
      parsed=...),
    version='V3.0',
    xml_namespace='https://admin-shell.io/aas/3/0'))