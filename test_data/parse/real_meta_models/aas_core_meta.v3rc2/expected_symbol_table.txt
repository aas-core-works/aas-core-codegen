UnverifiedSymbolTable(
  symbols=[
    ConcreteClass(
      name='Resource',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='path',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_kind',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Content_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='path',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_kind',
                node=...),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Content_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Date_time_stamp_UTC',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body="FunctionCall(\n  name='matches_xs_date_time_stamp_utc',\n  args=[\n    Name(\n      identifier='self',\n      original_node=...)],\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="FunctionCall(\n  name='is_xs_date_time_stamp_utc',\n  args=[\n    Name(\n      identifier='self',\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Non_empty_string',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Name(\n        identifier='self',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Blob_type',
      is_implementation_specific=False,
      inheritances=[
        'bytearray'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Data_type_def_RDF',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Lang_string',
          value='rdf:langString',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          3],
        index=4,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Decimal_build_in_types',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          7,
          7,
          11,
          3],
        index=1,
        fragment=None),
      description=None,
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Duration_build_in_types',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          11,
          3],
        index=2,
        fragment=None),
      description=None,
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Primitive_types',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          11,
          3],
        index=3,
        fragment=None),
      description=None,
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Data_type_def_XSD',
      is_superset_of=[
        'Decimal_build_in_types',
        'Duration_build_in_types',
        'Primitive_types'],
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          11,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Data_type_def',
      is_superset_of=[
        'Data_type_def_XSD',
        'Data_type_def_RDF'],
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Lang_string',
          value='rdf:langString',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Identifier',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='BCP_47_language_tag',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body="FunctionCall(\n  name='matches_BCP_47',\n  args=[\n    Name(\n      identifier='self',\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='language',
          type_annotation=AtomicTypeAnnotation(
            identifier='BCP_47_language_tag',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='str',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_set',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='lang_strings',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='lang_strings',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string',
                    node=...)],
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='lang_strings',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="FunctionCall(\n  name='lang_strings_have_unique_languages',\n  args=[\n    Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='lang_strings',\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Content_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body="FunctionCall(\n  name='matches_MIME_type',\n  args=[\n    Name(\n      identifier='self',\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Path_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body="FunctionCall(\n  name='matches_RFC_8089_path',\n  args=[\n    Name(\n      identifier='self',\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Qualifier_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_data_type',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Reference',
      is_implementation_specific=False,
      inheritances=[],
      properties=[],
      methods=[],
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_extensions',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Extension',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has_extensions needs to be unique.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='extensions',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='extension_names_are_unique',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='extensions',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Referable',
      is_implementation_specific=False,
      inheritances=[
        'Has_extensions'],
      properties=[
        Property(
          name='id_short',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='display_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='category',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='description',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='checksum',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-027: ID-short shall have a maximum length of 128 characters.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='id_short',\n      original_node=...),\n    original_node=...),\n  consequent=Comparison(\n    left=FunctionCall(\n      name='len',\n      args=[\n        Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='id_short',\n          original_node=...)],\n      original_node=...),\n    op='LE',\n    right=Constant(\n      value=128,\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_kind',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='kind',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Modeling_kind',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_semantics',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          6],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Qualifiable',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Qualifier',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='qualifiers',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='qualifier_types_are_unique',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='qualifiers',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          7],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_data_specification',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          9],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Submodel_element',
      is_implementation_specific=False,
      inheritances=[
        'Referable',
        'Has_kind',
        'Has_semantics',
        'Qualifiable',
        'Has_data_specification'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          6],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Qualifier',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Qualifier_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Qualifier_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-020: The value shall be consistent to the data type as defined in value_type.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='value_consistent_with_xsd_type',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...),\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value_type',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Data_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body="Or(\n  values=[\n    Comparison(\n      left=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='category',\n        original_node=...),\n      op='EQ',\n      right=Constant(\n        value='CONSTANT',\n        original_node=...),\n      original_node=...),\n    Comparison(\n      left=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='category',\n        original_node=...),\n      op='EQ',\n      right=Constant(\n        value='PARAMETER',\n        original_node=...),\n      original_node=...),\n    Comparison(\n      left=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='category',\n        original_node=...),\n      op='EQ',\n      right=Constant(\n        value='VARIABLE',\n        original_node=...),\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          5],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Reference_element',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Global_reference',
      is_implementation_specific=False,
      inheritances=[
        'Reference'],
      properties=[
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Model_reference',
      is_implementation_specific=False,
      inheritances=[
        'Reference'],
      properties=[
        Property(
          name='keys',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Key',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='referred_semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='keys',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Key',
                    node=...)],
                node=...),
              default=None,
              node=...),
            Argument(
              name='referred_semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='keys',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Key',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Key_elements',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=None,
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Key_elements',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Extension',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='name',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='refers_to',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Model_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='name',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_def_XSD',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='refers_to',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Model_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Identifiable',
      is_implementation_specific=False,
      inheritances=[
        'Referable'],
      properties=[
        Property(
          name='ID',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='administration',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Administrative_information',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Modeling_kind',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Template',
          value='TEMPLATE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Instance',
          value='INSTANCE',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Administrative_information',
      is_implementation_specific=False,
      inheritances=[
        'Has_data_specification'],
      properties=[
        Property(
          name='version',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='revision',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='version',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='revision',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-005: If version is not specified than also revision shall be unspecified. This means, a revision requires a version. If there is no version there is no revision neither. Revision is optional.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='revision',\n      original_node=...),\n    original_node=...),\n  consequent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='version',\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          5],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Asset_administration_shell',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='asset_information',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_information',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='submodels',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Model_reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='derived_from',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Model_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='asset_information',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_information',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodels',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Model_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='derived_from',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Model_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='derived_from',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='is_model_reference_to',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='derived_from',\n        original_node=...),\n      Member(\n        instance=Name(\n          identifier='Key_elements',\n          original_node=...),\n        name='Asset_administration_shell',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='submodels',\n      original_node=...),\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='reference',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='submodels',\n        original_node=...),\n      original_node=...),\n    condition=FunctionCall(\n      name='is_model_reference_to',\n      args=[\n        Name(\n          identifier='reference',\n          original_node=...),\n        Member(\n          instance=Name(\n            identifier='Key_elements',\n            original_node=...),\n          name='Submodel',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Asset_information',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_kind',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='global_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='specific_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Identifier_key_value_pair',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='default_thumbnail',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Resource',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='asset_kind',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_kind',
                node=...),
              default=None,
              node=...),
            Argument(
              name='global_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='specific_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Identifier_key_value_pair',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='default_thumbnail',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Resource',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Asset_kind',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=2,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Identifier_key_value_pair',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='key',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='external_subject_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='key',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='external_subject_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_kind',
        'Has_semantics',
        'Qualifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='submodel_elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodel_elements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Short IDs need to be defined for all the submodel elements.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='submodel_elements',\n      original_node=...),\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='element',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='submodel_elements',\n        original_node=...),\n      original_node=...),\n    condition=IsNotNone(\n      value=Member(\n        instance=Name(\n          identifier='element',\n          original_node=...),\n        name='id_short',\n        original_node=...),\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='submodel_elements',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='id_shorts_are_unique',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='submodel_elements',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          5],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Relationship_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='first',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='second',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='first',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='second',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          16],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel_element_list',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='type_value_list_element',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element_elements',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='order_relevant',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='bool',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='semantic_id_list_element',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type_list_element',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type_value_list_element',
              type_annotation=AtomicTypeAnnotation(
                identifier='Submodel_element_elements',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='order_relevant',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='bool',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id_list_element',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_type_list_element',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_def_XSD',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-107: If a first level child element has a semantic ID it shall be identical to semantic ID list element.',
          body="Implication(\n  antecedent=And(\n    values=[\n      IsNotNone(\n        value=Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='value',\n          original_node=...),\n        original_node=...),\n      IsNotNone(\n        value=Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='semantic_id_list_element',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='child',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...),\n      original_node=...),\n    condition=Implication(\n      antecedent=IsNotNone(\n        value=Member(\n          instance=Name(\n            identifier='child',\n            original_node=...),\n          name='semantic_id',\n          original_node=...),\n        original_node=...),\n      consequent=Comparison(\n        left=Member(\n          instance=Name(\n            identifier='child',\n            original_node=...),\n          name='semantic_id',\n          original_node=...),\n        op='EQ',\n        right=Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='semantic_id_list_element',\n          original_node=...),\n        original_node=...),\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description='Constraint AASd-114: If two first level child elements have a semantic ID then they shall be identical.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='submodel_elements_have_identical_semantic_ids',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description='Constraint AASd-108: All first level child elements shall have the same submodel element type as specified in type value list element.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='element',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...),\n      original_node=...),\n    condition=FunctionCall(\n      name='submodel_element_is_of_type',\n      args=[\n        Name(\n          identifier='element',\n          original_node=...),\n        Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='type_value_list_element',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description='Constraint AASd-109: If type value list element is equal to Property or Range value type list element shall be set and all first level child elements shall have the value type as specified in value type list element.',
          body="Implication(\n  antecedent=And(\n    values=[\n      IsNotNone(\n        value=Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='value',\n          original_node=...),\n        original_node=...),\n      Or(\n        values=[\n          Comparison(\n            left=Member(\n              instance=Name(\n                identifier='self',\n                original_node=...),\n              name='type_value_list_element',\n              original_node=...),\n            op='EQ',\n            right=Member(\n              instance=Name(\n                identifier='Submodel_element_elements',\n                original_node=...),\n              name='Property',\n              original_node=...),\n            original_node=...),\n          Comparison(\n            left=Member(\n              instance=Name(\n                identifier='self',\n                original_node=...),\n              name='type_value_list_element',\n              original_node=...),\n            op='EQ',\n            right=Member(\n              instance=Name(\n                identifier='Submodel_element_elements',\n                original_node=...),\n              name='Range',\n              original_node=...),\n            original_node=...)],\n        original_node=...)],\n    original_node=...),\n  consequent=And(\n    values=[\n      IsNotNone(\n        value=Member(\n          instance=Name(\n            identifier='self',\n            original_node=...),\n          name='value_type_list_element',\n          original_node=...),\n        original_node=...),\n      FunctionCall(\n        name='properties_or_ranges_have_value_type',\n        args=[\n          Member(\n            instance=Name(\n              identifier='self',\n              original_node=...),\n            name='value',\n            original_node=...),\n          Member(\n            instance=Name(\n              identifier='self',\n              original_node=...),\n            name='value_type_list_element',\n            original_node=...)],\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description='Short IDs need to be defined for all the elements.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='element',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...),\n      original_node=...),\n    condition=IsNotNone(\n      value=Member(\n        instance=Name(\n          identifier='element',\n          original_node=...),\n        name='id_short',\n        original_node=...),\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='id_shorts_are_unique',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          17],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel_element_struct',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Short IDs need to be defined for all the elements.',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='element',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...),\n      original_node=...),\n    condition=IsNotNone(\n      value=Member(\n        instance=Name(\n          identifier='element',\n          original_node=...),\n        name='id_short',\n        original_node=...),\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='id_shorts_are_unique',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          18],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Property',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='value',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='value_consistent_with_xsd_type',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value',\n        original_node=...),\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value_type',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          13],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Multi_language_property',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          11],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Range',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='min',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='min',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='max',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='max',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='value_consistent_with_xsd_type',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='max',\n        original_node=...),\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value_type',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...),
        Invariant(
          description=None,
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='min',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='value_consistent_with_xsd_type',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='min',\n        original_node=...),\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='value_type',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          14],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Blob',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='MIME_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Content_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Blob_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='MIME_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Content_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Blob_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='File',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='content_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Content_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Path_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Content_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Path_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          8],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      is_implementation_specific=False,
      inheritances=[
        'Relationship_element'],
      properties=[
        Property(
          name='annotation',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='first',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='second',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='annotation',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Data_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Direction',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='input',
          value='INPUT',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='output',
          value='OUTPUT',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='State_of_event',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='on',
          value='ON',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='off',
          value='OFF',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=2,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    AbstractClass(
      name='Event_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          7],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Basic_event_element',
      is_implementation_specific=False,
      inheritances=[
        'Event_element'],
      properties=[
        Property(
          name='observed',
          type_annotation=AtomicTypeAnnotation(
            identifier='Model_reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='direction',
          type_annotation=AtomicTypeAnnotation(
            identifier='Direction',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='state',
          type_annotation=AtomicTypeAnnotation(
            identifier='State_of_event',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='message_topic',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='message_broker',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Model_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='last_update',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='min_interval',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max_interval',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='observed',
              type_annotation=AtomicTypeAnnotation(
                identifier='Model_reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='direction',
              type_annotation=AtomicTypeAnnotation(
                identifier='Direction',
                node=...),
              default=None,
              node=...),
            Argument(
              name='state',
              type_annotation=AtomicTypeAnnotation(
                identifier='State_of_event',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='message_topic',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='message_broker',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Model_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='last_update',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_stamp_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='min_interval',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_stamp_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='max_interval',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_stamp_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Event_payload',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='source',
          type_annotation=AtomicTypeAnnotation(
            identifier='Model_reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='source_semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='observable_reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Model_reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='observable_semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='topic',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='subject_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Global_reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='time_stamp',
          type_annotation=AtomicTypeAnnotation(
            identifier='Date_time_stamp_UTC',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='payload',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='source',
              type_annotation=AtomicTypeAnnotation(
                identifier='Model_reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='observable_reference',
              type_annotation=AtomicTypeAnnotation(
                identifier='Model_reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='time_stamp',
              type_annotation=AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...),
              default=None,
              node=...),
            Argument(
              name='source_semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='observable_semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='topic',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='subject_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='payload',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Entity_type',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='COMANAGEDENTITY',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SELFMANAGEDENTITY',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Entity',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='entity_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Entity_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='statements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='global_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='specific_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Identifier_key_value_pair',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='entity_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Entity_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='statements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='global_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='specific_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Identifier_key_value_pair',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description="Constraint AASd-014: Either the attribute global asset ID or specific asset ID must be set if entity type is set to 'SelfManagedEntity'. They are not existing otherwise.",
          body="Or(\n  values=[\n    And(\n      values=[\n        Comparison(\n          left=Member(\n            instance=Name(\n              identifier='self',\n              original_node=...),\n            name='entity_type',\n            original_node=...),\n          op='EQ',\n          right=Member(\n            instance=Name(\n              identifier='Entity_type',\n              original_node=...),\n            name='Self_managed_entity',\n            original_node=...),\n          original_node=...),\n        Or(\n          values=[\n            And(\n              values=[\n                IsNotNone(\n                  value=Member(\n                    instance=Name(\n                      identifier='self',\n                      original_node=...),\n                    name='global_asset_id',\n                    original_node=...),\n                  original_node=...),\n                IsNone(\n                  value=Member(\n                    instance=Name(\n                      identifier='self',\n                      original_node=...),\n                    name='global_asset_id',\n                    original_node=...),\n                  original_node=...)],\n              original_node=...),\n            And(\n              values=[\n                IsNone(\n                  value=Member(\n                    instance=Name(\n                      identifier='self',\n                      original_node=...),\n                    name='global_asset_id',\n                    original_node=...),\n                  original_node=...),\n                IsNotNone(\n                  value=Member(\n                    instance=Name(\n                      identifier='self',\n                      original_node=...),\n                    name='global_asset_id',\n                    original_node=...),\n                  original_node=...)],\n              original_node=...)],\n          original_node=...)],\n      original_node=...),\n    And(\n      values=[\n        IsNone(\n          value=Member(\n            instance=Name(\n              identifier='self',\n              original_node=...),\n            name='global_asset_id',\n            original_node=...),\n          original_node=...),\n        IsNone(\n          value=Member(\n            instance=Name(\n              identifier='self',\n              original_node=...),\n            name='specific_asset_id',\n            original_node=...),\n          original_node=...)],\n      original_node=...)],\n  original_node=...)",
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Event',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          7],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Basic_Event',
      is_implementation_specific=False,
      inheritances=[
        'Event'],
      properties=[
        Property(
          name='observed',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='observed',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Operation',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='input_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='output_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='inoutput_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='input_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='output_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='inoutput_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          12],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Operation_variable',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          13],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Capability',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Concept_description',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='is_case_of',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='is_case_of',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description="Constraint AASd-051: A concept description shall have one of the following categories: 'VALUE', 'PROPERTY', 'REFERENCE', 'DOCUMENT', 'CAPABILITY',; 'RELATIONSHIP', 'COLLECTION', 'FUNCTION', 'EVENT', 'ENTITY', 'APPLICATION_CLASS', 'QUALIFIER', 'VIEW'.",
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='category',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='concept_description_category_is_valid',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='category',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          8],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='View',
      is_implementation_specific=False,
      inheritances=[
        'Referable',
        'Has_semantics',
        'Has_data_specification'],
      properties=[
        Property(
          name='contained_elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Global_reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Global_reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='contained_elements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          9],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Identifiable_elements',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=5,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Submodel_element_elements',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_struct',
          value='SubmodelElementStruct',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=4,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Referable_elements',
      is_superset_of=[
        'Submodel_element_elements',
        'Identifiable_elements'],
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_struct',
          value='SubmodelElementStruct',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Key_elements',
      is_superset_of=[
        'Referable_elements'],
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_struct',
          value='SubmodelElementStruct',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=2,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    AbstractClass(
      name='Data_specification_content',
      is_implementation_specific=False,
      inheritances=[],
      properties=[],
      methods=[],
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Data_type_IEC61360',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Date',
          value='DATE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='String',
          value='STRING',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='String_translatable',
          value='STRING_TRANSLATABLE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Integer_Measure',
          value='INTEGER_MEASURE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Integer_count',
          value='INTEGER_COUNT',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Integer_currency',
          value='INTEGER_CURRENCY',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Real_measure',
          value='REAL_MEASURE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Real_count',
          value='REAL_COUNT',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Real_currency',
          value='REAL_CURRENCY',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='BOOLEAN',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='IRI',
          value='IRI',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='IRDI',
          value='IRDI',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Rational',
          value='RATIONAL',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Rational_measure',
          value='RATIONAL_MEASURE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Time',
          value='TIME',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Timestamp',
          value='TIMESTAMP',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='FILE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='HTML',
          value='HTML',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='BLOB',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=2,
        fragment=None),
      description=None,
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Level_type',
      is_superset_of=[],
      literals=[
        EnumerationLiteral(
          name='Min',
          value='Min',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Max',
          value='Max',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Nom',
          value='Nom',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=5,
        fragment=None),
      description=None,
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Value_reference_pair',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value_id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=4,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_list',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value_reference_pairs',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_reference_pair',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_reference_pairs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Value_reference_pair',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Data_specification_IEC61360',
      is_implementation_specific=False,
      inheritances=[
        'Data_specification_content'],
      properties=[
        Property(
          name='preferred_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='short_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='unit',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='unit_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='source_of_definition',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='symbol',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='data_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_IEC61360',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='definition',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_format',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_list',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_list',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='level_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Level_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='preferred_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='short_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='unit',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='unit_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='source_of_definition',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='symbol',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_IEC61360',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='definition',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_format',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_list',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_list',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='level_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Level_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          3,
          2,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Data_specification_physical_unit',
      is_implementation_specific=False,
      inheritances=[
        'Data_specification_content'],
      properties=[
        Property(
          name='unit_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='unit_symbol',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='definition',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='SI_notation',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='SI_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='DIN_notation',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='ECE_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='ECE_code',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='NIST_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='source_of_definition',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='conversion_factor',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='registration_authority_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='supplier',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='unit_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='unit_symbol',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='definition',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='SI_notation',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='SI_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='DIN_notation',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ECE_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ECE_code',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='NIST_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='source_of_definition',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='conversion_factor',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='registration_authority_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplier',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          4,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Environment',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Asset_administration_shell',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='submodels',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='concept_descriptions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Concept_description',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='asset_administration_shells',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Asset_administration_shell',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodels',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='concept_descriptions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Concept_description',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          9],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Data_specification',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='id',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='administration',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Administrative_information',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='description',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='data_specification_content',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_specification_content',
                node=...)],
            node=...),
          description=None,
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specification_content',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_specification_content',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...)],
  verification_functions=[
    UnderstoodMethod(
      name='matches_xs_date_time_stamp_utc',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='digit',\n    original_node=...),\n  value=Constant(\n    value='[0-9]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='year_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '-?(([1-9]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)|(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='month_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|(1[0-2]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='day_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|([12]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(3[01]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='hour_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(([01]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(2[0-3]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='minute_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='second_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '([0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')(\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='end_of_day_frag',\n    original_node=...),\n  value=Constant(\n    value='24:00:00(\\\\.0+)?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='timezone_frag',\n    original_node=...),\n  value=Constant(\n    value='Z',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='date_time_stamp_lexical_rep',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='year_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='month_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='day_frag',\n          original_node=...),\n        original_node=...),\n      'T((',\n      FormattedValue(\n        value=Name(\n          identifier='hour_frag',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='minute_frag',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='second_frag',\n          original_node=...),\n        original_node=...),\n      ')|',\n      FormattedValue(\n        value=Name(\n          identifier='end_of_day_frag',\n          original_node=...),\n        original_node=...),\n      ')',\n      FormattedValue(\n        value=Name(\n          identifier='timezone_frag',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='date_time_stamp_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_xs_date_time_stamp_utc',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_MIME_type',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        'Assignment(\n  target=Name(\n    identifier=\'tchar\',\n    original_node=...),\n  value=Constant(\n    value="[!#$%&\'*+\\\\-.^_`|~0-9a-zA-Z]",\n    original_node=...),\n  original_node=...)',
        "Assignment(\n  target=Name(\n    identifier='token',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='tchar',\n          original_node=...),\n        original_node=...),\n      ')+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='type',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='token',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='subtype',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='token',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ows',\n    original_node=...),\n  value=Constant(\n    value='[ \\t]*',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='obs_text',\n    original_node=...),\n  value=Constant(\n    value='[\\\\x80-\\\\xff]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='qd_text',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '([\\t !#-\\\\[\\\\]-~]|',\n      FormattedValue(\n        value=Name(\n          identifier='obs_text',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='quoted_pair',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '\\\\\\\\([\\t !-~]|',\n      FormattedValue(\n        value=Name(\n          identifier='obs_text',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        'Assignment(\n  target=Name(\n    identifier=\'quoted_string\',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      \'"(\',\n      FormattedValue(\n        value=Name(\n          identifier=\'qd_text\',\n          original_node=...),\n        original_node=...),\n      \'|\',\n      FormattedValue(\n        value=Name(\n          identifier=\'quoted_pair\',\n          original_node=...),\n        original_node=...),\n      \')*"\'],\n    original_node=...),\n  original_node=...)',
        "Assignment(\n  target=Name(\n    identifier='parameter',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='token',\n          original_node=...),\n        original_node=...),\n      '=(',\n      FormattedValue(\n        value=Name(\n          identifier='token',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='quoted_string',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='media_type',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='type',\n          original_node=...),\n        original_node=...),\n      '/',\n      FormattedValue(\n        value=Name(\n          identifier='subtype',\n          original_node=...),\n        original_node=...),\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ows',\n          original_node=...),\n        original_node=...),\n      ';',\n      FormattedValue(\n        value=Name(\n          identifier='ows',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='parameter',\n          original_node=...),\n        original_node=...),\n      ')*$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='media_type',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_RFC_8089_path',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='h16',\n    original_node=...),\n  value=Constant(\n    value='[0-9A-Fa-f]{1,4}',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='dec_octet',\n    original_node=...),\n  value=Constant(\n    value='([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipv4address',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ls32',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipv4address',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipv6address',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){6}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){5}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){4}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':)?',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){3}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){2}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){2}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){3}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){4}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){5}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){6}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::)'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='unreserved',\n    original_node=...),\n  value=Constant(\n    value='[a-zA-Z0-9\\\\-._~]',\n    original_node=...),\n  original_node=...)",
        'Assignment(\n  target=Name(\n    identifier=\'sub_delims\',\n    original_node=...),\n  value=Constant(\n    value="[!$&\'()*+,;=]",\n    original_node=...),\n  original_node=...)',
        "Assignment(\n  target=Name(\n    identifier='ipvfuture',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[vV][0-9A-Fa-f]+\\\\.(',\n      FormattedValue(\n        value=Name(\n          identifier='unreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      '|:)+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ip_literal',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '\\\\[(',\n      FormattedValue(\n        value=Name(\n          identifier='ipv6address',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipvfuture',\n          original_node=...),\n        original_node=...),\n      ')\\\\]'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pct_encoded',\n    original_node=...),\n  value=Constant(\n    value='%[0-9A-Fa-f][0-9A-Fa-f]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='reg_name',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='unreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='pct_encoded',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='host',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ip_literal',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipv4address',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='reg_name',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='file_auth',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(localhost|',\n      FormattedValue(\n        value=Name(\n          identifier='host',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pchar',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='unreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='pct_encoded',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      '|[:@])'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='segment_nz',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='pchar',\n          original_node=...),\n        original_node=...),\n      ')+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='segment',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='pchar',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='path_absolute',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '/(',\n      FormattedValue(\n        value=Name(\n          identifier='segment_nz',\n          original_node=...),\n        original_node=...),\n      '(/',\n      FormattedValue(\n        value=Name(\n          identifier='segment',\n          original_node=...),\n        original_node=...),\n      ')*)?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='auth_path',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='file_auth',\n          original_node=...),\n        original_node=...),\n      ')?',\n      FormattedValue(\n        value=Name(\n          identifier='path_absolute',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='local_path',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='path_absolute',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='file_hier_part',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(//',\n      FormattedValue(\n        value=Name(\n          identifier='auth_path',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='local_path',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='file_scheme',\n    original_node=...),\n  value=Constant(\n    value='file',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='file_uri',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='file_scheme',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='file_hier_part',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='file_uri',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_BCP_47',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='alphanum',\n    original_node=...),\n  value=Constant(\n    value='[a-zA-Z0-9]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='singleton',\n    original_node=...),\n  value=Constant(\n    value='[0-9A-WY-Za-wy-z]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='extension',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='singleton',\n          original_node=...),\n        original_node=...),\n      '(-(',\n      FormattedValue(\n        value=Name(\n          identifier='alphanum',\n          original_node=...),\n        original_node=...),\n      '){2,8})+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='extlang',\n    original_node=...),\n  value=Constant(\n    value='[a-zA-Z]{3}(-[a-zA-Z]{3}){2}',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='irregular',\n    original_node=...),\n  value=Constant(\n    value='(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='regular',\n    original_node=...),\n  value=Constant(\n    value='(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='grandfathered',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='irregular',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='regular',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='language',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '([a-zA-Z]{2,3}(-',\n      FormattedValue(\n        value=Name(\n          identifier='extlang',\n          original_node=...),\n        original_node=...),\n      ')?|[a-zA-Z]{4}|[a-zA-Z]{5,8})'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='script',\n    original_node=...),\n  value=Constant(\n    value='[a-zA-Z]{4}',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='region',\n    original_node=...),\n  value=Constant(\n    value='([a-zA-Z]{2}|[0-9]{3})',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='variant',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((',\n      FormattedValue(\n        value=Name(\n          identifier='alphanum',\n          original_node=...),\n        original_node=...),\n      '){5,8}|[0-9](',\n      FormattedValue(\n        value=Name(\n          identifier='alphanum',\n          original_node=...),\n        original_node=...),\n      '){3})'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='privateuse',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[xX](-(',\n      FormattedValue(\n        value=Name(\n          identifier='alphanum',\n          original_node=...),\n        original_node=...),\n      '){1,8})+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='langtag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='language',\n          original_node=...),\n        original_node=...),\n      '(-',\n      FormattedValue(\n        value=Name(\n          identifier='script',\n          original_node=...),\n        original_node=...),\n      ')?(-',\n      FormattedValue(\n        value=Name(\n          identifier='region',\n          original_node=...),\n        original_node=...),\n      ')?(-',\n      FormattedValue(\n        value=Name(\n          identifier='variant',\n          original_node=...),\n        original_node=...),\n      ')*(-',\n      FormattedValue(\n        value=Name(\n          identifier='extension',\n          original_node=...),\n        original_node=...),\n      ')*(-',\n      FormattedValue(\n        value=Name(\n          identifier='privateuse',\n          original_node=...),\n        original_node=...),\n      ')?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='language_tag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='langtag',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='privateuse',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='grandfathered',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='language_tag',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='lang_strings_have_unique_languages',
      verification=True,
      arguments=[
        Argument(
          name='lang_strings',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='qualifier_types_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='qualifiers',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Qualifier',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_any_URI',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='scheme',\n    original_node=...),\n  value=Constant(\n    value='[a-zA-Z][a-zA-Z0-9+\\\\-.]*',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ucschar',\n    original_node=...),\n  value=Constant(\n    value='[\\\\xa0-\\\\ud7ff\\\\uf900-\\\\ufdcf\\\\ufdf0-\\\\uffef\\\\u10000-\\\\u1fffd\\\\u20000-\\\\u2fffd\\\\u30000-\\\\u3fffd\\\\u40000-\\\\u4fffd\\\\u50000-\\\\u5fffd\\\\u60000-\\\\u6fffd\\\\u70000-\\\\u7fffd\\\\u80000-\\\\u8fffd\\\\u90000-\\\\u9fffd\\\\ua0000-\\\\uafffd\\\\ub0000-\\\\ubfffd\\\\uc0000-\\\\ucfffd\\\\ud0000-\\\\udfffd\\\\ue1000-\\\\uefffd]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='iunreserved',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '([a-zA-Z0-9\\\\-._~]|',\n      FormattedValue(\n        value=Name(\n          identifier='ucschar',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pct_encoded',\n    original_node=...),\n  value=Constant(\n    value='%[0-9A-Fa-f][0-9A-Fa-f]',\n    original_node=...),\n  original_node=...)",
        'Assignment(\n  target=Name(\n    identifier=\'sub_delims\',\n    original_node=...),\n  value=Constant(\n    value="[!$&\'()*+,;=]",\n    original_node=...),\n  original_node=...)',
        "Assignment(\n  target=Name(\n    identifier='iuserinfo',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='iunreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='pct_encoded',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      '|:)*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='h16',\n    original_node=...),\n  value=Constant(\n    value='[0-9A-Fa-f]{1,4}',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='dec_octet',\n    original_node=...),\n  value=Constant(\n    value='([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipv4address',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='dec_octet',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ls32',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipv4address',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipv6address',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){6}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){5}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){4}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':)?',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){3}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){2}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::(',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){2}',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){3}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){4}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::',\n      FormattedValue(\n        value=Name(\n          identifier='ls32',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){5}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      '|((',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ':){6}',\n      FormattedValue(\n        value=Name(\n          identifier='h16',\n          original_node=...),\n        original_node=...),\n      ')?::)'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='unreserved',\n    original_node=...),\n  value=Constant(\n    value='[a-zA-Z0-9\\\\-._~]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipvfuture',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[vV][0-9A-Fa-f]+\\\\.(',\n      FormattedValue(\n        value=Name(\n          identifier='unreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      '|:)+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ip_literal',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '\\\\[(',\n      FormattedValue(\n        value=Name(\n          identifier='ipv6address',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipvfuture',\n          original_node=...),\n        original_node=...),\n      ')\\\\]'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ireg_name',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='iunreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='pct_encoded',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ihost',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ip_literal',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipv4address',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ireg_name',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='port',\n    original_node=...),\n  value=Constant(\n    value='[0-9]*',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='iauthority',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='iuserinfo',\n          original_node=...),\n        original_node=...),\n      '@)?',\n      FormattedValue(\n        value=Name(\n          identifier='ihost',\n          original_node=...),\n        original_node=...),\n      '(:',\n      FormattedValue(\n        value=Name(\n          identifier='port',\n          original_node=...),\n        original_node=...),\n      ')?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipchar',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='iunreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='pct_encoded',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      '|[:@])'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='isegment',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ipchar',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipath_abempty',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(/',\n      FormattedValue(\n        value=Name(\n          identifier='isegment',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='isegment_nz',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ipchar',\n          original_node=...),\n        original_node=...),\n      ')+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipath_absolute',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '/(',\n      FormattedValue(\n        value=Name(\n          identifier='isegment_nz',\n          original_node=...),\n        original_node=...),\n      '(/',\n      FormattedValue(\n        value=Name(\n          identifier='isegment',\n          original_node=...),\n        original_node=...),\n      ')*)?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipath_rootless',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='isegment_nz',\n          original_node=...),\n        original_node=...),\n      '(/',\n      FormattedValue(\n        value=Name(\n          identifier='isegment',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipath_empty',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ipchar',\n          original_node=...),\n        original_node=...),\n      '){0}'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ihier_part',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(//',\n      FormattedValue(\n        value=Name(\n          identifier='iauthority',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='ipath_abempty',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipath_absolute',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipath_rootless',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipath_empty',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='iprivate',\n    original_node=...),\n  value=Constant(\n    value='[\\\\ue000-\\\\uf8ff\\\\uf0000-\\\\uffffd\\\\u100000-\\\\u10fffd]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='iquery',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ipchar',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='iprivate',\n          original_node=...),\n        original_node=...),\n      '|[/?])*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ifragment',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='ipchar',\n          original_node=...),\n        original_node=...),\n      '|[/?])*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='isegment_nz_nc',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='iunreserved',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='pct_encoded',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='sub_delims',\n          original_node=...),\n        original_node=...),\n      '|@)+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='ipath_noscheme',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='isegment_nz_nc',\n          original_node=...),\n        original_node=...),\n      '(/',\n      FormattedValue(\n        value=Name(\n          identifier='isegment',\n          original_node=...),\n        original_node=...),\n      ')*'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='irelative_part',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(//',\n      FormattedValue(\n        value=Name(\n          identifier='iauthority',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='ipath_abempty',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipath_absolute',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipath_noscheme',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='ipath_empty',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='irelative_ref',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='irelative_part',\n          original_node=...),\n        original_node=...),\n      '(\\\\?',\n      FormattedValue(\n        value=Name(\n          identifier='iquery',\n          original_node=...),\n        original_node=...),\n      ')?(\\\\#',\n      FormattedValue(\n        value=Name(\n          identifier='ifragment',\n          original_node=...),\n        original_node=...),\n      ')?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='iri',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='scheme',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='ihier_part',\n          original_node=...),\n        original_node=...),\n      '(\\\\?',\n      FormattedValue(\n        value=Name(\n          identifier='iquery',\n          original_node=...),\n        original_node=...),\n      ')?(\\\\#',\n      FormattedValue(\n        value=Name(\n          identifier='ifragment',\n          original_node=...),\n        original_node=...),\n      ')?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='iri_reference',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='iri',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='irelative_ref',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='iri_reference',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_base_64_binary',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='b04_char',\n    original_node=...),\n  value=Constant(\n    value='[AQgw]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b04',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='b04_char',\n          original_node=...),\n        original_node=...),\n      '\\\\x20?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b16_char',\n    original_node=...),\n  value=Constant(\n    value='[AEIMQUYcgkosw048]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b16',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='b16_char',\n          original_node=...),\n        original_node=...),\n      '\\\\x20?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b64_char',\n    original_node=...),\n  value=Constant(\n    value='[A-Za-z0-9+/]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b64',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='b64_char',\n          original_node=...),\n        original_node=...),\n      '\\\\x20?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b64quad',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b64_final_quad',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64_char',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='padded_8',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b04',\n          original_node=...),\n        original_node=...),\n      '= ?='],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='padded_16',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b64',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='b16',\n          original_node=...),\n        original_node=...),\n      '='],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='b64final',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='b64_final_quad',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='padded_16',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='padded_8',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='base64_binary',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='b64quad',\n          original_node=...),\n        original_node=...),\n      '*',\n      FormattedValue(\n        value=Name(\n          identifier='b64final',\n          original_node=...),\n        original_node=...),\n      ')?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='base64_binary',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_boolean',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=Constant(\n    value='^(true|false|1|0)$',\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='digit',\n    original_node=...),\n  value=Constant(\n    value='[0-9]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='year_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '-?(([1-9]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)|(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='month_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|(1[0-2]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='day_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|([12]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(3[01]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='minute_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='timezone_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(Z|(\\\\+|-)(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '|1[0-3]):',\n      FormattedValue(\n        value=Name(\n          identifier='minute_frag',\n          original_node=...),\n        original_node=...),\n      '|14:00)'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='date_lexical_rep',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='year_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='month_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='day_frag',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='timezone_frag',\n          original_node=...),\n        original_node=...),\n      '?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='date_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='digit',\n    original_node=...),\n  value=Constant(\n    value='[0-9]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='year_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '-?(([1-9]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)|(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='month_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|(1[0-2]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='day_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|([12]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(3[01]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='hour_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(([01]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(2[0-3]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='minute_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='second_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '([0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')(\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='end_of_day_frag',\n    original_node=...),\n  value=Constant(\n    value='24:00:00(\\\\.0+)?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='timezone_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(Z|(\\\\+|-)(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '|1[0-3]):',\n      FormattedValue(\n        value=Name(\n          identifier='minute_frag',\n          original_node=...),\n        original_node=...),\n      '|14:00)'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='date_time_lexical_rep',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='year_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='month_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='day_frag',\n          original_node=...),\n        original_node=...),\n      'T((',\n      FormattedValue(\n        value=Name(\n          identifier='hour_frag',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='minute_frag',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='second_frag',\n          original_node=...),\n        original_node=...),\n      ')|',\n      FormattedValue(\n        value=Name(\n          identifier='end_of_day_frag',\n          original_node=...),\n        original_node=...),\n      ')',\n      FormattedValue(\n        value=Name(\n          identifier='timezone_frag',\n          original_node=...),\n        original_node=...),\n      '?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='date_time_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time_stamp',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='digit',\n    original_node=...),\n  value=Constant(\n    value='[0-9]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='year_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '-?(([1-9]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)|(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='month_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|(1[0-2]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='day_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '((0[1-9])|([12]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(3[01]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='hour_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(([01]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')|(2[0-3]))'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='minute_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '[0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='second_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '([0-5]',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      ')(\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+)?'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='end_of_day_frag',\n    original_node=...),\n  value=Constant(\n    value='24:00:00(\\\\.0+)?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='timezone_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(Z|(\\\\+|-)(0',\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '|1[0-3]):',\n      FormattedValue(\n        value=Name(\n          identifier='minute_frag',\n          original_node=...),\n        original_node=...),\n      '|14:00)'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='date_time_stamp_lexical_rep',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='year_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='month_frag',\n          original_node=...),\n        original_node=...),\n      '-',\n      FormattedValue(\n        value=Name(\n          identifier='day_frag',\n          original_node=...),\n        original_node=...),\n      'T((',\n      FormattedValue(\n        value=Name(\n          identifier='hour_frag',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='minute_frag',\n          original_node=...),\n        original_node=...),\n      ':',\n      FormattedValue(\n        value=Name(\n          identifier='second_frag',\n          original_node=...),\n        original_node=...),\n      ')|',\n      FormattedValue(\n        value=Name(\n          identifier='end_of_day_frag',\n          original_node=...),\n        original_node=...),\n      ')',\n      FormattedValue(\n        value=Name(\n          identifier='timezone_frag',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='date_time_stamp_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_decimal',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='digit',\n    original_node=...),\n  value=Constant(\n    value='[0-9]',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='unsigned_no_decimal_pt_numeral',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='no_decimal_pt_numeral',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(\\\\+|-)?',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_no_decimal_pt_numeral',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='frac_frag',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      FormattedValue(\n        value=Name(\n          identifier='digit',\n          original_node=...),\n        original_node=...),\n      '+'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='unsigned_decimal_pt_numeral',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_no_decimal_pt_numeral',\n          original_node=...),\n        original_node=...),\n      '\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='frac_frag',\n          original_node=...),\n        original_node=...),\n      '|\\\\.',\n      FormattedValue(\n        value=Name(\n          identifier='frac_frag',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='decimal_pt_numeral',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(\\\\+|-)?',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_decimal_pt_numeral',\n          original_node=...),\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='decimal_lexical_rep',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '(',\n      FormattedValue(\n        value=Name(\n          identifier='decimal_pt_numeral',\n          original_node=...),\n        original_node=...),\n      '|',\n      FormattedValue(\n        value=Name(\n          identifier='no_decimal_pt_numeral',\n          original_node=...),\n        original_node=...),\n      ')'],\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='decimal_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_double',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='double_rep',\n    original_node=...),\n  value=Constant(\n    value='(\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|(\\\\+|-)?INF|NaN',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='double_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='duration_rep',\n    original_node=...),\n  value=Constant(\n    value='-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S))))',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='duration_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_float',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='float_rep',\n    original_node=...),\n  value=Constant(\n    value='(\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|(\\\\+|-)?INF|NaN',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='float_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_day',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='g_day_lexical_rep',\n    original_node=...),\n  value=Constant(\n    value='---(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='g_day_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_month',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='g_month_lexical_rep',\n    original_node=...),\n  value=Constant(\n    value='--(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='g_month_lexical_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_month_day',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='g_month_day_rep',\n    original_node=...),\n  value=Constant(\n    value='--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='g_month_day_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_year',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='g_year_rep',\n    original_node=...),\n  value=Constant(\n    value='-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='g_year_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_year_month',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='g_year_month_rep',\n    original_node=...),\n  value=Constant(\n    value='-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='g_year_month_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_hex_binary',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='hex_binary',\n    original_node=...),\n  value=Constant(\n    value='([0-9a-fA-F]{2})*',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='hex_binary',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='time_rep',\n    original_node=...),\n  value=Constant(\n    value='(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\\\.[0-9]+)?|(24:00:00(\\\\.0+)?))(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='time_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_day_time_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='day_time_duration_rep',\n    original_node=...),\n  value=Constant(\n    value='-?P((([0-9]+D)(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S))))',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='day_time_duration_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_year_month_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='year_month_duration_rep',\n    original_node=...),\n  value=Constant(\n    value='-?P((([0-9]+Y)([0-9]+M)?)|([0-9]+M))',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='year_month_duration_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='integer_rep',\n    original_node=...),\n  value=Constant(\n    value='[\\\\-+]?[0-9]+',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='integer_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_long',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='long_rep',\n    original_node=...),\n  value=Constant(\n    value='[\\\\-+]?[0-9]+',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='long_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_int',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='int_rep',\n    original_node=...),\n  value=Constant(\n    value='[\\\\-+]?[0-9]+',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='int_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='short_rep',\n    original_node=...),\n  value=Constant(\n    value='[\\\\-+]?[0-9]+',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='short_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_byte',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='byte_rep',\n    original_node=...),\n  value=Constant(\n    value='[\\\\-+]?[0-9]+',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='byte_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_non_negative_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='non_negative_integer_rep',\n    original_node=...),\n  value=Constant(\n    value='(-0|\\\\+?[0-9]+)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='non_negative_integer_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_positive_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='positive_integer_rep',\n    original_node=...),\n  value=Constant(\n    value='\\\\+?0*[1-9][0-9]*',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='positive_integer_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_long',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='unsigned_long_rep',\n    original_node=...),\n  value=Constant(\n    value='(-0|\\\\+?[0-9]+)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_long_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_int',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='unsigned_int_rep',\n    original_node=...),\n  value=Constant(\n    value='(-0|\\\\+?[0-9]+)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_int_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='unsigned_short_rep',\n    original_node=...),\n  value=Constant(\n    value='(-0|\\\\+?[0-9]+)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_short_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_byte',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='unsigned_byte_rep',\n    original_node=...),\n  value=Constant(\n    value='(-0|\\\\+?[0-9]+)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='unsigned_byte_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_non_positive_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='non_positive_integer_rep',\n    original_node=...),\n  value=Constant(\n    value='(\\\\+0|0|-[0-9]+)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='non_positive_integer_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_negative_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        "Assignment(\n  target=Name(\n    identifier='negative_integer_rep',\n    original_node=...),\n  value=Constant(\n    value='(-0*[1-9][0-9]*)',\n    original_node=...),\n  original_node=...)",
        "Assignment(\n  target=Name(\n    identifier='pattern',\n    original_node=...),\n  value=JoinedStr(\n    values=[\n      '^',\n      FormattedValue(\n        value=Name(\n          identifier='negative_integer_rep',\n          original_node=...),\n        original_node=...),\n      '$'],\n    original_node=...),\n  original_node=...)",
        "Return(\n  value=IsNotNone(\n    value=FunctionCall(\n      name='match',\n      args=[\n        Name(\n          identifier='pattern',\n          original_node=...),\n        Name(\n          identifier='text',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)"],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='value_consistent_with_xsd_type',
      verification=True,
      arguments=[
        Argument(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...),
        Argument(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_model_reference_to',
      verification=True,
      arguments=[
        Argument(
          name='reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Model_reference',
            node=...),
          default=None,
          node=...),
        Argument(
          name='expected_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Key_elements',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='id_shorts_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='namespace',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Referable',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='extension_names_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='extensions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Extension',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='submodel_elements_have_identical_semantic_ids',
      verification=True,
      arguments=[
        Argument(
          name='elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='submodel_element_is_of_type',
      verification=True,
      arguments=[
        Argument(
          name='element',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element',
            node=...),
          default=None,
          node=...),
        Argument(
          name='element_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element_elements',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='properties_or_ranges_have_value_type',
      verification=True,
      arguments=[
        Argument(
          name='elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...)],
            node=...),
          default=None,
          node=...),
        Argument(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='concept_description_category_is_valid',
      verification=True,
      arguments=[
        Argument(
          name='category',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...)],
  meta_model=MetaModel(
    description=Description(
      document=...,
      node=...),
    book_url='__book_url__',
    book_version='__book_version__'))