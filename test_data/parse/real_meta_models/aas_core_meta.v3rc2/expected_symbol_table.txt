UnverifiedSymbolTable(
  our_types=[
    ConcreteClass(
      name='Non_empty_string',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Date_time_stamp_UTC',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_date_time_stamp_utc',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_xs_date_time_stamp_utc',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Blob_type',
      is_implementation_specific=False,
      inheritances=[
        'bytearray'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Identifier',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='BCP_47_language_tag',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_BCP_47',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Content_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_MIME_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Path_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_RFC_8089_path',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Qualifier_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_string'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_data_type',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Id_short',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Constraint AASd-027: ID-short shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='ID-short of Referables shall only feature letters, digits, underscore (``_``); starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_id_short',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_semantics',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          6],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Extension',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='name',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='refers_to',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='value_type_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='name',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_def_XSD',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='refers_to',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_or_default',
                      original_node=...),
                    args=[],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_extensions',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Extension',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Referable',
      is_implementation_specific=False,
      inheritances=[
        'Has_extensions'],
      properties=[
        Property(
          name='category',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='id_short',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Id_short',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='display_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='description',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='checksum',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Identifiable',
      is_implementation_specific=False,
      inheritances=[
        'Referable'],
      properties=[
        Property(
          name='administration',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Administrative_information',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='id',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Modeling_kind',
      literals=[
        EnumerationLiteral(
          name='Template',
          value='Template',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    AbstractClass(
      name='Has_kind',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='kind',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Modeling_kind',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='Modeling_kind',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_data_specification',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          9],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Administrative_information',
      is_implementation_specific=False,
      inheritances=[
        'Has_data_specification'],
      properties=[
        Property(
          name='version',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='revision',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='version',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='revision',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-005: If version is not specified then also revision shall be unspecified. This means, a revision requires a version. If there is no version there is no revision either. Revision is optional.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='revision',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='version',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          5],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Qualifiable',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Qualifier',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          7],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Qualifier_kind',
      literals=[
        EnumerationLiteral(
          name='Value_qualifier',
          value='ValueQualifier',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Concept_qualifier',
          value='ConceptQualifier',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Template_qualifier',
          value='TemplateQualifier',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Qualifier',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='kind',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Qualifier_kind',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Qualifier_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='Qualifier_kind',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Qualifier_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Qualifier_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-020: The value shall be consistent to the data type as defined in value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Asset_administration_shell',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='derived_from',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='asset_information',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_information',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='submodels',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='asset_information',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_information',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='derived_from',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodels',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='derived_from',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='derived_from',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='Key_types',
                      original_node=...),
                    name='Asset_administration_shell',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='reference',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodels',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Name(
                      identifier='reference',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Asset_information',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_kind',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='global_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='specific_asset_ids',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Specific_asset_id',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='default_thumbnail',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Resource',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='asset_kind',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_kind',
                node=...),
              default=None,
              node=...),
            Argument(
              name='global_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='specific_asset_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Specific_asset_id',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='default_thumbnail',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Resource',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Resource',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='path',
          type_annotation=AtomicTypeAnnotation(
            identifier='Path_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Content_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='path',
              type_annotation=AtomicTypeAnnotation(
                identifier='Path_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Content_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Asset_kind',
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=2,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Specific_asset_id',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='name',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='external_subject_id',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='name',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...),
            Argument(
              name='external_subject_id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_kind',
        'Has_semantics',
        'Qualifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='submodel_elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodel_elements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='ID-shorts need to be defined for all the submodel elements.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-120: ID-short of non-identifiable referables shall be unique in its namespace.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='id_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          5],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Submodel_element',
      is_implementation_specific=False,
      inheritances=[
        'Referable',
        'Has_kind',
        'Has_semantics',
        'Qualifiable',
        'Has_data_specification'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          6],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Relationship_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='first',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='second',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='first',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='second',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          14],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='AAS_submodel_elements',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=None,
          node=...)],
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Submodel_element_list',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='order_relevant',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='bool',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='semantic_id_list_element',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='type_value_list_element',
          type_annotation=AtomicTypeAnnotation(
            identifier='AAS_submodel_elements',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type_list_element',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='order_relevant_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='bool',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type_value_list_element',
              type_annotation=AtomicTypeAnnotation(
                identifier='AAS_submodel_elements',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='order_relevant',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='bool',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id_list_element',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_type_list_element',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_def_XSD',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-107: If a first level child element has a semantic ID it shall be identical to semantic ID list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='semantic_id_list_element',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='child',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='child',
                        original_node=...),
                      name='semantic_id',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='reference_key_values_equal',
                    args=[
                      Member(
                        instance=Name(
                          identifier='child',
                          original_node=...),
                        name='semantic_id',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='semantic_id_list_element',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-114: If two first level child elements have a semantic ID then they shall be identical.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='submodel_elements_have_identical_semantic_ids',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-108: All first level child elements shall have the same submodel element type as specified in type value list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='submodel_element_is_of_type',
                  args=[
                    Name(
                      identifier='element',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type_value_list_element',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-109: If type value list element is equal to Property or Range value type list element shall be set and all first level child elements shall have the value type as specified in value type list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Property',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Range',
                          original_node=...),
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              consequent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_list_element',
                      original_node=...),
                    original_node=...),
                  FunctionCall(
                    name='properties_or_ranges_have_value_type',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_type_list_element',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-120: ID-shorts of submodel elements within a SubmodelElementList shall not be specified.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          16],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel_element_collection',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='ID-shorts need to be defined for all the elements.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='id_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Data_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=...,
                node=...)]),
          node=...,
          arguments_by_name=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          5],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Property',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          11],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Multi_language_property',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          9],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Range',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='min',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='min',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='max',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='max',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='min',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='min',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          12],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Reference_element',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Blob',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Blob_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Content_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Content_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Blob_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='File',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Path_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Content_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Content_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Path_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          8],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      is_implementation_specific=False,
      inheritances=[
        'Relationship_element'],
      properties=[
        Property(
          name='annotations',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='first',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='second',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='annotations',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Data_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Entity_type',
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='CoManagedEntity',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SelfManagedEntity',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Entity',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='statements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='entity_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Entity_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='global_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='specific_asset_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Specific_asset_id',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='entity_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Entity_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='statements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='global_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='specific_asset_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Specific_asset_id',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description="Constraint AASd-014: Either the attribute global asset ID or specific asset ID must be set if entity type is set to 'SelfManagedEntity'. They are not existing otherwise.",
          body=textwrap.dedent("""\
            Or(
              values=[
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='EQ',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    Or(
                      values=[
                        And(
                          values=[
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_id',
                                original_node=...),
                              original_node=...),
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_id',
                                original_node=...),
                              original_node=...)],
                          original_node=...),
                        And(
                          values=[
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_id',
                                original_node=...),
                              original_node=...),
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_id',
                                original_node=...),
                              original_node=...)],
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                And(
                  values=[
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_id',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_id',
                        original_node=...),
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Direction',
      literals=[
        EnumerationLiteral(
          name='Input',
          value='INPUT',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Output',
          value='OUTPUT',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='State_of_event',
      literals=[
        EnumerationLiteral(
          name='On',
          value='ON',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Off',
          value='OFF',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=2,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Event_payload',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='source',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='source_semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='observable_reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='observable_semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='topic',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='subject_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='time_stamp',
          type_annotation=AtomicTypeAnnotation(
            identifier='Date_time_stamp_UTC',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='payload',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='source',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='observable_reference',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='time_stamp',
              type_annotation=AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...),
              default=None,
              node=...),
            Argument(
              name='source_semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='observable_semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='topic',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='subject_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='payload',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='source',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observable_reference',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Event_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          7],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Basic_event_element',
      is_implementation_specific=False,
      inheritances=[
        'Event_element'],
      properties=[
        Property(
          name='observed',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='direction',
          type_annotation=AtomicTypeAnnotation(
            identifier='Direction',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='state',
          type_annotation=AtomicTypeAnnotation(
            identifier='State_of_event',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='message_topic',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='message_broker',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='last_update',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='min_interval',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max_interval',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_stamp_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='observed',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='direction',
              type_annotation=AtomicTypeAnnotation(
                identifier='Direction',
                node=...),
              default=None,
              node=...),
            Argument(
              name='state',
              type_annotation=AtomicTypeAnnotation(
                identifier='State_of_event',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='message_topic',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='message_broker',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='last_update',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_stamp_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='min_interval',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_stamp_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='max_interval',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_stamp_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Max. interval is not applicable for input direction',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='direction',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Direction',
                    original_node=...),
                  name='Input',
                  original_node=...),
                original_node=...),
              consequent=IsNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max_interval',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observed',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='message_broker',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to_referable',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='message_broker',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Operation',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='input_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='output_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='inoutput_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='input_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='output_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='inoutput_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          10],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Operation_variable',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          10],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Capability',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modeling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_ids',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          4],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Concept_description',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='is_case_of',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=...,
                node=...)]),
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='id_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Id_short',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='checksum',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='is_case_of',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description="Constraint AASd-051: A concept description shall have one of the following categories: 'VALUE', 'PROPERTY', 'REFERENCE', 'DOCUMENT', 'CAPABILITY',; 'RELATIONSHIP', 'COLLECTION', 'FUNCTION', 'EVENT', 'ENTITY', 'APPLICATION_CLASS', 'QUALIFIER', 'VIEW'.",
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_concept_description',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          8],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Reference_types',
      literals=[
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Model_reference',
          value='ModelReference',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Reference',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference_types',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='referred_semantic_id',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='keys',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Key',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference_types',
                node=...),
              default=None,
              node=...),
            Argument(
              name='keys',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Key',
                    node=...)],
                node=...),
              default=None,
              node=...),
            Argument(
              name='referred_semantic_id',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='keys',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-121: For References the type of the first key shall be one of Globally identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...)],
                  original_node=...),
                op='GT',
                right=Constant(
                  value=0,
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-122: For global references the type of the first key shall be one of Generic globally identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Global_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=0,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Generic_globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-123: For model references the type of the first key shall be one of AAS identifiables',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=0,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='AAS_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-124: For global references the last key shall be either one of Generic globally identifiables or one of Generic fragment keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Global_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=0,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_globally_identifiables',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-125: For model references with more than one key, the type of the keys following the first key shall be one of Fragment keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=1,
                    original_node=...),
                  end=FunctionCall(
                    name='len',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                condition=IsIn(
                  member=Member(
                    instance=Index(
                      collection=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...),
                      index=Name(
                        identifier='i',
                        original_node=...),
                      original_node=...),
                    name='type',
                    original_node=...),
                  container=Name(
                    identifier='Fragment_keys',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-126: For model references with more than one key, the type of the last key in the reference key chain may be one of Generic fragment keys or no key at all shall have a value out of Generic fragment keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Not(
                  operand=IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-127: For model references with more than one key, a key with type Fragment reference shall be preceded by a key with type File or Blob.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Fragment_reference',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='File',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Blob',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-128: For model references, the value of a key preceded by a key with type Submodel element list is an integer number denoting the position in the array of the submodel element list.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=2,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel_element_list',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='matches_xs_positive_integer',
                    args=[
                      Member(
                        instance=Index(
                          collection=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='keys',
                            original_node=...),
                          index=Add(
                            left=Name(
                              identifier='i',
                              original_node=...),
                            right=Constant(
                              value=1,
                              original_node=...),
                            original_node=...),
                          original_node=...),
                        name='value',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Key',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Key_types',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Key_types',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Key_types',
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Identifiable',
          value='Identifiable',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Referable',
          value='Referable',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=Description(
            document=...,
            node=...),
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Data_type_def_XSD',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          node=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          11,
          3],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Lang_string',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='language',
          type_annotation=AtomicTypeAnnotation(
            identifier='BCP_47_language_tag',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='str',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_set',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='lang_strings',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='lang_strings',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string',
                    node=...)],
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='lang_strings',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='lang_strings_have_unique_languages',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='lang_strings',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Data_specification_content',
      is_implementation_specific=False,
      inheritances=[],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          2,
          1,
          1],
        index=1,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Data_specification',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='id',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='data_specification_content',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_specification_content',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='administration',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Administrative_information',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='description',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_set',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='id',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='data_specification_content',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_specification_content',
                node=...),
              default=None,
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=None,
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_set',
                    node=...)],
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          2,
          1,
          1],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Environment',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Asset_administration_shell',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='submodels',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='concept_descriptions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Concept_description',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_specification',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='asset_administration_shells',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Asset_administration_shell',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodels',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='concept_descriptions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Concept_description',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          9],
        index=0,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...)],
  constants=[
    ConstantSet(
      name='Valid_categories_for_data_element',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='str',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Valid_categories_for_concept_description',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='str',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      reference_in_the_book=None,
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Generic_fragment_keys',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...)],
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=9,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Generic_globally_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...)],
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=8,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=7,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_submodel_elements_as_keys',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=6,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_referable_non_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_submodel_elements_as_keys'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=4,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_referables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_referable_non_identifiables',
        'AAS_identifiables'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=5,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Globally_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_identifiables',
        'Generic_globally_identifiables'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=3,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Fragment_keys',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_referable_non_identifiables',
        'Generic_fragment_keys'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=2,
        fragment=None),
      description=Description(
        document=...,
        node=...),
      node=...)],
  verification_functions=[
    UnderstoodMethod(
      name='matches_id_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^[a-zA-Z][a-zA-Z0-9_]+$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time_stamp_utc',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hour_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(([01]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(2[0-3]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='second_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '([0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')(\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='end_of_day_frag',
              original_node=...),
            value=Constant(
              value='24:00:00(\\\\.0+)?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=Constant(
              value='Z',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_time_stamp_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                'T((',
                FormattedValue(
                  value=Name(
                    identifier='hour_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='second_frag',
                    original_node=...),
                  original_node=...),
                ')|',
                FormattedValue(
                  value=Name(
                    identifier='end_of_day_frag',
                    original_node=...),
                  original_node=...),
                ')',
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_time_stamp_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_xs_date_time_stamp_utc',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_MIME_type',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='tchar',
              original_node=...),
            value=Constant(
              value="[!#$%&'*+\\\\-.^_`|~0-9a-zA-Z]",
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='token',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='tchar',
                    original_node=...),
                  original_node=...),
                ')+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='type',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='subtype',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ows',
              original_node=...),
            value=Constant(
              value='[ \\t]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='obs_text',
              original_node=...),
            value=Constant(
              value='[\\\\x80-\\\\xff]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='qd_text',
              original_node=...),
            value=JoinedStr(
              values=[
                '([\\t !#-\\\\[\\\\]-~]|',
                FormattedValue(
                  value=Name(
                    identifier='obs_text',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='quoted_pair',
              original_node=...),
            value=JoinedStr(
              values=[
                '\\\\\\\\([\\t !-~]|',
                FormattedValue(
                  value=Name(
                    identifier='obs_text',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='quoted_string',
              original_node=...),
            value=JoinedStr(
              values=[
                '"(',
                FormattedValue(
                  value=Name(
                    identifier='qd_text',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='quoted_pair',
                    original_node=...),
                  original_node=...),
                ')*"'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='parameter',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...),
                '=(',
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='quoted_string',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='media_type',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='type',
                    original_node=...),
                  original_node=...),
                '/',
                FormattedValue(
                  value=Name(
                    identifier='subtype',
                    original_node=...),
                  original_node=...),
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ows',
                    original_node=...),
                  original_node=...),
                ';',
                FormattedValue(
                  value=Name(
                    identifier='ows',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='parameter',
                    original_node=...),
                  original_node=...),
                ')*$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='media_type',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_RFC_8089_path',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='h16',
              original_node=...),
            value=Constant(
              value='[0-9A-Fa-f]{1,4}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='dec_octet',
              original_node=...),
            value=Constant(
              value='([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv4address',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ls32',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv6address',
              original_node=...),
            value=JoinedStr(
              values=[
                '((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){6}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){5}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){4}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':)?',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){3}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){2}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){2}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){3}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){4}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){5}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){6}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unreserved',
              original_node=...),
            value=Constant(
              value='[a-zA-Z0-9\\\\-._~]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='sub_delims',
              original_node=...),
            value=Constant(
              value="[!$&'()*+,;=]",
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipvfuture',
              original_node=...),
            value=JoinedStr(
              values=[
                '[vV][0-9A-Fa-f]+\\\\.(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|:)+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ip_literal',
              original_node=...),
            value=JoinedStr(
              values=[
                '\\\\[(',
                FormattedValue(
                  value=Name(
                    identifier='ipv6address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipvfuture',
                    original_node=...),
                  original_node=...),
                ')\\\\]'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pct_encoded',
              original_node=...),
            value=Constant(
              value='%[0-9A-Fa-f][0-9A-Fa-f]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='reg_name',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='host',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ip_literal',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='reg_name',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_auth',
              original_node=...),
            value=JoinedStr(
              values=[
                '(localhost|',
                FormattedValue(
                  value=Name(
                    identifier='host',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pchar',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|[:@])'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='segment_nz',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='pchar',
                    original_node=...),
                  original_node=...),
                ')+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='segment',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='pchar',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='path_absolute',
              original_node=...),
            value=JoinedStr(
              values=[
                '/(',
                FormattedValue(
                  value=Name(
                    identifier='segment_nz',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='segment',
                    original_node=...),
                  original_node=...),
                ')*)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='auth_path',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='file_auth',
                    original_node=...),
                  original_node=...),
                ')?',
                FormattedValue(
                  value=Name(
                    identifier='path_absolute',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='local_path',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='path_absolute',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_hier_part',
              original_node=...),
            value=JoinedStr(
              values=[
                '(//',
                FormattedValue(
                  value=Name(
                    identifier='auth_path',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='local_path',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_scheme',
              original_node=...),
            value=Constant(
              value='file',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_uri',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='file_scheme',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='file_hier_part',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='file_uri',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_BCP_47',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='alphanum',
              original_node=...),
            value=Constant(
              value='[a-zA-Z0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='singleton',
              original_node=...),
            value=Constant(
              value='[0-9A-WY-Za-wy-z]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='extension',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='singleton',
                    original_node=...),
                  original_node=...),
                '(-(',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){2,8})+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='extlang',
              original_node=...),
            value=Constant(
              value='[a-zA-Z]{3}(-[a-zA-Z]{3}){2}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='irregular',
              original_node=...),
            value=Constant(
              value='(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='regular',
              original_node=...),
            value=Constant(
              value='(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='grandfathered',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='irregular',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='regular',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='language',
              original_node=...),
            value=JoinedStr(
              values=[
                '([a-zA-Z]{2,3}(-',
                FormattedValue(
                  value=Name(
                    identifier='extlang',
                    original_node=...),
                  original_node=...),
                ')?|[a-zA-Z]{4}|[a-zA-Z]{5,8})'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='script',
              original_node=...),
            value=Constant(
              value='[a-zA-Z]{4}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='region',
              original_node=...),
            value=Constant(
              value='([a-zA-Z]{2}|[0-9]{3})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='variant',
              original_node=...),
            value=JoinedStr(
              values=[
                '((',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){5,8}|[0-9](',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){3})'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='privateuse',
              original_node=...),
            value=JoinedStr(
              values=[
                '[xX](-(',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){1,8})+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='langtag',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='language',
                    original_node=...),
                  original_node=...),
                '(-',
                FormattedValue(
                  value=Name(
                    identifier='script',
                    original_node=...),
                  original_node=...),
                ')?(-',
                FormattedValue(
                  value=Name(
                    identifier='region',
                    original_node=...),
                  original_node=...),
                ')?(-',
                FormattedValue(
                  value=Name(
                    identifier='variant',
                    original_node=...),
                  original_node=...),
                ')*(-',
                FormattedValue(
                  value=Name(
                    identifier='extension',
                    original_node=...),
                  original_node=...),
                ')*(-',
                FormattedValue(
                  value=Name(
                    identifier='privateuse',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='language_tag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='langtag',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='privateuse',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='grandfathered',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='language_tag',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='lang_strings_have_unique_languages',
      verification=True,
      arguments=[
        Argument(
          name='lang_strings',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='qualifier_types_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='qualifiers',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Qualifier',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_any_URI',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='scheme',
              original_node=...),
            value=Constant(
              value='[a-zA-Z][a-zA-Z0-9+\\\\-.]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ucschar',
              original_node=...),
            value=Constant(
              value='[\\\\xa0-\\\\ud7ff\\\\uf900-\\\\ufdcf\\\\ufdf0-\\\\uffef\\\\U00010000-\\\\U0001fffd\\\\U00020000-\\\\U0002fffd\\\\U00030000-\\\\U0003fffd\\\\U00040000-\\\\U0004fffd\\\\U00050000-\\\\U0005fffd\\\\U00060000-\\\\U0006fffd\\\\U00070000-\\\\U0007fffd\\\\U00080000-\\\\U0008fffd\\\\U00090000-\\\\U0009fffd\\\\U000a0000-\\\\U000afffd\\\\U000b0000-\\\\U000bfffd\\\\U000c0000-\\\\U000cfffd\\\\U000d0000-\\\\U000dfffd\\\\U000e1000-\\\\U000efffd]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iunreserved',
              original_node=...),
            value=JoinedStr(
              values=[
                '([a-zA-Z0-9\\\\-._~]|',
                FormattedValue(
                  value=Name(
                    identifier='ucschar',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pct_encoded',
              original_node=...),
            value=Constant(
              value='%[0-9A-Fa-f][0-9A-Fa-f]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='sub_delims',
              original_node=...),
            value=Constant(
              value="[!$&'()*+,;=]",
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iuserinfo',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|:)*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='h16',
              original_node=...),
            value=Constant(
              value='[0-9A-Fa-f]{1,4}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='dec_octet',
              original_node=...),
            value=Constant(
              value='([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv4address',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ls32',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv6address',
              original_node=...),
            value=JoinedStr(
              values=[
                '((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){6}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){5}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){4}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':)?',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){3}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){2}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){2}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){3}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){4}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){5}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){6}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unreserved',
              original_node=...),
            value=Constant(
              value='[a-zA-Z0-9\\\\-._~]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipvfuture',
              original_node=...),
            value=JoinedStr(
              values=[
                '[vV][0-9A-Fa-f]+\\\\.(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|:)+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ip_literal',
              original_node=...),
            value=JoinedStr(
              values=[
                '\\\\[(',
                FormattedValue(
                  value=Name(
                    identifier='ipv6address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipvfuture',
                    original_node=...),
                  original_node=...),
                ')\\\\]'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ireg_name',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ihost',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ip_literal',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ireg_name',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='port',
              original_node=...),
            value=Constant(
              value='[0-9]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iauthority',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iuserinfo',
                    original_node=...),
                  original_node=...),
                '@)?',
                FormattedValue(
                  value=Name(
                    identifier='ihost',
                    original_node=...),
                  original_node=...),
                '(:',
                FormattedValue(
                  value=Name(
                    identifier='port',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipchar',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|[:@])'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='isegment',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_abempty',
              original_node=...),
            value=JoinedStr(
              values=[
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='isegment_nz',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                ')+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_absolute',
              original_node=...),
            value=JoinedStr(
              values=[
                '/(',
                FormattedValue(
                  value=Name(
                    identifier='isegment_nz',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_rootless',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='isegment_nz',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_empty',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                '){0}'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ihier_part',
              original_node=...),
            value=JoinedStr(
              values=[
                '(//',
                FormattedValue(
                  value=Name(
                    identifier='iauthority',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='ipath_abempty',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_absolute',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_rootless',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_empty',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iprivate',
              original_node=...),
            value=Constant(
              value='[\\\\ue000-\\\\uf8ff\\\\U000f0000-\\\\U000ffffd\\\\U00100000-\\\\U0010fffd]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iquery',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='iprivate',
                    original_node=...),
                  original_node=...),
                '|[/?])*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ifragment',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                '|[/?])*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='isegment_nz_nc',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|@)+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_noscheme',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='isegment_nz_nc',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='irelative_part',
              original_node=...),
            value=JoinedStr(
              values=[
                '(//',
                FormattedValue(
                  value=Name(
                    identifier='iauthority',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='ipath_abempty',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_absolute',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_noscheme',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_empty',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='irelative_ref',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='irelative_part',
                    original_node=...),
                  original_node=...),
                '(\\\\?',
                FormattedValue(
                  value=Name(
                    identifier='iquery',
                    original_node=...),
                  original_node=...),
                ')?(\\\\#',
                FormattedValue(
                  value=Name(
                    identifier='ifragment',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iri',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='scheme',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='ihier_part',
                    original_node=...),
                  original_node=...),
                '(\\\\?',
                FormattedValue(
                  value=Name(
                    identifier='iquery',
                    original_node=...),
                  original_node=...),
                ')?(\\\\#',
                FormattedValue(
                  value=Name(
                    identifier='ifragment',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iri_reference',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iri',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='irelative_ref',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='iri_reference',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_base_64_binary',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b04_char',
              original_node=...),
            value=Constant(
              value='[AQgw]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b04',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b04_char',
                    original_node=...),
                  original_node=...),
                '\\\\x20?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b16_char',
              original_node=...),
            value=Constant(
              value='[AEIMQUYcgkosw048]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b16',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b16_char',
                    original_node=...),
                  original_node=...),
                '\\\\x20?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64_char',
              original_node=...),
            value=Constant(
              value='[A-Za-z0-9+/]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b64_char',
                    original_node=...),
                  original_node=...),
                '\\\\x20?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64quad',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64_final_quad',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64_char',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='padded_8',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b04',
                    original_node=...),
                  original_node=...),
                '= ?='],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='padded_16',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b16',
                    original_node=...),
                  original_node=...),
                '='],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64final',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64_final_quad',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='padded_16',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='padded_8',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='base64_binary',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64quad',
                    original_node=...),
                  original_node=...),
                '*',
                FormattedValue(
                  value=Name(
                    identifier='b64final',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='base64_binary',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_boolean',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=Constant(
              value='^(true|false|1|0)$',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(Z|(\\\\+|-)(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '|1[0-3]):',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                '|14:00)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...),
                '?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hour_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(([01]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(2[0-3]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='second_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '([0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')(\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='end_of_day_frag',
              original_node=...),
            value=Constant(
              value='24:00:00(\\\\.0+)?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(Z|(\\\\+|-)(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '|1[0-3]):',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                '|14:00)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_time_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                'T((',
                FormattedValue(
                  value=Name(
                    identifier='hour_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='second_frag',
                    original_node=...),
                  original_node=...),
                ')|',
                FormattedValue(
                  value=Name(
                    identifier='end_of_day_frag',
                    original_node=...),
                  original_node=...),
                ')',
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...),
                '?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_time_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time_stamp',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hour_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(([01]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(2[0-3]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='second_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '([0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')(\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='end_of_day_frag',
              original_node=...),
            value=Constant(
              value='24:00:00(\\\\.0+)?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(Z|(\\\\+|-)(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '|1[0-3]):',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                '|14:00)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_time_stamp_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                'T((',
                FormattedValue(
                  value=Name(
                    identifier='hour_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='second_frag',
                    original_node=...),
                  original_node=...),
                ')|',
                FormattedValue(
                  value=Name(
                    identifier='end_of_day_frag',
                    original_node=...),
                  original_node=...),
                ')',
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_time_stamp_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_decimal',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_no_decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='no_decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                '(\\\\+|-)?',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_no_decimal_pt_numeral',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='frac_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_no_decimal_pt_numeral',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='frac_frag',
                    original_node=...),
                  original_node=...),
                '|\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='frac_frag',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                '(\\\\+|-)?',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_decimal_pt_numeral',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='decimal_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='decimal_pt_numeral',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='no_decimal_pt_numeral',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='decimal_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_double',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='double_rep',
              original_node=...),
            value=Constant(
              value='(\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|(\\\\+|-)?INF|NaN',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='double_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='duration_rep',
              original_node=...),
            value=Constant(
              value='-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S))))',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='duration_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_float',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='float_rep',
              original_node=...),
            value=Constant(
              value='(\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|(\\\\+|-)?INF|NaN',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='float_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_day',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_day_lexical_rep',
              original_node=...),
            value=Constant(
              value='---(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_day_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_month',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_month_lexical_rep',
              original_node=...),
            value=Constant(
              value='--(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_month_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_month_day',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_month_day_rep',
              original_node=...),
            value=Constant(
              value='--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_month_day_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_year',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_year_rep',
              original_node=...),
            value=Constant(
              value='-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_year_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_year_month',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_year_month_rep',
              original_node=...),
            value=Constant(
              value='-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_year_month_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_hex_binary',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hex_binary',
              original_node=...),
            value=Constant(
              value='([0-9a-fA-F]{2})*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='hex_binary',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='time_rep',
              original_node=...),
            value=Constant(
              value='(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\\\.[0-9]+)?|(24:00:00(\\\\.0+)?))(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='time_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_day_time_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_time_duration_rep',
              original_node=...),
            value=Constant(
              value='-?P((([0-9]+D)(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S))))',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='day_time_duration_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_year_month_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_month_duration_rep',
              original_node=...),
            value=Constant(
              value='-?P((([0-9]+Y)([0-9]+M)?)|([0-9]+M))',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='year_month_duration_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='integer_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?[0-9]+',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_long',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='long_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,20}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='long_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_int',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='int_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,10}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='int_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='short_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,5}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='short_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_byte',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='byte_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,3}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='byte_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_non_negative_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='non_negative_integer_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?[0-9]+)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='non_negative_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_positive_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='positive_integer_rep',
              original_node=...),
            value=Constant(
              value='\\\\+?0*[1-9][0-9]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='positive_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_long',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_long_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,20})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_long_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_int',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_int_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,10})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_int_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_short_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,5})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_short_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_byte',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_byte_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,3})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_byte_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_non_positive_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='non_positive_integer_rep',
              original_node=...),
            value=Constant(
              value='(\\\\+0|0|-[0-9]+)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='non_positive_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_negative_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='negative_integer_rep',
              original_node=...),
            value=Constant(
              value='(-0*[1-9][0-9]*)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='negative_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_string',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=Constant(
              value='^[\\\\u0001-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='value_consistent_with_xsd_type',
      verification=True,
      arguments=[
        Argument(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...),
        Argument(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_global_asset_id_literally',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=Constant(
              value='^[gG][lL][oO][bB][aA][lL][aA][sS][sS][eE][tT][iI][dD]$',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_model_reference_to',
      verification=True,
      arguments=[
        Argument(
          name='reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...),
        Argument(
          name='expected_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Key_types',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_model_reference_to_referable',
      verification=True,
      arguments=[
        Argument(
          name='reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='id_shorts_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='referables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Referable',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='extension_names_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='extensions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Extension',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='submodel_elements_have_identical_semantic_ids',
      verification=True,
      arguments=[
        Argument(
          name='elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='submodel_element_is_of_type',
      verification=True,
      arguments=[
        Argument(
          name='element',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element',
            node=...),
          default=None,
          node=...),
        Argument(
          name='element_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='AAS_submodel_elements',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='properties_or_ranges_have_value_type',
      verification=True,
      arguments=[
        Argument(
          name='elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...)],
            node=...),
          default=None,
          node=...),
        Argument(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='reference_key_values_equal',
      verification=True,
      arguments=[
        Argument(
          name='that',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...),
        Argument(
          name='other',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      node=...,
      arguments_by_name=...)],
  meta_model=MetaModel(
    description=Description(
      document=...,
      node=...),
    book_url='https://www.plattform-i40.de/IP/Redaktion/DE/Downloads/Publikation/Details_of_the_Asset_Administration_Shell_Part1_V3.pdf?__blob=publicationFile&v=10',
    book_version='V3.0RC02'))