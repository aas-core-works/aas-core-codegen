UnverifiedSymbolTable(
  our_types=[
    ConcreteClass(
      name='Non_empty_XML_serializable_string',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description="Constraint AASd-130: An attribute with data type 'string' shall consist of these characters only: ^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_XML_serializable_string',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='The value must not be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Date_time_UTC',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='The value must match the pattern of xs:dateTime with the time zone fixed to UTC.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_date_time_UTC',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='The value must represent a valid xs:dateTime with the time zone fixed to UTC.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_xs_date_time_UTC',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Duration',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='The value must match the pattern of xs:duration.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_duration',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Blob_type',
      is_implementation_specific=False,
      inheritances=[
        'bytearray'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Identifier',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Identifier shall have a maximum length of 2000 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=2000,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_type_IEC_61360',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Value type IEC 61360 shall have a maximum length of 2000 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=2000,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Name_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Name type shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Version_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Version type shall match the version pattern.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_version_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Version type shall have a maximum length of 4 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=4,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Revision_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Revision type shall match the revision pattern.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_revision_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Revision type shall have a maximum length of 4 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=4,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Label_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Label type shall have a maximum length of 64 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=64,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Message_topic_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Message topic type shall have a maximum length of 255 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=255,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='BCP_47_language_tag',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='The value must represent a value language tag conformant to BCP 47.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_BCP_47',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Content_type',
      is_implementation_specific=False,
      inheritances=[
        'Non_empty_XML_serializable_string'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='Content type shall have a maximum length of 100 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=100,
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='The value must represent a valid content MIME type according to RFC 2046.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_MIME_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Path_type',
      is_implementation_specific=False,
      inheritances=[
        'Identifier'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Qualifier_type',
      is_implementation_specific=False,
      inheritances=[
        'Name_type'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_data_type',
      is_implementation_specific=False,
      inheritances=[
        'str'],
      properties=[],
      methods=[],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='ID_short_type',
      is_implementation_specific=False,
      inheritances=[
        'Name_type'],
      properties=[],
      methods=[],
      invariants=[
        Invariant(
          description='ID-short of Referables shall only feature letters, digits, underscore (``_``); starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_ID_short',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_semantics',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='supplemental_semantic_IDs',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_IDs',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_ID',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Extension',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='name',
          type_annotation=AtomicTypeAnnotation(
            identifier='Name_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='refers_to',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='value_type_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='name',
              type_annotation=AtomicTypeAnnotation(
                identifier='Name_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_def_XSD',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='refers_to',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Refers-to must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='refers_to',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='refers_to',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='The value must match the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_or_default',
                      original_node=...),
                    args=[],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_extensions',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Extension',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Referable',
      is_implementation_specific=False,
      inheritances=[
        'Has_extensions'],
      properties=[
        Property(
          name='category',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Name_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='ID_short',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='ID_short_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='display_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_name_type',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='description',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_text_type',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Description must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Description must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Display name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Display name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Identifiable',
      is_implementation_specific=False,
      inheritances=[
        'Referable'],
      properties=[
        Property(
          name='administration',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Administrative_information',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='ID',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Modelling_kind',
      literals=[
        EnumerationLiteral(
          name='Template',
          value='Template',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    AbstractClass(
      name='Has_kind',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='kind',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Modelling_kind',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='Modelling_kind',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modelling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Has_data_specification',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Embedded_data_specification',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Administrative_information',
      is_implementation_specific=False,
      inheritances=[
        'Has_data_specification'],
      properties=[
        Property(
          name='version',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Version_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='revision',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Revision_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='creator',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='template_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Identifier',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='version',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Version_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='revision',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Revision_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='creator',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='template_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Identifier',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-005: If version is not specified then also revision shall be unspecified. This means, a revision requires a version. If there is no version there is no revision either. Revision is optional.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='revision',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='version',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Qualifiable',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Qualifier',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Qualifiers must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Qualifier_kind',
      literals=[
        EnumerationLiteral(
          name='Value_qualifier',
          value='ValueQualifier',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Concept_qualifier',
          value='ConceptQualifier',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Template_qualifier',
          value='TemplateQualifier',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Qualifier',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='kind',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Qualifier_kind',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Qualifier_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='Qualifier_kind',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Qualifier_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Qualifier_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-020: The value shall be consistent to the data type as defined in value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Asset_administration_shell',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='derived_from',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='asset_information',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_information',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='submodels',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='asset_information',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_information',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='derived_from',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodels',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Submodels must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodels',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Derived-from must be a model reference to an asset administration shell.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='derived_from',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='derived_from',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='Key_types',
                      original_node=...),
                    name='Asset_administration_shell',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='All submodels must be model references to a submodel.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='reference',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodels',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Name(
                      identifier='reference',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Asset_information',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=AtomicTypeAnnotation(
            identifier='Asset_kind',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='global_asset_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Identifier',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='specific_asset_IDs',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Specific_asset_ID',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='asset_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Identifier',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='default_thumbnail',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Resource',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='asset_kind',
              type_annotation=AtomicTypeAnnotation(
                identifier='Asset_kind',
                node=...),
              default=None,
              node=...),
            Argument(
              name='global_asset_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Identifier',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='specific_asset_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Specific_asset_ID',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='asset_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Identifier',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='default_thumbnail',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Resource',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-116: ``globalAssetId`` is a reserved key. If used as value for the name of specific asset ID then the value of specific asset ID shall be identical to the global asset ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_IDs',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='specific_asset_ID',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='specific_asset_IDs',
                    original_node=...),
                  original_node=...),
                condition=Or(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='specific_asset_ID',
                          original_node=...),
                        name='name',
                        original_node=...),
                      op='NE',
                      right=Constant(
                        value='globalAssetId',
                        original_node=...),
                      original_node=...),
                    And(
                      values=[
                        IsNotNone(
                          value=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='global_asset_ID',
                            original_node=...),
                          original_node=...),
                        Comparison(
                          left=Member(
                            instance=Name(
                              identifier='specific_asset_ID',
                              original_node=...),
                            name='name',
                            original_node=...),
                          op='EQ',
                          right=Constant(
                            value='globalAssetId',
                            original_node=...),
                          original_node=...),
                        Comparison(
                          left=Member(
                            instance=Name(
                              identifier='specific_asset_ID',
                              original_node=...),
                            name='value',
                            original_node=...),
                          op='EQ',
                          right=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='global_asset_ID',
                            original_node=...),
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-131: Either the global asset ID shall be defined or at least one specific asset ID.',
          body=textwrap.dedent("""\
            And(
              values=[
                Or(
                  values=[
                    IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_ID',
                        original_node=...),
                      original_node=...),
                    IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_IDs',
                        original_node=...),
                      original_node=...)],
                  original_node=...),
                Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_IDs',
                      original_node=...),
                    original_node=...),
                  consequent=Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='specific_asset_IDs',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Specific asset IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Resource',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='path',
          type_annotation=AtomicTypeAnnotation(
            identifier='Path_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Content_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='path',
              type_annotation=AtomicTypeAnnotation(
                identifier='Path_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Content_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Asset_kind',
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Not_applicable',
          value='NotApplicable',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Specific_asset_ID',
      is_implementation_specific=False,
      inheritances=[
        'Has_semantics'],
      properties=[
        Property(
          name='name',
          type_annotation=AtomicTypeAnnotation(
            identifier='Label_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='external_subject_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='name',
              type_annotation=AtomicTypeAnnotation(
                identifier='Label_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='external_subject_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-133: External subject ID shall be an external reference.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='external_subject_ID',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=Member(
                  instance=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='external_subject_ID',
                    original_node=...),
                  name='type',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Reference_types',
                    original_node=...),
                  name='External_reference',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_kind',
        'Has_semantics',
        'Qualifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='submodel_elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='kind',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Modelling_kind',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodel_elements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Submodel elements must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodel_elements',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of submodel elements according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-022: ID-short of non-identifiable referables within the same name space shall be unique (case-sensitive).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='ID_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-129: If any qualifier kind value of a Submodel element qualifier (attribute qualifier inherited via Qualifiable) is equal to Template Qualifier then the submodel element shall be part of a submodel template, i.e. a Submodel with submodel kind (attribute kind inherited via Has-Kind) value is equal to Template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='NE',
                  right=Member(
                    instance=Name(
                      identifier='Modelling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                consequent=All(
                  generator=ForEach(
                    variable=Name(
                      identifier='submodel_element',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodel_elements',
                      original_node=...),
                    original_node=...),
                  condition=Implication(
                    antecedent=IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='submodel_element',
                          original_node=...),
                        name='qualifiers',
                        original_node=...),
                      original_node=...),
                    consequent=All(
                      generator=ForEach(
                        variable=Name(
                          identifier='qualifier',
                          original_node=...),
                        iteration=Member(
                          instance=Name(
                            identifier='submodel_element',
                            original_node=...),
                          name='qualifiers',
                          original_node=...),
                        original_node=...),
                      condition=Comparison(
                        left=MethodCall(
                          member=Member(
                            instance=Name(
                              identifier='qualifier',
                              original_node=...),
                            name='kind_or_default',
                            original_node=...),
                          args=[],
                          original_node=...),
                        op='NE',
                        right=Member(
                          instance=Name(
                            identifier='Qualifier_kind',
                            original_node=...),
                          name='Template_qualifier',
                          original_node=...),
                        original_node=...),
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=MethodCall(
                      member=Member(
                        instance=Name(
                          identifier='qualifier',
                          original_node=...),
                        name='kind_or_default',
                        original_node=...),
                      args=[],
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modelling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Submodel_element',
      is_implementation_specific=False,
      inheritances=[
        'Referable',
        'Has_semantics',
        'Qualifiable',
        'Has_data_specification'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Relationship_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='first',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='second',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='first',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='second',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='AAS_submodel_elements',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=None,
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Submodel_element_list',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='order_relevant',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='bool',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='semantic_ID_list_element',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='type_value_list_element',
          type_annotation=AtomicTypeAnnotation(
            identifier='AAS_submodel_elements',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_type_list_element',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ImplementationSpecificMethod(
          name='order_relevant_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='bool',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=True,
          node=...,
          arguments_by_name=...),
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type_value_list_element',
              type_annotation=AtomicTypeAnnotation(
                identifier='AAS_submodel_elements',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='order_relevant',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='bool',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID_list_element',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_type_list_element',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_def_XSD',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Value must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-107: If a first level child element has a semantic ID it shall be identical to semantic ID list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='semantic_ID_list_element',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='child',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='child',
                        original_node=...),
                      name='semantic_ID',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='reference_key_values_equal',
                    args=[
                      Member(
                        instance=Name(
                          identifier='child',
                          original_node=...),
                        name='semantic_ID',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='semantic_ID_list_element',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-114: If two first level child elements have a semantic ID then they shall be identical.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='submodel_elements_have_identical_semantic_IDs',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-108: All first level child elements shall have the same submodel element type as specified in type value list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='submodel_element_is_of_type',
                  args=[
                    Name(
                      identifier='element',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type_value_list_element',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-109: If type value list element is equal to Property or Range value type list element shall be set and all first level child elements shall have the value type as specified in value type list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Property',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Range',
                          original_node=...),
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              consequent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_list_element',
                      original_node=...),
                    original_node=...),
                  FunctionCall(
                    name='properties_or_ranges_have_value_type',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_type_list_element',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-120: ID-short of submodel elements being a direct child of a  Submodel element list shall not be specified.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Submodel_element_collection',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Value must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of value according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='ID-shorts of the value must be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='ID_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Data_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...)],
          returns=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=...,
                node=...)]),
          non_mutating=True,
          node=...,
          arguments_by_name=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Property',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Value must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Multi_language_property',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_text_type',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Value must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Value must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Range',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='min',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_data_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_type_def_XSD',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='min',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='max',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_data_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Max must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='max',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Min must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='min',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_XSD_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='min',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Reference_element',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Blob',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Blob_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Content_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Content_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Blob_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='File',
      is_implementation_specific=False,
      inheritances=[
        'Data_element'],
      properties=[
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Path_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='content_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Content_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='content_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Content_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Path_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      is_implementation_specific=False,
      inheritances=[
        'Relationship_element'],
      properties=[
        Property(
          name='annotations',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='first',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='second',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='annotations',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Data_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Annotations must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='annotations',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='annotations',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of annotations according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='annotations',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='annotations',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Entity',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='statements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel_element',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='entity_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Entity_type',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='global_asset_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Identifier',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='specific_asset_IDs',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Specific_asset_ID',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='entity_type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Entity_type',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='statements',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel_element',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='global_asset_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Identifier',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='specific_asset_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Specific_asset_ID',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Statements must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='statements',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='statements',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='ID-shorts need to be defined for all the items of statements according to AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='statements',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='item',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='statements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='item',
                      original_node=...),
                    name='ID_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-014: Either the attribute global asset ID or specific asset ID must be set if entity type is set to self-managed entity. They are not existing otherwise.',
          body=textwrap.dedent("""\
            Or(
              values=[
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='EQ',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    Or(
                      values=[
                        And(
                          values=[
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_ID',
                                original_node=...),
                              original_node=...),
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_IDs',
                                original_node=...),
                              original_node=...)],
                          original_node=...),
                        And(
                          values=[
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_ID',
                                original_node=...),
                              original_node=...),
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_IDs',
                                original_node=...),
                              original_node=...),
                            Comparison(
                              left=FunctionCall(
                                name='len',
                                args=[
                                  Member(
                                    instance=Name(
                                      identifier='self',
                                      original_node=...),
                                    name='specific_asset_IDs',
                                    original_node=...)],
                                original_node=...),
                              op='GE',
                              right=Constant(
                                value=1,
                                original_node=...),
                              original_node=...)],
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='NE',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_ID',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_IDs',
                        original_node=...),
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Specific asset IDs must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_IDs',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_IDs',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Entity_type',
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='CoManagedEntity',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SelfManagedEntity',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Direction',
      literals=[
        EnumerationLiteral(
          name='Input',
          value='input',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Output',
          value='output',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='State_of_event',
      literals=[
        EnumerationLiteral(
          name='On',
          value='on',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Off',
          value='off',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Event_payload',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='source',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='source_semantic_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='observable_reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='observable_semantic_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='topic',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Message_topic_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='subject_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='time_stamp',
          type_annotation=AtomicTypeAnnotation(
            identifier='Date_time_UTC',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='payload',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Blob_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='source',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='observable_reference',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='time_stamp',
              type_annotation=AtomicTypeAnnotation(
                identifier='Date_time_UTC',
                node=...),
              default=None,
              node=...),
            Argument(
              name='source_semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='observable_semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='topic',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Message_topic_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='subject_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='payload',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Blob_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Source must be a model reference to an Event element.',
          body=textwrap.dedent("""\
            Or(
              values=[
                FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='source',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Event_element',
                      original_node=...)],
                  original_node=...),
                FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='source',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Basic_event_element',
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Observable reference must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observable_reference',
                  original_node=...)],
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Event_element',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Basic_event_element',
      is_implementation_specific=False,
      inheritances=[
        'Event_element'],
      properties=[
        Property(
          name='observed',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='direction',
          type_annotation=AtomicTypeAnnotation(
            identifier='Direction',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='state',
          type_annotation=AtomicTypeAnnotation(
            identifier='State_of_event',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='message_topic',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Message_topic_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='message_broker',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='last_update',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Date_time_UTC',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='min_interval',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Duration',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max_interval',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Duration',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='observed',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...),
            Argument(
              name='direction',
              type_annotation=AtomicTypeAnnotation(
                identifier='Direction',
                node=...),
              default=None,
              node=...),
            Argument(
              name='state',
              type_annotation=AtomicTypeAnnotation(
                identifier='State_of_event',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='message_topic',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Message_topic_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='message_broker',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='last_update',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Date_time_UTC',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='min_interval',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Duration',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='max_interval',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Duration',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Max. interval is not applicable for input direction.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='direction',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Direction',
                    original_node=...),
                  name='Input',
                  original_node=...),
                original_node=...),
              consequent=IsNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max_interval',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Observed must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observed',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Message broker must be a model reference to a referable.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='message_broker',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to_referable',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='message_broker',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Operation',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[
        Property(
          name='input_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='output_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='inoutput_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='input_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='output_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='inoutput_variables',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Operation_variable',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASd-134: For an Operation the ID-short of all values of input, output and in/output variables.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='ID_shorts_of_variables_are_unique',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='input_variables',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='output_variables',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='inoutput_variables',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Input variables must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='input_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='input_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Output variables must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='output_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='output_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Inoutput variables must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='inoutput_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='inoutput_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Operation_variable',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Value must have the ID-short specified according to Constraint AASd-117 (ID-short of Referables not being a direct child of a Submodel element list shall be specified).',
          body=textwrap.dedent("""\
            IsNotNone(
              value=Member(
                instance=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                name='ID_short',
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Capability',
      is_implementation_specific=False,
      inheritances=[
        'Submodel_element'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='supplemental_semantic_IDs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='qualifiers',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Qualifier',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Concept_description',
      is_implementation_specific=False,
      inheritances=[
        'Identifiable',
        'Has_data_specification'],
      properties=[
        Property(
          name='is_case_of',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...),
            Argument(
              name='extensions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Extension',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='category',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Name_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='ID_short',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='ID_short_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='display_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_name_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='description',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_text_type',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='administration',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Administrative_information',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='embedded_data_specifications',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Embedded_data_specification',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='is_case_of',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Reference',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Is-case-of must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='is_case_of',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='is_case_of',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-008: For a concept description using data specification template IEC 61360, the definition is mandatory and shall be defined at least in English. Exception: The concept description describes a value.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  FunctionCall(
                    name='data_specification_IEC_61360s_have_definition_at_least_in_english',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='embedded_data_specifications',
                        original_node=...)],
                    original_node=...),
                  FunctionCall(
                    name='data_specification_IEC_61360s_have_value',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='embedded_data_specifications',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-007: For a concept description with category QUALIFIER_TYPE using data specification IEC 61360, the data type of the data specification is mandatory and shall be defined.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='QUALIFIER_TYPE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_have_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-006: For a concept description with category DOCUMENT using data specification IEC 61360, the data type of the data specification shall be one of: FILE, BLOB, HTML.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='DOCUMENT',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_document_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-005: For a concept description with category REFERENCE using data specification IEC 61360, the data type of the data specification shall be one of: STRING, IRI, IRDI.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='REFERENCE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_reference_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-004: For a concept description with category PROPERTY or VALUE using data specification IEC 61360, the data type of the data specification is mandatory and shall be one of: DATE, STRING, STRING_TRANSLATABLE, INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, RATIONAL_MEASURE, TIME, TIMESTAMP.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='category',
                          original_node=...),
                        op='EQ',
                        right=Constant(
                          value='PROPERTY',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='category',
                          original_node=...),
                        op='EQ',
                        right=Constant(
                          value='VALUE',
                          original_node=...),
                        original_node=...)],
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_property_or_value_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Reference_types',
      literals=[
        EnumerationLiteral(
          name='External_reference',
          value='ExternalReference',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Model_reference',
          value='ModelReference',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Reference',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference_types',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='referred_semantic_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='keys',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Key',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference_types',
                node=...),
              default=None,
              node=...),
            Argument(
              name='keys',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Key',
                    node=...)],
                node=...),
              default=None,
              node=...),
            Argument(
              name='referred_semantic_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Keys must contain at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='keys',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-121: For References the value of type of the first key of keys shall be one of Globally Identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-122: For external references the value of type of the first key of keys shall be one of Generic Globally Identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='External_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Generic_globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-123: For model references the value of type of the first key of keys shall be one of AAS identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='AAS_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-124: For external references the last key of keys shall be either one of Generic Globally Identifiables or one of Generic Fragment Keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='External_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_globally_identifiables',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-125: For model references with more than one key in keys the value of type of each of the keys following the first key of keys shall be one of Fragment Keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=1,
                    original_node=...),
                  end=FunctionCall(
                    name='len',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                condition=IsIn(
                  member=Member(
                    instance=Index(
                      collection=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...),
                      index=Name(
                        identifier='i',
                        original_node=...),
                      original_node=...),
                    name='type',
                    original_node=...),
                  container=Name(
                    identifier='Fragment_keys',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-126: For model references with more than one key in keys the value of type of the last key in the reference key chain may be one of Generic Fragment Keys or no key at all shall have a value out of Generic Fragment Keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Not(
                  operand=IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-127: For model references, with more than one key in keys a key with type Fragment Reference shall be preceded by a key with type File or Blob.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Fragment_reference',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='File',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Blob',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASd-128: For model references, the value of a key preceded by a key with type Submodel element list is an integer number denoting the position in the array of the submodel element list.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=2,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel_element_list',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='matches_xs_positive_integer',
                    args=[
                      Member(
                        instance=Index(
                          collection=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='keys',
                            original_node=...),
                          index=Add(
                            left=Name(
                              identifier='i',
                              original_node=...),
                            right=Constant(
                              value=1,
                              original_node=...),
                            original_node=...),
                          original_node=...),
                        name='value',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Key',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Key_types',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Identifier',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='type',
              type_annotation=AtomicTypeAnnotation(
                identifier='Key_types',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Identifier',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Key_types',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Identifiable',
          value='Identifiable',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Referable',
          value='Referable',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    Enumeration(
      name='Data_type_def_XSD',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          node=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:nonNegativeInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          node=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          node=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          node=...)],
      description=Description(
        document=...,
        node=...),
      node=...,
      literals_by_name=...),
    AbstractClass(
      name='Abstract_lang_string',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='language',
          type_annotation=AtomicTypeAnnotation(
            identifier='BCP_47_language_tag',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='Non_empty_XML_serializable_string',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_name_type',
      is_implementation_specific=False,
      inheritances=[
        'Abstract_lang_string'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='String shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_text_type',
      is_implementation_specific=False,
      inheritances=[
        'Abstract_lang_string'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='String shall have a maximum length of 1023 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=1023,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Environment',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Asset_administration_shell',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='submodels',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Submodel',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='concept_descriptions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Concept_description',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='asset_administration_shells',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Asset_administration_shell',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='submodels',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Submodel',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='concept_descriptions',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Concept_description',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Concept descriptions must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='concept_descriptions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='concept_descriptions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Submodels must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodels',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Asset administration shells must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='asset_administration_shells',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='asset_administration_shells',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    AbstractClass(
      name='Data_specification_content',
      is_implementation_specific=False,
      inheritances=[],
      properties=[],
      methods=[],
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Embedded_data_specification',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='data_specification_content',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_specification_content',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='data_specification',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='data_specification_content',
              type_annotation=AtomicTypeAnnotation(
                identifier='Data_specification_content',
                node=...),
              default=None,
              node=...),
            Argument(
              name='data_specification',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    Enumeration(
      name='Data_type_IEC_61360',
      literals=[
        EnumerationLiteral(
          name='Date',
          value='DATE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='String',
          value='STRING',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='String_translatable',
          value='STRING_TRANSLATABLE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Integer_measure',
          value='INTEGER_MEASURE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Integer_count',
          value='INTEGER_COUNT',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Integer_currency',
          value='INTEGER_CURRENCY',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Real_measure',
          value='REAL_MEASURE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Real_count',
          value='REAL_COUNT',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Real_currency',
          value='REAL_CURRENCY',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Boolean',
          value='BOOLEAN',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='IRI',
          value='IRI',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='IRDI',
          value='IRDI',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Rational',
          value='RATIONAL',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Rational_measure',
          value='RATIONAL_MEASURE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Time',
          value='TIME',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Timestamp',
          value='TIMESTAMP',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='File',
          value='FILE',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='HTML',
          value='HTML',
          description=Description(
            document=...,
            node=...),
          node=...),
        EnumerationLiteral(
          name='Blob',
          value='BLOB',
          description=Description(
            document=...,
            node=...),
          node=...)],
      description=None,
      node=...,
      literals_by_name=...),
    ConcreteClass(
      name='Level_type',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='min',
          type_annotation=AtomicTypeAnnotation(
            identifier='bool',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='nom',
          type_annotation=AtomicTypeAnnotation(
            identifier='bool',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='typ',
          type_annotation=AtomicTypeAnnotation(
            identifier='bool',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='max',
          type_annotation=AtomicTypeAnnotation(
            identifier='bool',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='min',
              type_annotation=AtomicTypeAnnotation(
                identifier='bool',
                node=...),
              default=None,
              node=...),
            Argument(
              name='nom',
              type_annotation=AtomicTypeAnnotation(
                identifier='bool',
                node=...),
              default=None,
              node=...),
            Argument(
              name='typ',
              type_annotation=AtomicTypeAnnotation(
                identifier='bool',
                node=...),
              default=None,
              node=...),
            Argument(
              name='max',
              type_annotation=AtomicTypeAnnotation(
                identifier='bool',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_reference_pair',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='Value_type_IEC_61360',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_ID',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value',
              type_annotation=AtomicTypeAnnotation(
                identifier='Value_type_IEC_61360',
                node=...),
              default=None,
              node=...),
            Argument(
              name='value_ID',
              type_annotation=AtomicTypeAnnotation(
                identifier='Reference',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Value_list',
      is_implementation_specific=False,
      inheritances=[],
      properties=[
        Property(
          name='value_reference_pairs',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_reference_pair',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='value_reference_pairs',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_reference_pair',
                    node=...)],
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Value reference pair types must contain at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_reference_pairs',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_preferred_name_type_IEC_61360',
      is_implementation_specific=False,
      inheritances=[
        'Abstract_lang_string'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='String shall have a maximum length of 255 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=255,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_short_name_type_IEC_61360',
      is_implementation_specific=False,
      inheritances=[
        'Abstract_lang_string'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='String shall have a maximum length of 18 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=18,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Lang_string_definition_type_IEC_61360',
      is_implementation_specific=False,
      inheritances=[
        'Abstract_lang_string'],
      properties=[],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='language',
              type_annotation=AtomicTypeAnnotation(
                identifier='BCP_47_language_tag',
                node=...),
              default=None,
              node=...),
            Argument(
              name='text',
              type_annotation=AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...),
              default=None,
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='String shall have a maximum length of 1023 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='text',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=1023,
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=None,
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...),
    ConcreteClass(
      name='Data_specification_IEC_61360',
      is_implementation_specific=False,
      inheritances=[
        'Data_specification_content'],
      properties=[
        Property(
          name='preferred_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Lang_string_preferred_name_type_IEC_61360',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='short_name',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_short_name_type_IEC_61360',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='unit',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='unit_ID',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Reference',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='source_of_definition',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='symbol',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='data_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Data_type_IEC_61360',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='definition',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_definition_type_IEC_61360',
                    node=...)],
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_format',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Non_empty_XML_serializable_string',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value_list',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_list',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='value',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Value_type_IEC_61360',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...),
        Property(
          name='level_type',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Level_type',
                node=...)],
            node=...),
          description=Description(
            document=...,
            node=...),
          node=...)],
      methods=[
        ConstructorToBeUnderstood(
          name='__init__',
          verification=False,
          arguments=[
            Argument(
              name='self',
              type_annotation=SelfTypeAnnotation(),
              default=None,
              node=...),
            Argument(
              name='preferred_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Lang_string_preferred_name_type_IEC_61360',
                    node=...)],
                node=...),
              default=None,
              node=...),
            Argument(
              name='short_name',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_short_name_type_IEC_61360',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='unit',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_XML_serializable_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='unit_ID',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Reference',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='source_of_definition',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_XML_serializable_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='symbol',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_XML_serializable_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='data_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Data_type_IEC_61360',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='definition',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  SubscriptedTypeAnnotation(
                    identifier='List',
                    subscripts=[
                      AtomicTypeAnnotation(
                        identifier='Lang_string_definition_type_IEC_61360',
                        node=...)],
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_format',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Non_empty_XML_serializable_string',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value_list',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_list',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='value',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Value_type_IEC_61360',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...),
            Argument(
              name='level_type',
              type_annotation=SubscriptedTypeAnnotation(
                identifier='Optional',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Level_type',
                    node=...)],
                node=...),
              default=Default(
                node=...),
              node=...)],
          returns=None,
          description=None,
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          non_mutating=False,
          node=...,
          arguments_by_name=...,
          body=...)],
      invariants=[
        Invariant(
          description='Constraint AASc-3a-010: If value is not empty then value list shall be empty and vice versa.',
          body=textwrap.dedent("""\
            Not(
              operand=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_list',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-009: If data type is a an integer, real or rational with a measure or currency, unit or unit ID shall be defined.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='data_type',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='data_type',
                      original_node=...),
                    container=Name(
                      identifier='IEC_61360_data_types_with_unit',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='unit',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='unit_ID',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Definition must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='definition',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Definition must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='definition',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Short name must be either not set or have at least one item.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='short_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='short_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Short name must specify unique languages.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='short_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='short_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Preferred name must have at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='preferred_name',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          node=...),
        Invariant(
          description='Preferred name must specify unique languages.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='lang_strings_have_unique_languages',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='preferred_name',
                  original_node=...)],
              original_node=...)"""),
          node=...),
        Invariant(
          description='Constraint AASc-3a-002: preferred name shall be provided at least in English.',
          body=textwrap.dedent("""\
            Any(
              generator=ForEach(
                variable=Name(
                  identifier='lang_string',
                  original_node=...),
                iteration=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='preferred_name',
                  original_node=...),
                original_node=...),
              condition=FunctionCall(
                name='is_BCP_47_for_english',
                args=[
                  Member(
                    instance=Name(
                      identifier='lang_string',
                      original_node=...),
                    name='language',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          node=...)],
      serialization=Serialization(
        with_model_type=True),
      description=Description(
        document=...,
        node=...),
      node=...,
      properties_by_name=...,
      methods_by_name=...)],
  constants=[
    ConstantSet(
      name='Valid_categories_for_data_element',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='str',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Generic_fragment_keys',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Generic_globally_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_submodel_elements_as_keys',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_referable_non_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_submodel_elements_as_keys'],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='AAS_referables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_referable_non_identifiables',
        'AAS_identifiables'],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Globally_identifiables',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_identifiables',
        'Generic_globally_identifiables'],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Fragment_keys',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Key_types',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[
        'AAS_referable_non_identifiables',
        'Generic_fragment_keys'],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Data_type_IEC_61360_for_property_or_value',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Data_type_IEC_61360',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Data_type_IEC_61360_for_reference',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Data_type_IEC_61360',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='Data_type_IEC_61360_for_document',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Data_type_IEC_61360',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...),
    ConstantSet(
      name='IEC_61360_data_types_with_unit',
      items_type_annotation=AtomicTypeAnnotation(
        identifier='Data_type_IEC_61360',
        node=...),
      set_literals=[
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...),
        SetLiteral(
          node=...)],
      subsets=[],
      description=Description(
        document=...,
        node=...),
      node=...)],
  verification_functions=[
    UnderstoodMethod(
      name='matches_ID_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^[a-zA-Z][a-zA-Z0-9_]*$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_version_type',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^(0|[1-9][0-9]*)$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_revision_type',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^(0|[1-9][0-9]*)$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time_UTC',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hour_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(([01]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(2[0-3]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='second_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '([0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')(\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='end_of_day_frag',
              original_node=...),
            value=Constant(
              value='24:00:00(\\\\.0+)?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=Constant(
              value='(Z|\\\\+00:00|-00:00)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_time_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                'T((',
                FormattedValue(
                  value=Name(
                    identifier='hour_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='second_frag',
                    original_node=...),
                  original_node=...),
                ')|',
                FormattedValue(
                  value=Name(
                    identifier='end_of_day_frag',
                    original_node=...),
                  original_node=...),
                ')',
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_time_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_xs_date_time_UTC',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_MIME_type',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='tchar',
              original_node=...),
            value=Constant(
              value="[!#$%&'*+\\\\-.^_`|~0-9a-zA-Z]",
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='token',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='tchar',
                    original_node=...),
                  original_node=...),
                ')+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='type',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='subtype',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ows',
              original_node=...),
            value=Constant(
              value='[ \\t]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='obs_text',
              original_node=...),
            value=Constant(
              value='[\\\\x80-\\\\xff]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='qd_text',
              original_node=...),
            value=JoinedStr(
              values=[
                '([\\t !#-\\\\[\\\\]-~]|',
                FormattedValue(
                  value=Name(
                    identifier='obs_text',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='quoted_pair',
              original_node=...),
            value=JoinedStr(
              values=[
                '\\\\\\\\([\\t !-~]|',
                FormattedValue(
                  value=Name(
                    identifier='obs_text',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='quoted_string',
              original_node=...),
            value=JoinedStr(
              values=[
                '"(',
                FormattedValue(
                  value=Name(
                    identifier='qd_text',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='quoted_pair',
                    original_node=...),
                  original_node=...),
                ')*"'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='parameter',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...),
                '=(',
                FormattedValue(
                  value=Name(
                    identifier='token',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='quoted_string',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='media_type',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='type',
                    original_node=...),
                  original_node=...),
                '/',
                FormattedValue(
                  value=Name(
                    identifier='subtype',
                    original_node=...),
                  original_node=...),
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ows',
                    original_node=...),
                  original_node=...),
                ';',
                FormattedValue(
                  value=Name(
                    identifier='ows',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='parameter',
                    original_node=...),
                  original_node=...),
                ')*$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='media_type',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_RFC_8089_path',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='h16',
              original_node=...),
            value=Constant(
              value='[0-9A-Fa-f]{1,4}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='dec_octet',
              original_node=...),
            value=Constant(
              value='([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv4address',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ls32',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv6address',
              original_node=...),
            value=JoinedStr(
              values=[
                '((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){6}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){5}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){4}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':)?',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){3}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,2}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){2}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,3}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,4}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,5}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,6}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unreserved',
              original_node=...),
            value=Constant(
              value='[a-zA-Z0-9\\\\-._~]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='sub_delims',
              original_node=...),
            value=Constant(
              value="[!$&'()*+,;=]",
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipvfuture',
              original_node=...),
            value=JoinedStr(
              values=[
                '[vV][0-9A-Fa-f]+\\\\.(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|:)+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ip_literal',
              original_node=...),
            value=JoinedStr(
              values=[
                '\\\\[(',
                FormattedValue(
                  value=Name(
                    identifier='ipv6address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipvfuture',
                    original_node=...),
                  original_node=...),
                ')\\\\]'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pct_encoded',
              original_node=...),
            value=Constant(
              value='%[0-9A-Fa-f][0-9A-Fa-f]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='reg_name',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='host',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ip_literal',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='reg_name',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_auth',
              original_node=...),
            value=JoinedStr(
              values=[
                '(localhost|',
                FormattedValue(
                  value=Name(
                    identifier='host',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pchar',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|[:@])'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='segment_nz',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='pchar',
                    original_node=...),
                  original_node=...),
                ')+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='segment',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='pchar',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='path_absolute',
              original_node=...),
            value=JoinedStr(
              values=[
                '/(',
                FormattedValue(
                  value=Name(
                    identifier='segment_nz',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='segment',
                    original_node=...),
                  original_node=...),
                ')*)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='auth_path',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='file_auth',
                    original_node=...),
                  original_node=...),
                ')?',
                FormattedValue(
                  value=Name(
                    identifier='path_absolute',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='local_path',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='path_absolute',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_hier_part',
              original_node=...),
            value=JoinedStr(
              values=[
                '(//',
                FormattedValue(
                  value=Name(
                    identifier='auth_path',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='local_path',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_scheme',
              original_node=...),
            value=Constant(
              value='file',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='file_uri',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='file_scheme',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='file_hier_part',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='file_uri',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_BCP_47',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='alphanum',
              original_node=...),
            value=Constant(
              value='[a-zA-Z0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='singleton',
              original_node=...),
            value=Constant(
              value='[0-9A-WY-Za-wy-z]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='extension',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='singleton',
                    original_node=...),
                  original_node=...),
                '(-(',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){2,8})+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='extlang',
              original_node=...),
            value=Constant(
              value='[a-zA-Z]{3}(-[a-zA-Z]{3}){,2}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='irregular',
              original_node=...),
            value=Constant(
              value='(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='regular',
              original_node=...),
            value=Constant(
              value='(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='grandfathered',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='irregular',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='regular',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='language',
              original_node=...),
            value=JoinedStr(
              values=[
                '([a-zA-Z]{2,3}(-',
                FormattedValue(
                  value=Name(
                    identifier='extlang',
                    original_node=...),
                  original_node=...),
                ')?|[a-zA-Z]{4}|[a-zA-Z]{5,8})'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='script',
              original_node=...),
            value=Constant(
              value='[a-zA-Z]{4}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='region',
              original_node=...),
            value=Constant(
              value='([a-zA-Z]{2}|[0-9]{3})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='variant',
              original_node=...),
            value=JoinedStr(
              values=[
                '((',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){5,8}|[0-9](',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){3})'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='privateuse',
              original_node=...),
            value=JoinedStr(
              values=[
                '[xX](-(',
                FormattedValue(
                  value=Name(
                    identifier='alphanum',
                    original_node=...),
                  original_node=...),
                '){1,8})+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='langtag',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='language',
                    original_node=...),
                  original_node=...),
                '(-',
                FormattedValue(
                  value=Name(
                    identifier='script',
                    original_node=...),
                  original_node=...),
                ')?(-',
                FormattedValue(
                  value=Name(
                    identifier='region',
                    original_node=...),
                  original_node=...),
                ')?(-',
                FormattedValue(
                  value=Name(
                    identifier='variant',
                    original_node=...),
                  original_node=...),
                ')*(-',
                FormattedValue(
                  value=Name(
                    identifier='extension',
                    original_node=...),
                  original_node=...),
                ')*(-',
                FormattedValue(
                  value=Name(
                    identifier='privateuse',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='language_tag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='langtag',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='privateuse',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='grandfathered',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='language_tag',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='lang_strings_have_unique_languages',
      verification=True,
      arguments=[
        Argument(
          name='lang_strings',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Abstract_lang_string',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='qualifier_types_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='qualifiers',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Qualifier',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_XML_serializable_string',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=Constant(
              value='^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_any_URI',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='scheme',
              original_node=...),
            value=Constant(
              value='[a-zA-Z][a-zA-Z0-9+\\\\-.]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ucschar',
              original_node=...),
            value=Constant(
              value='[\\\\xa0-\\\\ud7ff\\\\uf900-\\\\ufdcf\\\\ufdf0-\\\\uffef\\\\U00010000-\\\\U0001fffd\\\\U00020000-\\\\U0002fffd\\\\U00030000-\\\\U0003fffd\\\\U00040000-\\\\U0004fffd\\\\U00050000-\\\\U0005fffd\\\\U00060000-\\\\U0006fffd\\\\U00070000-\\\\U0007fffd\\\\U00080000-\\\\U0008fffd\\\\U00090000-\\\\U0009fffd\\\\U000a0000-\\\\U000afffd\\\\U000b0000-\\\\U000bfffd\\\\U000c0000-\\\\U000cfffd\\\\U000d0000-\\\\U000dfffd\\\\U000e1000-\\\\U000efffd]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iunreserved',
              original_node=...),
            value=JoinedStr(
              values=[
                '([a-zA-Z0-9\\\\-._~]|',
                FormattedValue(
                  value=Name(
                    identifier='ucschar',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pct_encoded',
              original_node=...),
            value=Constant(
              value='%[0-9A-Fa-f][0-9A-Fa-f]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='sub_delims',
              original_node=...),
            value=Constant(
              value="[!$&'()*+,;=]",
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iuserinfo',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|:)*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='h16',
              original_node=...),
            value=Constant(
              value='[0-9A-Fa-f]{1,4}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='dec_octet',
              original_node=...),
            value=Constant(
              value='([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv4address',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='dec_octet',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ls32',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipv6address',
              original_node=...),
            value=JoinedStr(
              values=[
                '((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){6}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){5}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){4}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':)?',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){3}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,2}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::(',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){2}',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,3}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,4}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='ls32',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,5}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                '|((',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ':){,6}',
                FormattedValue(
                  value=Name(
                    identifier='h16',
                    original_node=...),
                  original_node=...),
                ')?::)'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unreserved',
              original_node=...),
            value=Constant(
              value='[a-zA-Z0-9\\\\-._~]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipvfuture',
              original_node=...),
            value=JoinedStr(
              values=[
                '[vV][0-9A-Fa-f]+\\\\.(',
                FormattedValue(
                  value=Name(
                    identifier='unreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|:)+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ip_literal',
              original_node=...),
            value=JoinedStr(
              values=[
                '\\\\[(',
                FormattedValue(
                  value=Name(
                    identifier='ipv6address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipvfuture',
                    original_node=...),
                  original_node=...),
                ')\\\\]'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ireg_name',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ihost',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ip_literal',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipv4address',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ireg_name',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='port',
              original_node=...),
            value=Constant(
              value='[0-9]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iauthority',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iuserinfo',
                    original_node=...),
                  original_node=...),
                '@)?',
                FormattedValue(
                  value=Name(
                    identifier='ihost',
                    original_node=...),
                  original_node=...),
                '(:',
                FormattedValue(
                  value=Name(
                    identifier='port',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipchar',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|[:@])'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='isegment',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_abempty',
              original_node=...),
            value=JoinedStr(
              values=[
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='isegment_nz',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                ')+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_absolute',
              original_node=...),
            value=JoinedStr(
              values=[
                '/(',
                FormattedValue(
                  value=Name(
                    identifier='isegment_nz',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_rootless',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='isegment_nz',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_empty',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                '){0}'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ihier_part',
              original_node=...),
            value=JoinedStr(
              values=[
                '(//',
                FormattedValue(
                  value=Name(
                    identifier='iauthority',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='ipath_abempty',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_absolute',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_rootless',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_empty',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iprivate',
              original_node=...),
            value=Constant(
              value='[\\\\ue000-\\\\uf8ff\\\\U000f0000-\\\\U000ffffd\\\\U00100000-\\\\U0010fffd]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iquery',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='iprivate',
                    original_node=...),
                  original_node=...),
                '|[/?])*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ifragment',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='ipchar',
                    original_node=...),
                  original_node=...),
                '|[/?])*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='isegment_nz_nc',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iunreserved',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='pct_encoded',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='sub_delims',
                    original_node=...),
                  original_node=...),
                '|@)+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='ipath_noscheme',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='isegment_nz_nc',
                    original_node=...),
                  original_node=...),
                '(/',
                FormattedValue(
                  value=Name(
                    identifier='isegment',
                    original_node=...),
                  original_node=...),
                ')*'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='irelative_part',
              original_node=...),
            value=JoinedStr(
              values=[
                '(//',
                FormattedValue(
                  value=Name(
                    identifier='iauthority',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='ipath_abempty',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_absolute',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_noscheme',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='ipath_empty',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='irelative_ref',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='irelative_part',
                    original_node=...),
                  original_node=...),
                '(\\\\?',
                FormattedValue(
                  value=Name(
                    identifier='iquery',
                    original_node=...),
                  original_node=...),
                ')?(\\\\#',
                FormattedValue(
                  value=Name(
                    identifier='ifragment',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iri',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='scheme',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='ihier_part',
                    original_node=...),
                  original_node=...),
                '(\\\\?',
                FormattedValue(
                  value=Name(
                    identifier='iquery',
                    original_node=...),
                  original_node=...),
                ')?(\\\\#',
                FormattedValue(
                  value=Name(
                    identifier='ifragment',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='iri_reference',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='iri',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='irelative_ref',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='iri_reference',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_base_64_binary',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b04_char',
              original_node=...),
            value=Constant(
              value='[AQgw]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b04',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b04_char',
                    original_node=...),
                  original_node=...),
                '\\\\x20?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b16_char',
              original_node=...),
            value=Constant(
              value='[AEIMQUYcgkosw048]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b16',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b16_char',
                    original_node=...),
                  original_node=...),
                '\\\\x20?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64_char',
              original_node=...),
            value=Constant(
              value='[A-Za-z0-9+/]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b64_char',
                    original_node=...),
                  original_node=...),
                '\\\\x20?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64quad',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64_final_quad',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64_char',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='padded_8',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b04',
                    original_node=...),
                  original_node=...),
                '= ?='],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='padded_16',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b64',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='b16',
                    original_node=...),
                  original_node=...),
                '='],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='b64final',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64_final_quad',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='padded_16',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='padded_8',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='base64_binary',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='b64quad',
                    original_node=...),
                  original_node=...),
                '*',
                FormattedValue(
                  value=Name(
                    identifier='b64final',
                    original_node=...),
                  original_node=...),
                ')?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='base64_binary',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_boolean',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=Constant(
              value='^(true|false|1|0)$',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(Z|(\\\\+|-)((0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '|1[0-3]):',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                '|14:00))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...),
                '?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_date_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='year_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '-?(([1-9]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)|(0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='month_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|(1[0-2]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='day_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '((0[1-9])|([12]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(3[01]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hour_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(([01]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')|(2[0-3]))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='minute_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '[0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='second_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '([0-5]',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                ')(\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+)?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='end_of_day_frag',
              original_node=...),
            value=Constant(
              value='24:00:00(\\\\.0+)?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='timezone_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                '(Z|(\\\\+|-)((0',
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '|1[0-3]):',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                '|14:00))'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='date_time_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='year_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='month_frag',
                    original_node=...),
                  original_node=...),
                '-',
                FormattedValue(
                  value=Name(
                    identifier='day_frag',
                    original_node=...),
                  original_node=...),
                'T((',
                FormattedValue(
                  value=Name(
                    identifier='hour_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='minute_frag',
                    original_node=...),
                  original_node=...),
                ':',
                FormattedValue(
                  value=Name(
                    identifier='second_frag',
                    original_node=...),
                  original_node=...),
                ')|',
                FormattedValue(
                  value=Name(
                    identifier='end_of_day_frag',
                    original_node=...),
                  original_node=...),
                ')',
                FormattedValue(
                  value=Name(
                    identifier='timezone_frag',
                    original_node=...),
                  original_node=...),
                '?'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='date_time_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='is_xs_date_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_decimal',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='digit',
              original_node=...),
            value=Constant(
              value='[0-9]',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_no_decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='no_decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                '(\\\\+|-)?',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_no_decimal_pt_numeral',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='frac_frag',
              original_node=...),
            value=JoinedStr(
              values=[
                FormattedValue(
                  value=Name(
                    identifier='digit',
                    original_node=...),
                  original_node=...),
                '+'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_no_decimal_pt_numeral',
                    original_node=...),
                  original_node=...),
                '\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='frac_frag',
                    original_node=...),
                  original_node=...),
                '|\\\\.',
                FormattedValue(
                  value=Name(
                    identifier='frac_frag',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='decimal_pt_numeral',
              original_node=...),
            value=JoinedStr(
              values=[
                '(\\\\+|-)?',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_decimal_pt_numeral',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='decimal_lexical_rep',
              original_node=...),
            value=JoinedStr(
              values=[
                '(',
                FormattedValue(
                  value=Name(
                    identifier='decimal_pt_numeral',
                    original_node=...),
                  original_node=...),
                '|',
                FormattedValue(
                  value=Name(
                    identifier='no_decimal_pt_numeral',
                    original_node=...),
                  original_node=...),
                ')'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='decimal_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_double',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='double_rep',
              original_node=...),
            value=Constant(
              value='((\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|-?INF|NaN)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='double_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_duration',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='duration_rep',
              original_node=...),
            value=Constant(
              value='-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\\\.[0-9]+)?S)?|([0-9]+(\\\\.[0-9]+)?S))))',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='duration_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_float',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='float_rep',
              original_node=...),
            value=Constant(
              value='((\\\\+|-)?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([Ee](\\\\+|-)?[0-9]+)?|-?INF|NaN)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='float_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_day',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_day_lexical_rep',
              original_node=...),
            value=Constant(
              value='---(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_day_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_month',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_month_lexical_rep',
              original_node=...),
            value=Constant(
              value='--(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_month_lexical_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_month_day',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_month_day_rep',
              original_node=...),
            value=Constant(
              value='--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_month_day_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_year',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_year_rep',
              original_node=...),
            value=Constant(
              value='-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_year_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_g_year_month',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='g_year_month_rep',
              original_node=...),
            value=Constant(
              value='-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='g_year_month_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_hex_binary',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='hex_binary',
              original_node=...),
            value=Constant(
              value='([0-9a-fA-F]{2})*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='hex_binary',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_time',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='time_rep',
              original_node=...),
            value=Constant(
              value='(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\\\.[0-9]+)?|(24:00:00(\\\\.0+)?))(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='time_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='integer_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?[0-9]+',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_long',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='long_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,20}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='long_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_int',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='int_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,10}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='int_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='short_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,5}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='short_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_byte',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='byte_rep',
              original_node=...),
            value=Constant(
              value='[\\\\-+]?0*[0-9]{1,3}',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='byte_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_non_negative_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='non_negative_integer_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?[0-9]+)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='non_negative_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_positive_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='positive_integer_rep',
              original_node=...),
            value=Constant(
              value='\\\\+?0*[1-9][0-9]*',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='positive_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_long',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_long_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,20})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_long_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_int',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_int_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,10})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_int_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_short',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_short_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,5})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_short_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_unsigned_byte',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='unsigned_byte_rep',
              original_node=...),
            value=Constant(
              value='(-0|\\\\+?0*[0-9]{1,3})',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='unsigned_byte_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_non_positive_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='non_positive_integer_rep',
              original_node=...),
            value=Constant(
              value='(\\\\+0|0|-[0-9]+)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='non_positive_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_negative_integer',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='negative_integer_rep',
              original_node=...),
            value=Constant(
              value='(-0*[1-9][0-9]*)',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^',
                FormattedValue(
                  value=Name(
                    identifier='negative_integer_rep',
                    original_node=...),
                  original_node=...),
                '$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='matches_xs_string',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=Constant(
              value='^[\\\\x09\\\\x0A\\\\x0D\\\\x20-\\\\uD7FF\\\\uE000-\\\\uFFFD\\\\U00010000-\\\\U0010FFFF]*$',
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='value_consistent_with_XSD_type',
      verification=True,
      arguments=[
        Argument(
          name='value',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...),
        Argument(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='is_model_reference_to',
      verification=True,
      arguments=[
        Argument(
          name='reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...),
        Argument(
          name='expected_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Key_types',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Return(
            value=And(
              values=[
                Comparison(
                  left=Member(
                    instance=Name(
                      identifier='reference',
                      original_node=...),
                    name='type',
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Reference_types',
                      original_node=...),
                    name='Model_reference',
                    original_node=...),
                  original_node=...),
                Comparison(
                  left=FunctionCall(
                    name='len',
                    args=[
                      Member(
                        instance=Name(
                          identifier='reference',
                          original_node=...),
                        name='keys',
                        original_node=...)],
                    original_node=...),
                  op='NE',
                  right=Constant(
                    value=0,
                    original_node=...),
                  original_node=...),
                Comparison(
                  left=Member(
                    instance=Index(
                      collection=Member(
                        instance=Name(
                          identifier='reference',
                          original_node=...),
                        name='keys',
                        original_node=...),
                      index=Constant(
                        value=-1,
                        original_node=...),
                      original_node=...),
                    name='type',
                    original_node=...),
                  op='EQ',
                  right=Name(
                    identifier='expected_type',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='is_model_reference_to_referable',
      verification=True,
      arguments=[
        Argument(
          name='reference',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Return(
            value=And(
              values=[
                Comparison(
                  left=Member(
                    instance=Name(
                      identifier='reference',
                      original_node=...),
                    name='type',
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Reference_types',
                      original_node=...),
                    name='Model_reference',
                    original_node=...),
                  original_node=...),
                Comparison(
                  left=FunctionCall(
                    name='len',
                    args=[
                      Member(
                        instance=Name(
                          identifier='reference',
                          original_node=...),
                        name='keys',
                        original_node=...)],
                    original_node=...),
                  op='NE',
                  right=Constant(
                    value=0,
                    original_node=...),
                  original_node=...),
                IsIn(
                  member=Member(
                    instance=Index(
                      collection=Member(
                        instance=Name(
                          identifier='reference',
                          original_node=...),
                        name='keys',
                        original_node=...),
                      index=Constant(
                        value=-1,
                        original_node=...),
                      original_node=...),
                    name='type',
                    original_node=...),
                  container=Name(
                    identifier='AAS_referables',
                    original_node=...),
                  original_node=...)],
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='ID_shorts_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='referables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Referable',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='ID_shorts_of_variables_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='input_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          default=None,
          node=...),
        Argument(
          name='output_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          default=None,
          node=...),
        Argument(
          name='inoutput_variables',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='Optional',
            subscripts=[
              SubscriptedTypeAnnotation(
                identifier='List',
                subscripts=[
                  AtomicTypeAnnotation(
                    identifier='Operation_variable',
                    node=...)],
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='extension_names_are_unique',
      verification=True,
      arguments=[
        Argument(
          name='extensions',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Extension',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='submodel_elements_have_identical_semantic_IDs',
      verification=True,
      arguments=[
        Argument(
          name='elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='submodel_element_is_of_type',
      verification=True,
      arguments=[
        Argument(
          name='element',
          type_annotation=AtomicTypeAnnotation(
            identifier='Submodel_element',
            node=...),
          default=None,
          node=...),
        Argument(
          name='element_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='AAS_submodel_elements',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='properties_or_ranges_have_value_type',
      verification=True,
      arguments=[
        Argument(
          name='elements',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Submodel_element',
                node=...)],
            node=...),
          default=None,
          node=...),
        Argument(
          name='value_type',
          type_annotation=AtomicTypeAnnotation(
            identifier='Data_type_def_XSD',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='reference_key_values_equal',
      verification=True,
      arguments=[
        Argument(
          name='that',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...),
        Argument(
          name='other',
          type_annotation=AtomicTypeAnnotation(
            identifier='Reference',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='data_specification_IEC_61360s_for_property_or_value_have_appropriate_data_type',
      verification=True,
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Embedded_data_specification',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='data_specification_IEC_61360s_for_reference_have_appropriate_data_type',
      verification=True,
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Embedded_data_specification',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='data_specification_IEC_61360s_for_document_have_appropriate_data_type',
      verification=True,
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Embedded_data_specification',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='data_specification_IEC_61360s_have_data_type',
      verification=True,
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Embedded_data_specification',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='data_specification_IEC_61360s_have_value',
      verification=True,
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Embedded_data_specification',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    ImplementationSpecificMethod(
      name='data_specification_IEC_61360s_have_definition_at_least_in_english',
      verification=True,
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=SubscriptedTypeAnnotation(
            identifier='List',
            subscripts=[
              AtomicTypeAnnotation(
                identifier='Embedded_data_specification',
                node=...)],
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      node=...,
      arguments_by_name=...),
    UnderstoodMethod(
      name='is_BCP_47_for_english',
      verification=True,
      arguments=[
        Argument(
          name='text',
          type_annotation=AtomicTypeAnnotation(
            identifier='str',
            node=...),
          default=None,
          node=...)],
      returns=AtomicTypeAnnotation(
        identifier='bool',
        node=...),
      description=Description(
        document=...,
        node=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      non_mutating=False,
      body=[
        textwrap.dedent("""\
          Assignment(
            target=Name(
              identifier='pattern',
              original_node=...),
            value=JoinedStr(
              values=[
                '^(en|EN)(-.*)?$'],
              original_node=...),
            original_node=...)"""),
        textwrap.dedent("""\
          Return(
            value=IsNotNone(
              value=FunctionCall(
                name='match',
                args=[
                  Name(
                    identifier='pattern',
                    original_node=...),
                  Name(
                    identifier='text',
                    original_node=...)],
                original_node=...),
              original_node=...),
            original_node=...)""")],
      node=...,
      arguments_by_name=...)],
  meta_model=MetaModel(
    description=Description(
      document=...,
      node=...),
    version='V3.0',
    xml_namespace='https://admin-shell.io/aas/3/0'))