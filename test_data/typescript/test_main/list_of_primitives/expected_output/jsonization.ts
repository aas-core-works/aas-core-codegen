/**
 * Provide de/serialization of AAS classes to/from JSON.
 *
 * We can not use one-pass deserialization for JSON since the object
 * properties do not have fixed order, and hence we can not read
 * `modelType` property ahead of the remaining properties.
 */

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import * as AasCommon from "./common";
import * as AasTypes from "./types";
import * as AasStringification from "./stringification";

export type JsonValue = string | number | boolean | JsonObject | JsonArray;

export type JsonArray = Iterable<JsonValue>;
export type JsonObject = { [prop: string]: JsonValue };

/**
 * Represent a property on a path to the erroneous value.
 */
export class PropertySegment {
  /**
   * Instance that contains the property
   */
  readonly instance: JsonObject;

  /**
   * Name of the property
   */
  readonly name: string;

  constructor(instance: JsonObject, name: string) {
    this.instance = instance;
    this.name = name;
  }
}

/**
 * Represent an index access on a path to the erroneous value.
 */
export class IndexSegment {
  /**
   * Container that contains the item
   */
  readonly container: JsonArray;

  /**
   * Index of the item
   */
  readonly index: number;

  constructor(container: JsonArray, index: number) {
    if (!Number.isInteger(index)) {
      throw new Error(`Expected an integer for the index, but got: ${index}`);
    }

    this.container = container;
    this.index = index;
  }
}

export type Segment = PropertySegment | IndexSegment;

/**
 * Represent the relative path to the erroneous value.
 */
export class Path {
  private readonly _segments = new Array<Segment>();

  /**
   * Get the segments of the path.
   */
  segments(): Array<Segment> {
    return this._segments;
  }

  /**
   * Insert the `segment` in front of the {@link segments}.
   *
   * @param segment - segment to be prepended to {@link segments}
   */
  prepend(segment: Segment): void {
    this._segments.unshift(segment);
  }

  toString(): string {
    if (this._segments.length === 0) {
      return "";
    }

    const parts = new Array<string>();

    let segment = this._segments[0];

    if (segment instanceof PropertySegment) {
      parts.push(segment.name);
    } else if (segment instanceof IndexSegment) {
      parts.push(`[${segment.index}]`);
    } else {
      throw new Error(`Unexpected segment: ${segment}`);
    }

    for (let i = 1; i < this._segments.length; i++) {
      segment = this._segments[i];
      if (segment instanceof PropertySegment) {
        parts.push(`.${segment.name}`);
      } else if (segment instanceof IndexSegment) {
        parts.push(`[${segment.index}]`);
      } else {
        throw new Error(`Unexpected segment: ${segment}`);
      }
    }

    return parts.join("");
  }
}

// region De-serialization

/**
 * Signal that the JSON de-serialization could not be performed.
 */
export class DeserializationError {
  /**
   * Human-readable explanation of the error
   */
  readonly message: string;

  /**
   * Relative path to the erroneous value
   */
  readonly path: Path;

  constructor(message: string, path: Path | null = null) {
    this.message = message;
    this.path = path ?? new Path();
  }
}

/**
 * Create an error as {@link common.Either}.
 *
 * @param message - human-readable explanation of the error
 * @returns An {@link common.Either } with the error set
 * @typeParam T - type of the value if there had been no error
 */
function newDeserializationError<T>(
  message: string
): AasCommon.Either<T, DeserializationError> {
  return new AasCommon.Either<T, DeserializationError>(
    null,
    new DeserializationError(message)
  );
}

/**
 * Parse `jsonable` as a boolean.
 *
 * @param jsonable - to be parsed
 * @returns parsed boolean value, or an error
 */
function booleanFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<boolean, DeserializationError> {
  // `typeof` seems to be optimized these days, so we use it instead of
  // literal comparison, see:
  // https://stackoverflow.com/questions/61786250/is-typeof-faster-than-literal-comparison

  if (jsonable === null) {
    return newDeserializationError<boolean>(
      "Expected a boolean, but got null"
    );
  }
  if (typeof jsonable !== "boolean") {
    return newDeserializationError<boolean>(
      `Expected a boolean, but got ${typeof jsonable}`
    );
  }

  return new AasCommon.Either<boolean, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as an integer.
 *
 * @param jsonable - to be parsed
 * @returns parsed integer value, or an error
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function integerFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<number, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<number>(
      "Expected an integer number, but got null"
    );
  }
  if (typeof jsonable !== "number") {
    return newDeserializationError<number>(
      `Expected an integer number, but got: ${typeof jsonable}`
    );
  }

  if (!Number.isInteger(jsonable)) {
    return newDeserializationError<number>(
      `Expected an integer number, but got: ${jsonable}`
    );
  }

  return new AasCommon.Either<number, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as a number.
 *
 * @param jsonable - to be parsed
 * @returns parsed numeric value, or an error
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function numberFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<number, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<number>(
      "Expected a number, but got null"
    );
  }
  if (typeof jsonable !== "number") {
    return newDeserializationError<number>(
      `Expected a number, but got: ${typeof jsonable}`
    );
  }

  return new AasCommon.Either<number, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as a string.
 *
 * @param jsonable - to be parsed
 * @returns parsed string value, or an error
 */
function stringFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<string, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<string>(
      "Expected a string, but got null"
    );
  }
  if (typeof jsonable !== "string") {
    return newDeserializationError<string>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  return new AasCommon.Either<string, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as a byte array.
 *
 * @param jsonable - to be parsed
 * @returns parsed byte array, or an error
 */
function bytesFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<Uint8Array, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<Uint8Array>(
      "Expected a base64-encoded string, but got null"
    );
  }
  if (typeof jsonable !== "string") {
    return newDeserializationError<Uint8Array>(
      `Expected a base64-encoded string, but got: ${typeof jsonable}`
    );
  }

  const either = AasCommon.base64Decode(jsonable);
  if (either.error !== null) {
    return newDeserializationError<Uint8Array>(either.error);
  }
  return new AasCommon.Either<Uint8Array, DeserializationError>(
    either.mustValue(), null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ListOfPrimitives}.
 */
class SetterForListOfPrimitives {
  strings: Array<string> | null = null;

  integers: Array<number> | null = null;

  booleans: Array<boolean> | null = null;

  /**
   * Parse `jsonable` as the value of {@link strings}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setStringsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<string>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = stringFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.strings = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link integers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIntegersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<number>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = integerFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.integers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link booleans}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setBooleansFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<boolean>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = booleanFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.booleans = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!ListOfPrimitives} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ListOfPrimitives},
 * or an error if any
 */
export function listOfPrimitivesFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.ListOfPrimitives,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.ListOfPrimitives>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.ListOfPrimitives>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.ListOfPrimitives>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForListOfPrimitives();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LIST_OF_PRIMITIVES.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.ListOfPrimitives,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.strings === null) {
    return newDeserializationError<
      AasTypes.ListOfPrimitives
    >(
      "The required property 'strings' is missing"
    );
  }

  if (setter.integers === null) {
    return newDeserializationError<
      AasTypes.ListOfPrimitives
    >(
      "The required property 'integers' is missing"
    );
  }

  if (setter.booleans === null) {
    return newDeserializationError<
      AasTypes.ListOfPrimitives
    >(
      "The required property 'booleans' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.ListOfPrimitives,
    DeserializationError
  >(
    new AasTypes.ListOfPrimitives(
      setter.strings,
      setter.integers,
      setter.booleans
    ),
    null
  );
}

const SETTER_MAP_FOR_LIST_OF_PRIMITIVES =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "strings",
        SetterForListOfPrimitives.prototype.setStringsFromJsonable
      ],
      [
        "integers",
        SetterForListOfPrimitives.prototype.setIntegersFromJsonable
      ],
      [
        "booleans",
        SetterForListOfPrimitives.prototype.setBooleansFromJsonable
      ],
    ]
  );

// endregion

// region Serialization

/**
 * Transform the instance to its JSON-able representation.
 */
class Serializer extends AasTypes.AbstractTransformer<JsonObject> {


  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformListOfPrimitives(
    that: AasTypes.ListOfPrimitives
  ): JsonObject {
    const jsonable: JsonObject = {};

    const stringsArray = new Array<JsonValue>();
    for (const item of that.strings) {
      stringsArray.push(
        stringFromJsonable(item).mustValue()
      );
    }
    jsonable["strings"] = stringsArray;

    const integersArray = new Array<JsonValue>();
    for (const item of that.integers) {
      integersArray.push(
        integerFromJsonable(item).mustValue()
      );
    }
    jsonable["integers"] = integersArray;

    const booleansArray = new Array<JsonValue>();
    for (const item of that.booleans) {
      booleansArray.push(
        booleanFromJsonable(item).mustValue()
      );
    }
    jsonable["booleans"] = booleansArray;

    return jsonable;
  }
}

const SERIALIZER = new Serializer();

/**
 * Convert `that` to a JSON-able structure.
 *
 * @param that - AAS data to be recursively converted to a JSON-able structure
 * @returns
 * JSON-able structure which can be further processed with, say,
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify|JSON.stringify})
 */
export function toJsonable(that: AasTypes.Class): JsonObject {
  return SERIALIZER.transform(that);
}

// endregion

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
