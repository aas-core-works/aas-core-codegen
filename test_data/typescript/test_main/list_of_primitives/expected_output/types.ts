// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

/**
 * Represent runtime model type of an instance.
 */
export enum ModelType {
  ListOfPrimitives = 0
}

/**
 * Iterate over the literals of {@link ModelType}.
 *
 * @remark
 * TypeScript does not provide an elegant way to iterate over the literals, so
 * this function helps you avoid common errors and pitfalls.
 *
 * @return iterator over the literals
 */
export function *overModelType (
): Iterable<ModelType> {
  // NOTE (mristin, 2022-12-03):
  // We yield numbers instead of literals to avoid name lookups on platforms
  // which do not provide JIT compilation of hot paths.
  yield <ModelType>0;  // ListOfPrimitives
}

/**
 * Represent the most general class of an AAS model.
 */
export abstract class Class {
  /**
   * Indicate the runtime model type of an instance.
   */
  abstract modelType(): ModelType;

  /**
   * Iterate over all the instances referenced from this one.
   */
  abstract descendOnce(): IterableIterator<Class>;

  /**
   * Iterate recursively over all the instances referenced from this one.
   */
  abstract descend(): IterableIterator<Class>;

  /**
   * Dispatch the `visitor` on this instance.
   *
   * @param visitor - to be dispatched
   */
  abstract accept(visitor: AbstractVisitor): void;

  /**
   * Dispatch the `visitor` on this instance with `context`.
   *
   * @param visitor - to be dispatched
   * @param context - of the visitation
   * @typeParam ContextT - type of the visitation context
   */
  abstract acceptWithContext<ContextT>(
    visitor: AbstractVisitorWithContext<ContextT>,
    context: ContextT
  ): void;

  /**
   * Dispatch the `transformer` on this instance.
   *
   * @param transformer - to be dispatched
   * @return this instance transformed
   * @typeParam T - type of the transformation result
   */
  abstract transform<T>(transformer: AbstractTransformer<T>): T;

  /**
   * Dispatch the `transformer` on this instance in `context`.
   *
   * @param transformer - to be dispatched
   * @param context - of the transformation
   * @return this instance transformed
   * @typeParam T - type of the transformation result
   */
  abstract transformWithContext<ContextT, T>(
    transformer: AbstractTransformerWithContext<ContextT, T>,
    context: ContextT
  ): T;
}

export class ListOfPrimitives extends Class {
  /**
   * Indicate the runtime model type of the instance.
   */
  modelType(): ModelType {
    // NOTE (mristin, 2022-12-03):
    // We yield numbers instead of literals to avoid name lookups on platforms
    // which do not provide JIT compilation of hot paths.
    return <ModelType>0;  // ListOfPrimitives
  }

  strings: Array<string>;

  integers: Array<number>;

  booleans: Array<boolean>;

  /**
   * Iterate over the instances referenced from this instance.
   *
   * We do not recurse into the referenced instances.
   *
   * @returns Iterator over the referenced instances
   */
  *descendOnce(): IterableIterator<Class> {
    // No descendable properties
  }

  /**
   * Iterate recursively over the instances referenced from this instance.
   *
   * @returns Iterator over the referenced instances
   */
  *descend(): IterableIterator<Class> {
    // No descendable properties
  }

  /**
   * Dispatch `visitor` on this instance.
   *
   * @param visitor - to visit this instance
   */
  accept(visitor: AbstractVisitor): void {
    visitor.visitListOfPrimitives(this);
  }

  /**
   * Dispatch `visitor` with `context` on this instance.
   *
   * @param visitor - to visit this instance
   * @param context - to be passed along to the dispatched visitor method
   * @typeParam ContextT - type of the context
   */
  acceptWithContext<ContextT>(
    visitor: AbstractVisitorWithContext<ContextT>,
    context: ContextT
  ) {
    visitor.visitListOfPrimitivesWithContext(this, context);
  }

  /**
   * Dispatch the `transformer` on this instance.
   *
   * @param transformer - to transform this instance
   * @returns transformation of this instance
   * @paramType T - type of the transformation result
   */
  transform<T>(transformer: AbstractTransformer<T>): T {
    return transformer.transformListOfPrimitives(this);
  }

  /**
   * Dispatch the `transformer` on this instance in `context`.
   *
   * @param transformer - to transform this instance
   * @param context - to be passed along to the `transformer`
   * @returns transformation of this instance
   * @paramType T - type of the transformation result
   * @paramType ContextT - type of the transformation context
   */
  transformWithContext<ContextT, T>(
    transformer: AbstractTransformerWithContext<ContextT, T>,
    context: ContextT
  ): T {
    return transformer.transformListOfPrimitivesWithContext(
      this, context
    );
  }

  constructor(
    strings: Array<string>,
    integers: Array<number>,
    booleans: Array<boolean>
  ) {
    super();
    this.strings = strings;
    this.integers = integers;
    this.booleans = booleans;
  }
}

/**
 * Visit the instances of the model.
 */
export abstract class AbstractVisitor {
  /**
   * Double-dispatch on `that`.
   */
  visit(that: Class): void {
    that.accept(this);
  }

  /**
   * Visit `that`.
   *
   * @param that - instance to be visited
   */
  abstract visitListOfPrimitives(
    that: ListOfPrimitives
  ): void;
}

/**
 * Visit the instances of the model with context.
 *
 * @typeParam ContextT - type of the visitation context
 */
export abstract class AbstractVisitorWithContext<ContextT> {
  /**
   * Double-dispatch on `that` in `context`.
   *
   * @param that - instance to be visited
   * @param context - of the visitation
   */
  visitWithContext(
    that: Class,
    context: ContextT
  ): void {
    that.acceptWithContext(this, context);
  }

  /**
   * Visit `that` in `context`.
   *
   * @param that - instance to be visited
   * @param context - of the visitation
   */
  abstract visitListOfPrimitivesWithContext(
    that: ListOfPrimitives,
    context: ContextT
  ): void;
}

/**
 * Visit the instances of the model without action.
 *
 * @remarks
 * This visitor is not meant to be directly used. Instead, you usually
 * inherit from it, and implement only the relevant visit methods.
 */
export class PassThroughVisitor extends AbstractVisitor {
  /**
   * Visit `that`.
   *
   * @param that - instance to be visited
   */
  visitListOfPrimitives(
    that: ListOfPrimitives
  ): void {
    for (const another of that.descendOnce()) {
      this.visit(another);
    }
  }
}

/**
 * Visit the instances of the model without action and in context.
 *
 * @remarks
 * This visitor is not meant to be directly used. Instead, you usually
 * inherit from it, and implement only the relevant visit methods.
 */
export class PassThroughVisitorWithContext<ContextT>
    extends AbstractVisitorWithContext<ContextT> {
  /**
   * Double-dispatch on `that` in `context`.
   */
  visitWithContext(
    that: Class,
    context: ContextT
  ): void {
    that.acceptWithContext(this, context);
  }

  /**
   * Visit `that` in `context`.
   *
   * @param that - instance to be visited
   * @param context - of the visitation
   */
  visitListOfPrimitivesWithContext(
    that: ListOfPrimitives,
    context: ContextT
  ): void {
    for (const another of that.descendOnce()) {
      this.visitWithContext(another, context);
    }
  }
}

/**
 * Transform the instance of the model.
 *
 * @typeParam T - type of the transformation result
 */
export abstract class AbstractTransformer<T> {
  /**
   * Double-dispatch on `that`.
   */
  transform(that: Class): T {
    return that.transform(this);
  }

  /**
   * Transform `that`.
   *
   * @param that - instance to be transformed
   * @returns transformed `that`
   */
  abstract transformListOfPrimitives(
    that: ListOfPrimitives
  ): T;
}

/**
 * Transform the instances of the model in context.
 *
 * @typeParam ContextT - type of the transformation context
 * @typeParam T - type of the transformation result
 */
export abstract class AbstractTransformerWithContext<ContextT, T> {
  /**
   * Double-dispatch on `that` in `context`.
   *
   * @param that - instance to be transformed
   * @param context - of the transformation
   * @returns transformed `that`
   */
  transformWithContext(
    that: Class,
    context: ContextT
  ): T {
    return that.transformWithContext(this, context);
  }

  /**
   * Transform `that` in `context`.
   *
   * @param that - instance to be transformed
   * @param context - of the transformation
   * @returns transformed `that`
   */
  abstract transformListOfPrimitivesWithContext(
    that: ListOfPrimitives,
    context: ContextT
  ): T;
}

/**
 * Transform the instances of the model.
 *
 * @remarks
 * If you do not override the transformation methods, they simply
 * return {@link defaultResult}.
 *
 * @typeParam T - type of the transformation result
 */
export class TransformerWithDefault<T> extends AbstractTransformer<T> {
  /**
   * Default value which is returned if no override of the transformation
   */
  defaultResult: T

  /**
   * Initialize with the given `default` value.
   *
   * @param defaultResult - returned if no override of the transformation
   */
  constructor(defaultResult: T) {
    super();
    this.defaultResult = defaultResult;
  }

  /**
   * Transform `that`.
   *
   * @param that - instance to be transformed
   * @returns transformed `that`
   */
  /* eslint-disable @typescript-eslint/no-unused-vars */
  transformListOfPrimitives(
    that: ListOfPrimitives
  ): T {
    return this.defaultResult;
  }
  /* eslint-enable @typescript-eslint/no-unused-vars */
}

/**
 * Transform the instances of the model in context.
 *
 * @remarks
 * If you do not override the transformation methods, they simply
 * return {@link defaultResult}.
 *
 * @typeParam ContextT - type of the visitation context
 * @typeParam T - type of the transformation result
 */
export class TransformerWithDefaultAndContext<ContextT, T>
    extends AbstractTransformerWithContext<ContextT, T> {
  /**
   * Default value which is returned if no override of the transformation
   */
  defaultResult: T

  /**
   * Initialize with the given `default` value.
   *
   * @param defaultResult - returned if no override of the transformation
   */
  constructor(defaultResult: T) {
    super();
    this.defaultResult = defaultResult;
  }

  /**
   * Transform `that` in `context`.
   *
   * @param that - instance to be transformed
   * @param context - of the visitation
   * @returns transformed `that`
   */
  /* eslint-disable @typescript-eslint/no-unused-vars */
  transformListOfPrimitivesWithContext(
    that: ListOfPrimitives,
    context: ContextT
  ): T {
    return this.defaultResult;
  }
  /* eslint-enable @typescript-eslint/no-unused-vars */
}

/**
 * Try to cast `that` instance to
 * the class {@link ListOfPrimitives}.
 *
 * @param that - instance to be casted
 * @returns - casted `that` if cast successful, or `null`
 */
export function asListOfPrimitives(
  that: Class
): ListOfPrimitives | null {
  return (that instanceof ListOfPrimitives)
    ? <ListOfPrimitives>that
    : null;
}

/**
 * Check the type of `that` instance.
 *
 * @param that - instance to be type-checked
 * @returns `true` if the type check is successful
 */
export function isListOfPrimitives(
  that: Class
): that is ListOfPrimitives {
  return that instanceof ListOfPrimitives;
}

class TypeMatcher extends AbstractTransformerWithContext<
  Readonly<Class>,
  boolean
> {
  /* eslint-disable @typescript-eslint/no-unused-vars */
  transformListOfPrimitivesWithContext(
    that: ListOfPrimitives,
    other: Class
  ): boolean {
    return isListOfPrimitives(other);
  }
  /* eslint-enable @typescript-eslint/no-unused-vars */
}

const TYPE_MATCHER = new TypeMatcher();

/**
 * Check whether the type of `that` matches the type of `other` instance.
 *
 * @remarks
 * We check with `is*` function. Hence, if the class of `other` is a subclass of
 * the class of `that`, we confirm the match.
 *
 * @param that - standard instance
 * @param other - instance whose type is compared against `that`
 */
export function typesMatch<ClassT extends Class>(
  that: ClassT,
  other: Class
): other is ClassT {
  return TYPE_MATCHER.transformWithContext(that, other);
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
