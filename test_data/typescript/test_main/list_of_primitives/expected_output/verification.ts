/**
 * Verify that the instances of the meta-model satisfy the invariants.
 *
 * Here is an example how to verify an instance of {@link types.Foo}:
 *
 * ```ts
 * import * as AasTypes from "test/types";
 * import * as AasVerification from "test/verification";
 *
 * const anInstance = new AasTypes.Foo(
 *   // ... some constructor arguments ...
 * );
 *
 * for (const error of AasVerification.verify(anInstance)) {
 *   console.log(`${error.message} at: ${error.path}`);
 * }
 * ```
 */

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import * as AasCommon from "./common";
import * as AasConstants from "./constants";
import * as AasTypes from "./types";

// The generated code might contain deliberately double negations. For example,
// when the constraint is formulated as a NAND and we check that the constraint
// is not fulfilled. Therefore, we disable this linting rule.
/* eslint no-extra-boolean-cast: 0 */

/**
 * Represent a property access on a path to an erroneous value.
 */
export class PropertySegment {
  /**
   * Instance containing the property
   */
  readonly instance: AasTypes.Class;

  /**
   * Name of the property
   */
  readonly name: string;

  constructor(instance: AasTypes.Class, name: string) {
    this.instance = instance;
    this.name = name;
  }

  toString(): string {
    return `.${this.name}`;
  }
}

/**
 * Represent an index access on a path to an erroneous value.
 */
export class IndexSegment {
  /**
   * Sequence containing the item at {@link index}
   */
  readonly sequence: Array<AasTypes.Class>;

  /**
   * Index of the item in the {@link sequence}
   */
  readonly index: number;

  constructor(sequence: Array<AasTypes.Class>, index: number) {
    this.sequence = sequence;
    this.index = index;
  }

  toString(): string {
    return `[${this.index}]`;
  }
}

export type Segment = PropertySegment | IndexSegment;

/**
 * Represent the relative path to the erroneous value.
 */
export class Path {
  readonly segments: Array<Segment> = [];

  prepend(segment: Segment): void {
    this.segments.unshift(segment);
  }

  toString(): string {
    return this.segments.join("");
  }
}

/**
 * Represent a verification error in the data.
 */
export class VerificationError {
  // NOTE (mristin, 2022-11-12):
  // The name `VerificationError` is redundant since it lives in `verification` module,
  // and it would have made more sense to call it simply `Error`. Unfortunately in this case,
  // `Error` is a reserved name by JavaScript.

  /**
   * Human-readable description of the error
   */
  readonly message: string;

  /**
   * Path to the erroneous value
   */
  readonly path: Path = new Path();

  /**
   * Initialize with the given `message` and `path`.
   *
   * @remarks
   * If no `path` is specified, initialize with an empty path.
   */
  constructor(message: string, path: Path | null = null) {
    this.message = message;
    this.path = (path !== null)
      ? path
      : new Path();
  }
}

/**
 * Verify an instance of the model recursively or non-recursively (depending on the context).
 */
class Verifier
  extends AasTypes.AbstractTransformerWithContext<
    boolean, IterableIterator<VerificationError>
  > {
  *transformFooWithContext(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    that: AasTypes.Foo,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    // No verification has been defined for Foo.
  }

  *transformListOfPrimitivesWithContext(
    that: AasTypes.ListOfPrimitives,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (context === true) {
      let stringsIndex = 0;
      for (const item of that.strings) {
        for (const error of this.transformWithContext(item, context)) {
          error.path.prepend(
            new IndexSegment(
              that.strings,
              stringsIndex
            )
          );
          error.path.prepend(
            new PropertySegment(
              that,
              "strings"
            )
          );
          yield error;
        }
        stringsIndex++;
      }

      let integersIndex = 0;
      for (const item of that.integers) {
        for (const error of this.transformWithContext(item, context)) {
          error.path.prepend(
            new IndexSegment(
              that.integers,
              integersIndex
            )
          );
          error.path.prepend(
            new PropertySegment(
              that,
              "integers"
            )
          );
          yield error;
        }
        integersIndex++;
      }

      let booleansIndex = 0;
      for (const item of that.booleans) {
        for (const error of this.transformWithContext(item, context)) {
          error.path.prepend(
            new IndexSegment(
              that.booleans,
              booleansIndex
            )
          );
          error.path.prepend(
            new PropertySegment(
              that,
              "booleans"
            )
          );
          yield error;
        }
        booleansIndex++;
      }
    }
  }
}

const VERIFIER = new Verifier();

/**
 * Verify the constraints of `that`.
 *
 * @param that - instance to be verified
 * @param recurse - if set, continue the verification recursively
 * @returns a stream of verification errors
 */
export function *verify(
  that: AasTypes.Class,
  recurse = true
): IterableIterator<VerificationError> {
  yield * VERIFIER.transformWithContext(that, recurse);
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
