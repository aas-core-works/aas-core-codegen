/**
 * Provide de/serialization of AAS classes to/from JSON.
 *
 * We can not use one-pass deserialization for JSON since the object
 * properties do not have fixed order, and hence we can not read
 * `modelType` property ahead of the remaining properties.
 */

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import * as AasCommon from "./common";
import * as AasTypes from "./types";
import * as AasStringification from "./stringification";

export type JsonValue = string | number | boolean | JsonObject | JsonArray;

export type JsonArray = Iterable<JsonValue>;
export type JsonObject = { [prop: string]: JsonValue };

/**
 * Represent a property on a path to the erroneous value.
 */
export class PropertySegment {
  /**
   * Instance that contains the property
   */
  readonly instance: JsonObject;

  /**
   * Name of the property
   */
  readonly name: string;

  constructor(instance: JsonObject, name: string) {
    this.instance = instance;
    this.name = name;
  }
}

/**
 * Represent an index access on a path to the erroneous value.
 */
export class IndexSegment {
  /**
   * Container that contains the item
   */
  readonly container: JsonArray;

  /**
   * Index of the item
   */
  readonly index: number;

  constructor(container: JsonArray, index: number) {
    if (!Number.isInteger(index)) {
      throw new Error(`Expected an integer for the index, but got: ${index}`);
    }

    this.container = container;
    this.index = index;
  }
}

export type Segment = PropertySegment | IndexSegment;

/**
 * Represent the relative path to the erroneous value.
 */
export class Path {
  private readonly _segments = new Array<Segment>();

  /**
   * Get the segments of the path.
   */
  segments(): Array<Segment> {
    return this._segments;
  }

  /**
   * Insert the `segment` in front of the {@link segments}.
   *
   * @param segment - segment to be prepended to {@link segments}
   */
  prepend(segment: Segment): void {
    this._segments.unshift(segment);
  }

  toString(): string {
    if (this._segments.length === 0) {
      return "";
    }

    const parts = new Array<string>();

    let segment = this._segments[0];

    if (segment instanceof PropertySegment) {
      parts.push(segment.name);
    } else if (segment instanceof IndexSegment) {
      parts.push(`[${segment.index}]`);
    } else {
      throw new Error(`Unexpected segment: ${segment}`);
    }

    for (let i = 1; i < this._segments.length; i++) {
      segment = this._segments[i];
      if (segment instanceof PropertySegment) {
        parts.push(`.${segment.name}`);
      } else if (segment instanceof IndexSegment) {
        parts.push(`[${segment.index}]`);
      } else {
        throw new Error(`Unexpected segment: ${segment}`);
      }
    }

    return parts.join("");
  }
}

// region De-serialization

/**
 * Signal that the JSON de-serialization could not be performed.
 */
export class DeserializationError {
  /**
   * Human-readable explanation of the error
   */
  readonly message: string;

  /**
   * Relative path to the erroneous value
   */
  readonly path: Path;

  constructor(message: string, path: Path | null = null) {
    this.message = message;
    this.path = path ?? new Path();
  }
}

/**
 * Create an error as {@link common.Either}.
 *
 * @param message - human-readable explanation of the error
 * @returns An {@link common.Either } with the error set
 * @typeParam T - type of the value if there had been no error
 */
function newDeserializationError<T>(
  message: string
): AasCommon.Either<T, DeserializationError> {
  return new AasCommon.Either<T, DeserializationError>(
    null,
    new DeserializationError(message)
  );
}

/**
 * Parse `jsonable` as a boolean.
 *
 * @param jsonable - to be parsed
 * @returns parsed boolean value, or an error
 */
function booleanFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<boolean, DeserializationError> {
  // `typeof` seems to be optimized these days, so we use it instead of
  // literal comparison, see:
  // https://stackoverflow.com/questions/61786250/is-typeof-faster-than-literal-comparison

  if (jsonable === null) {
    return newDeserializationError<boolean>(
      "Expected a boolean, but got null"
    );
  }
  if (typeof jsonable !== "boolean") {
    return newDeserializationError<boolean>(
      `Expected a boolean, but got ${typeof jsonable}`
    );
  }

  return new AasCommon.Either<boolean, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as an integer.
 *
 * @param jsonable - to be parsed
 * @returns parsed integer value, or an error
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function integerFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<number, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<number>(
      "Expected an integer number, but got null"
    );
  }
  if (typeof jsonable !== "number") {
    return newDeserializationError<number>(
      `Expected an integer number, but got: ${typeof jsonable}`
    );
  }

  if (!Number.isInteger(jsonable)) {
    return newDeserializationError<number>(
      `Expected an integer number, but got: ${jsonable}`
    );
  }

  return new AasCommon.Either<number, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as a number.
 *
 * @param jsonable - to be parsed
 * @returns parsed numeric value, or an error
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function numberFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<number, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<number>(
      "Expected a number, but got null"
    );
  }
  if (typeof jsonable !== "number") {
    return newDeserializationError<number>(
      `Expected a number, but got: ${typeof jsonable}`
    );
  }

  return new AasCommon.Either<number, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as a string.
 *
 * @param jsonable - to be parsed
 * @returns parsed string value, or an error
 */
function stringFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<string, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<string>(
      "Expected a string, but got null"
    );
  }
  if (typeof jsonable !== "string") {
    return newDeserializationError<string>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  return new AasCommon.Either<string, DeserializationError>(jsonable, null);
}

/**
 * Parse `jsonable` as a byte array.
 *
 * @param jsonable - to be parsed
 * @returns parsed byte array, or an error
 */
function bytesFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<Uint8Array, DeserializationError> {
  if (jsonable === null) {
    return newDeserializationError<Uint8Array>(
      "Expected a base64-encoded string, but got null"
    );
  }
  if (typeof jsonable !== "string") {
    return newDeserializationError<Uint8Array>(
      `Expected a base64-encoded string, but got: ${typeof jsonable}`
    );
  }

  const either = AasCommon.base64Decode(jsonable);
  if (either.error !== null) {
    return newDeserializationError<Uint8Array>(either.error);
  }
  return new AasCommon.Either<Uint8Array, DeserializationError>(
    either.mustValue(), null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasSemantics}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasSemanticsFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IHasSemantics,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IHasSemantics>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IHasSemantics>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IHasSemantics>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IHasSemantics>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IHasSemantics>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = HAS_SEMANTICS_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IHasSemantics>(
      `Unexpected model type for IHasSemantics: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Extension}.
 */
class SetterForExtension {
  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  name: string | null = null;

  valueType: AasTypes.DataTypeDefXsd | null = null;

  value: string | null = null;

  refersTo: Array<AasTypes.Reference> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link name}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.name = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataTypeDefXsdFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link refersTo}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setRefersToFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.refersTo = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Extension} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Extension},
 * or an error if any
 */
export function extensionFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Extension,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Extension>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Extension>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Extension>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForExtension();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_EXTENSION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Extension,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.name === null) {
    return newDeserializationError<
      AasTypes.Extension
    >(
      "The required property 'name' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Extension,
    DeserializationError
  >(
    new AasTypes.Extension(
      setter.name,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.valueType,
      setter.value,
      setter.refersTo
    ),
    null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasExtensions}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasExtensionsFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IHasExtensions,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IHasExtensions>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IHasExtensions>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IHasExtensions>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IHasExtensions>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IHasExtensions>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IHasExtensions>(
      `Unexpected model type for IHasExtensions: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IReferable}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function referableFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IReferable,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IReferable>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IReferable>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IReferable>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IReferable>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IReferable>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = REFERABLE_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IReferable>(
      `Unexpected model type for IReferable: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IIdentifiable}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function identifiableFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IIdentifiable,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IIdentifiable>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IIdentifiable>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IIdentifiable>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IIdentifiable>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IIdentifiable>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = IDENTIFIABLE_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IIdentifiable>(
      `Unexpected model type for IIdentifiable: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!ModellingKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function modellingKindFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.ModellingKind, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.ModellingKind>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.modellingKindFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.ModellingKind>(
      "Not a valid string representation of " +
        `a literal of ModellingKind: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.ModellingKind,
    DeserializationError
  >(literal, null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasKindFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IHasKind,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IHasKind>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IHasKind>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IHasKind>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IHasKind>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IHasKind>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = HAS_KIND_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IHasKind>(
      `Unexpected model type for IHasKind: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IHasDataSpecification}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function hasDataSpecificationFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IHasDataSpecification,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IHasDataSpecification>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IHasDataSpecification>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IHasDataSpecification>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IHasDataSpecification>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IHasDataSpecification>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IHasDataSpecification>(
      `Unexpected model type for IHasDataSpecification: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AdministrativeInformation}.
 */
class SetterForAdministrativeInformation {
  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  version: string | null = null;

  revision: string | null = null;

  creator: AasTypes.Reference | null = null;

  templateId: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link version}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setVersionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.version = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link revision}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setRevisionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.revision = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link creator}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCreatorFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.creator = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link templateId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTemplateIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.templateId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!AdministrativeInformation} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AdministrativeInformation},
 * or an error if any
 */
export function administrativeInformationFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.AdministrativeInformation,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.AdministrativeInformation>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.AdministrativeInformation>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.AdministrativeInformation>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForAdministrativeInformation();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.AdministrativeInformation,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.AdministrativeInformation,
    DeserializationError
  >(
    new AasTypes.AdministrativeInformation(
      setter.embeddedDataSpecifications,
      setter.version,
      setter.revision,
      setter.creator,
      setter.templateId
    ),
    null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IQualifiable}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function qualifiableFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IQualifiable,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IQualifiable>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IQualifiable>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IQualifiable>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IQualifiable>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IQualifiable>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = QUALIFIABLE_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IQualifiable>(
      `Unexpected model type for IQualifiable: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!QualifierKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function qualifierKindFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.QualifierKind, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.QualifierKind>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.qualifierKindFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.QualifierKind>(
      "Not a valid string representation of " +
        `a literal of QualifierKind: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.QualifierKind,
    DeserializationError
  >(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Qualifier}.
 */
class SetterForQualifier {
  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  kind: AasTypes.QualifierKind | null = null;

  type: string | null = null;

  valueType: AasTypes.DataTypeDefXsd | null = null;

  value: string | null = null;

  valueId: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link kind}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setKindFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = qualifierKindFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.kind = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link type}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.type = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataTypeDefXsdFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Qualifier} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Qualifier},
 * or an error if any
 */
export function qualifierFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Qualifier,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Qualifier>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Qualifier>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Qualifier>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForQualifier();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_QUALIFIER.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Qualifier,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.type === null) {
    return newDeserializationError<
      AasTypes.Qualifier
    >(
      "The required property 'type' is missing"
    );
  }

  if (setter.valueType === null) {
    return newDeserializationError<
      AasTypes.Qualifier
    >(
      "The required property 'valueType' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Qualifier,
    DeserializationError
  >(
    new AasTypes.Qualifier(
      setter.type,
      setter.valueType,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.kind,
      setter.value,
      setter.valueId
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AssetAdministrationShell}.
 */
class SetterForAssetAdministrationShell {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  administration: AasTypes.AdministrativeInformation | null = null;

  id: string | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  derivedFrom: AasTypes.Reference | null = null;

  assetInformation: AasTypes.AssetInformation | null = null;

  submodels: Array<AasTypes.Reference> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link administration}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAdministrationFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = administrativeInformationFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.administration = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link id}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.id = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link derivedFrom}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDerivedFromFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.derivedFrom = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link assetInformation}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetInformationFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = assetInformationFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.assetInformation = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link submodels}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubmodelsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.submodels = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!AssetAdministrationShell} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AssetAdministrationShell},
 * or an error if any
 */
export function assetAdministrationShellFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.AssetAdministrationShell,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.AssetAdministrationShell>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.AssetAdministrationShell>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.AssetAdministrationShell>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForAssetAdministrationShell();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.AssetAdministrationShell,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.id === null) {
    return newDeserializationError<
      AasTypes.AssetAdministrationShell
    >(
      "The required property 'id' is missing"
    );
  }

  if (setter.assetInformation === null) {
    return newDeserializationError<
      AasTypes.AssetAdministrationShell
    >(
      "The required property 'assetInformation' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.AssetAdministrationShell,
    DeserializationError
  >(
    new AasTypes.AssetAdministrationShell(
      setter.id,
      setter.assetInformation,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.administration,
      setter.embeddedDataSpecifications,
      setter.derivedFrom,
      setter.submodels
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AssetInformation}.
 */
class SetterForAssetInformation {
  assetKind: AasTypes.AssetKind | null = null;

  globalAssetId: string | null = null;

  specificAssetIds: Array<AasTypes.SpecificAssetId> | null = null;

  assetType: string | null = null;

  defaultThumbnail: AasTypes.Resource | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link assetKind}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetKindFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = assetKindFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.assetKind = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link globalAssetId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setGlobalAssetIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.globalAssetId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link specificAssetIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSpecificAssetIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.SpecificAssetId>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = specificAssetIdFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.specificAssetIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link assetType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.assetType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link defaultThumbnail}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDefaultThumbnailFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = resourceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.defaultThumbnail = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!AssetInformation} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AssetInformation},
 * or an error if any
 */
export function assetInformationFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.AssetInformation,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.AssetInformation>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.AssetInformation>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.AssetInformation>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForAssetInformation();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_ASSET_INFORMATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.AssetInformation,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.assetKind === null) {
    return newDeserializationError<
      AasTypes.AssetInformation
    >(
      "The required property 'assetKind' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.AssetInformation,
    DeserializationError
  >(
    new AasTypes.AssetInformation(
      setter.assetKind,
      setter.globalAssetId,
      setter.specificAssetIds,
      setter.assetType,
      setter.defaultThumbnail
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Resource}.
 */
class SetterForResource {
  path: string | null = null;

  contentType: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link path}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setPathFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.path = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link contentType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setContentTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.contentType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Resource} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Resource},
 * or an error if any
 */
export function resourceFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Resource,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Resource>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Resource>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Resource>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForResource();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_RESOURCE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Resource,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.path === null) {
    return newDeserializationError<
      AasTypes.Resource
    >(
      "The required property 'path' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Resource,
    DeserializationError
  >(
    new AasTypes.Resource(
      setter.path,
      setter.contentType
    ),
    null
  );
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!AssetKind}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function assetKindFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.AssetKind, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.AssetKind>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.assetKindFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.AssetKind>(
      "Not a valid string representation of " +
        `a literal of AssetKind: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.AssetKind,
    DeserializationError
  >(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!SpecificAssetId}.
 */
class SetterForSpecificAssetId {
  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  name: string | null = null;

  value: string | null = null;

  externalSubjectId: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link name}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.name = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link externalSubjectId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExternalSubjectIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.externalSubjectId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!SpecificAssetId} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!SpecificAssetId},
 * or an error if any
 */
export function specificAssetIdFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.SpecificAssetId,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.SpecificAssetId>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.SpecificAssetId>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.SpecificAssetId>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForSpecificAssetId();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_SPECIFIC_ASSET_ID.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.SpecificAssetId,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.name === null) {
    return newDeserializationError<
      AasTypes.SpecificAssetId
    >(
      "The required property 'name' is missing"
    );
  }

  if (setter.value === null) {
    return newDeserializationError<
      AasTypes.SpecificAssetId
    >(
      "The required property 'value' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.SpecificAssetId,
    DeserializationError
  >(
    new AasTypes.SpecificAssetId(
      setter.name,
      setter.value,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.externalSubjectId
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Submodel}.
 */
class SetterForSubmodel {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  administration: AasTypes.AdministrativeInformation | null = null;

  id: string | null = null;

  kind: AasTypes.ModellingKind | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  submodelElements: Array<AasTypes.ISubmodelElement> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link administration}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAdministrationFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = administrativeInformationFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.administration = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link id}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.id = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link kind}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setKindFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = modellingKindFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.kind = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link submodelElements}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubmodelElementsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.ISubmodelElement>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.submodelElements = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Submodel} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Submodel},
 * or an error if any
 */
export function submodelFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Submodel,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Submodel>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Submodel>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Submodel>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForSubmodel();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_SUBMODEL.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Submodel,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.id === null) {
    return newDeserializationError<
      AasTypes.Submodel
    >(
      "The required property 'id' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Submodel,
    DeserializationError
  >(
    new AasTypes.Submodel(
      setter.id,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.administration,
      setter.kind,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.submodelElements
    ),
    null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!ISubmodelElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function submodelElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.ISubmodelElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.ISubmodelElement>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.ISubmodelElement>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.ISubmodelElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.ISubmodelElement>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.ISubmodelElement>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.ISubmodelElement>(
      `Unexpected model type for ISubmodelElement: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IRelationshipElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function relationshipElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IRelationshipElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IRelationshipElement>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IRelationshipElement>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IRelationshipElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IRelationshipElement>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IRelationshipElement>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IRelationshipElement>(
      `Unexpected model type for IRelationshipElement: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!RelationshipElement}.
 */
class SetterForRelationshipElement {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  first: AasTypes.Reference | null = null;

  second: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link first}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setFirstFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.first = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link second}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSecondFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.second = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!RelationshipElement} from the JSON-able
 * structure `jsonable`.
 *
 * This function performs no dispatch! It is used to parse the properties
 * as-are, and already assumes the exact model type. Usually, this function
 * is called from within a dispatching function, and you never call it
 * directly. If you want to de-serialize an instance of
 * {@link types!RelationshipElement}, call
 * {@link relationshipElementFromJsonable}.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!RelationshipElement},
 * or an error if any
 */
function relationshipElementFromJsonableWithoutDispatch(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.RelationshipElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.RelationshipElement>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.RelationshipElement>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.RelationshipElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForRelationshipElement();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_RELATIONSHIP_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.RelationshipElement,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.first === null) {
    return newDeserializationError<
      AasTypes.RelationshipElement
    >(
      "The required property 'first' is missing"
    );
  }

  if (setter.second === null) {
    return newDeserializationError<
      AasTypes.RelationshipElement
    >(
      "The required property 'second' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.RelationshipElement,
    DeserializationError
  >(
    new AasTypes.RelationshipElement(
      setter.first,
      setter.second,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications
    ),
    null
  );
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!AasSubmodelElements}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function aasSubmodelElementsFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.AasSubmodelElements, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.AasSubmodelElements>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.aasSubmodelElementsFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.AasSubmodelElements>(
      "Not a valid string representation of " +
        `a literal of AasSubmodelElements: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.AasSubmodelElements,
    DeserializationError
  >(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!SubmodelElementList}.
 */
class SetterForSubmodelElementList {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  orderRelevant: boolean | null = null;

  semanticIdListElement: AasTypes.Reference | null = null;

  typeValueListElement: AasTypes.AasSubmodelElements | null = null;

  valueTypeListElement: AasTypes.DataTypeDefXsd | null = null;

  value: Array<AasTypes.ISubmodelElement> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link orderRelevant}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setOrderRelevantFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = booleanFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.orderRelevant = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link semanticIdListElement}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdListElementFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticIdListElement = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link typeValueListElement}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeValueListElementFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = aasSubmodelElementsFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.typeValueListElement = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueTypeListElement}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeListElementFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataTypeDefXsdFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueTypeListElement = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.ISubmodelElement>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.value = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!SubmodelElementList} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!SubmodelElementList},
 * or an error if any
 */
export function submodelElementListFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.SubmodelElementList,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.SubmodelElementList>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.SubmodelElementList>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.SubmodelElementList>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForSubmodelElementList();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.SubmodelElementList,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.typeValueListElement === null) {
    return newDeserializationError<
      AasTypes.SubmodelElementList
    >(
      "The required property 'typeValueListElement' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.SubmodelElementList,
    DeserializationError
  >(
    new AasTypes.SubmodelElementList(
      setter.typeValueListElement,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.orderRelevant,
      setter.semanticIdListElement,
      setter.valueTypeListElement,
      setter.value
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!SubmodelElementCollection}.
 */
class SetterForSubmodelElementCollection {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  value: Array<AasTypes.ISubmodelElement> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.ISubmodelElement>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.value = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!SubmodelElementCollection} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!SubmodelElementCollection},
 * or an error if any
 */
export function submodelElementCollectionFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.SubmodelElementCollection,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.SubmodelElementCollection>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.SubmodelElementCollection>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.SubmodelElementCollection>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForSubmodelElementCollection();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.SubmodelElementCollection,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.SubmodelElementCollection,
    DeserializationError
  >(
    new AasTypes.SubmodelElementCollection(
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.value
    ),
    null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IDataElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function dataElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IDataElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IDataElement>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IDataElement>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IDataElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IDataElement>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IDataElement>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = DATA_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IDataElement>(
      `Unexpected model type for IDataElement: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Property}.
 */
class SetterForProperty {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  valueType: AasTypes.DataTypeDefXsd | null = null;

  value: string | null = null;

  valueId: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataTypeDefXsdFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Property} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Property},
 * or an error if any
 */
export function propertyFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Property,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Property>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Property>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Property>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForProperty();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_PROPERTY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Property,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.valueType === null) {
    return newDeserializationError<
      AasTypes.Property
    >(
      "The required property 'valueType' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Property,
    DeserializationError
  >(
    new AasTypes.Property(
      setter.valueType,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.value,
      setter.valueId
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!MultiLanguageProperty}.
 */
class SetterForMultiLanguageProperty {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  value: Array<AasTypes.LangStringTextType> | null = null;

  valueId: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.value = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!MultiLanguageProperty} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!MultiLanguageProperty},
 * or an error if any
 */
export function multiLanguagePropertyFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.MultiLanguageProperty,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.MultiLanguageProperty>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.MultiLanguageProperty>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.MultiLanguageProperty>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForMultiLanguageProperty();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.MultiLanguageProperty,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.MultiLanguageProperty,
    DeserializationError
  >(
    new AasTypes.MultiLanguageProperty(
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.value,
      setter.valueId
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Range}.
 */
class SetterForRange {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  valueType: AasTypes.DataTypeDefXsd | null = null;

  min: string | null = null;

  max: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataTypeDefXsdFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link min}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMinFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.min = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link max}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMaxFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.max = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Range} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Range},
 * or an error if any
 */
export function rangeFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Range,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Range>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Range>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Range>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForRange();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_RANGE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Range,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.valueType === null) {
    return newDeserializationError<
      AasTypes.Range
    >(
      "The required property 'valueType' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Range,
    DeserializationError
  >(
    new AasTypes.Range(
      setter.valueType,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.min,
      setter.max
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ReferenceElement}.
 */
class SetterForReferenceElement {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  value: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!ReferenceElement} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ReferenceElement},
 * or an error if any
 */
export function referenceElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.ReferenceElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.ReferenceElement>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.ReferenceElement>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.ReferenceElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForReferenceElement();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_REFERENCE_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.ReferenceElement,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.ReferenceElement,
    DeserializationError
  >(
    new AasTypes.ReferenceElement(
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.value
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Blob}.
 */
class SetterForBlob {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  value: Uint8Array | null = null;

  contentType: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = bytesFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link contentType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setContentTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.contentType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Blob} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Blob},
 * or an error if any
 */
export function blobFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Blob,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Blob>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Blob>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Blob>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForBlob();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_BLOB.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Blob,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.contentType === null) {
    return newDeserializationError<
      AasTypes.Blob
    >(
      "The required property 'contentType' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Blob,
    DeserializationError
  >(
    new AasTypes.Blob(
      setter.contentType,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.value
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!File}.
 */
class SetterForFile {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  value: string | null = null;

  contentType: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link contentType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setContentTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.contentType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!File} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!File},
 * or an error if any
 */
export function fileFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.File,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.File>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.File>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.File>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForFile();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_FILE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.File,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.contentType === null) {
    return newDeserializationError<
      AasTypes.File
    >(
      "The required property 'contentType' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.File,
    DeserializationError
  >(
    new AasTypes.File(
      setter.contentType,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.value
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!AnnotatedRelationshipElement}.
 */
class SetterForAnnotatedRelationshipElement {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  first: AasTypes.Reference | null = null;

  second: AasTypes.Reference | null = null;

  annotations: Array<AasTypes.IDataElement> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link first}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setFirstFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.first = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link second}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSecondFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.second = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link annotations}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAnnotationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.IDataElement>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = dataElementFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.annotations = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!AnnotatedRelationshipElement} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!AnnotatedRelationshipElement},
 * or an error if any
 */
export function annotatedRelationshipElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.AnnotatedRelationshipElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.AnnotatedRelationshipElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForAnnotatedRelationshipElement();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.AnnotatedRelationshipElement,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.first === null) {
    return newDeserializationError<
      AasTypes.AnnotatedRelationshipElement
    >(
      "The required property 'first' is missing"
    );
  }

  if (setter.second === null) {
    return newDeserializationError<
      AasTypes.AnnotatedRelationshipElement
    >(
      "The required property 'second' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.AnnotatedRelationshipElement,
    DeserializationError
  >(
    new AasTypes.AnnotatedRelationshipElement(
      setter.first,
      setter.second,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.annotations
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Entity}.
 */
class SetterForEntity {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  statements: Array<AasTypes.ISubmodelElement> | null = null;

  entityType: AasTypes.EntityType | null = null;

  globalAssetId: string | null = null;

  specificAssetIds: Array<AasTypes.SpecificAssetId> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link statements}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setStatementsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.ISubmodelElement>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelElementFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.statements = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link entityType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEntityTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = entityTypeFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.entityType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link globalAssetId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setGlobalAssetIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.globalAssetId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link specificAssetIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSpecificAssetIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.SpecificAssetId>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = specificAssetIdFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.specificAssetIds = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Entity} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Entity},
 * or an error if any
 */
export function entityFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Entity,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Entity>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Entity>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Entity>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForEntity();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_ENTITY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Entity,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.entityType === null) {
    return newDeserializationError<
      AasTypes.Entity
    >(
      "The required property 'entityType' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Entity,
    DeserializationError
  >(
    new AasTypes.Entity(
      setter.entityType,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.statements,
      setter.globalAssetId,
      setter.specificAssetIds
    ),
    null
  );
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!EntityType}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function entityTypeFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.EntityType, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.EntityType>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.entityTypeFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.EntityType>(
      "Not a valid string representation of " +
        `a literal of EntityType: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.EntityType,
    DeserializationError
  >(literal, null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!Direction}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function directionFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.Direction, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.Direction>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.directionFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.Direction>(
      "Not a valid string representation of " +
        `a literal of Direction: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.Direction,
    DeserializationError
  >(literal, null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!StateOfEvent}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function stateOfEventFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.StateOfEvent, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.StateOfEvent>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.stateOfEventFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.StateOfEvent>(
      "Not a valid string representation of " +
        `a literal of StateOfEvent: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.StateOfEvent,
    DeserializationError
  >(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!EventPayload}.
 */
class SetterForEventPayload {
  source: AasTypes.Reference | null = null;

  sourceSemanticId: AasTypes.Reference | null = null;

  observableReference: AasTypes.Reference | null = null;

  observableSemanticId: AasTypes.Reference | null = null;

  topic: string | null = null;

  subjectId: AasTypes.Reference | null = null;

  timeStamp: string | null = null;

  payload: Uint8Array | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link source}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSourceFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.source = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link sourceSemanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSourceSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.sourceSemanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link observableReference}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setObservableReferenceFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.observableReference = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link observableSemanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setObservableSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.observableSemanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link topic}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTopicFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.topic = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link subjectId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubjectIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.subjectId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link timeStamp}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTimeStampFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.timeStamp = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link payload}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setPayloadFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = bytesFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.payload = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!EventPayload} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!EventPayload},
 * or an error if any
 */
export function eventPayloadFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.EventPayload,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.EventPayload>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.EventPayload>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.EventPayload>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForEventPayload();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_EVENT_PAYLOAD.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.EventPayload,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.source === null) {
    return newDeserializationError<
      AasTypes.EventPayload
    >(
      "The required property 'source' is missing"
    );
  }

  if (setter.observableReference === null) {
    return newDeserializationError<
      AasTypes.EventPayload
    >(
      "The required property 'observableReference' is missing"
    );
  }

  if (setter.timeStamp === null) {
    return newDeserializationError<
      AasTypes.EventPayload
    >(
      "The required property 'timeStamp' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.EventPayload,
    DeserializationError
  >(
    new AasTypes.EventPayload(
      setter.source,
      setter.observableReference,
      setter.timeStamp,
      setter.sourceSemanticId,
      setter.observableSemanticId,
      setter.topic,
      setter.subjectId,
      setter.payload
    ),
    null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IEventElement}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function eventElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IEventElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IEventElement>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IEventElement>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IEventElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IEventElement>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IEventElement>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = EVENT_ELEMENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IEventElement>(
      `Unexpected model type for IEventElement: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!BasicEventElement}.
 */
class SetterForBasicEventElement {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  observed: AasTypes.Reference | null = null;

  direction: AasTypes.Direction | null = null;

  state: AasTypes.StateOfEvent | null = null;

  messageTopic: string | null = null;

  messageBroker: AasTypes.Reference | null = null;

  lastUpdate: string | null = null;

  minInterval: string | null = null;

  maxInterval: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link observed}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setObservedFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.observed = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link direction}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDirectionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = directionFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.direction = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link state}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setStateFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stateOfEventFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.state = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link messageTopic}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMessageTopicFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.messageTopic = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link messageBroker}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMessageBrokerFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.messageBroker = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link lastUpdate}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLastUpdateFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.lastUpdate = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link minInterval}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMinIntervalFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.minInterval = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link maxInterval}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMaxIntervalFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.maxInterval = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!BasicEventElement} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!BasicEventElement},
 * or an error if any
 */
export function basicEventElementFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.BasicEventElement,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.BasicEventElement>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.BasicEventElement>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.BasicEventElement>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForBasicEventElement();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_BASIC_EVENT_ELEMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.BasicEventElement,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.observed === null) {
    return newDeserializationError<
      AasTypes.BasicEventElement
    >(
      "The required property 'observed' is missing"
    );
  }

  if (setter.direction === null) {
    return newDeserializationError<
      AasTypes.BasicEventElement
    >(
      "The required property 'direction' is missing"
    );
  }

  if (setter.state === null) {
    return newDeserializationError<
      AasTypes.BasicEventElement
    >(
      "The required property 'state' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.BasicEventElement,
    DeserializationError
  >(
    new AasTypes.BasicEventElement(
      setter.observed,
      setter.direction,
      setter.state,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.messageTopic,
      setter.messageBroker,
      setter.lastUpdate,
      setter.minInterval,
      setter.maxInterval
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Operation}.
 */
class SetterForOperation {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  inputVariables: Array<AasTypes.OperationVariable> | null = null;

  outputVariables: Array<AasTypes.OperationVariable> | null = null;

  inoutputVariables: Array<AasTypes.OperationVariable> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link inputVariables}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setInputVariablesFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.OperationVariable>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = operationVariableFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.inputVariables = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link outputVariables}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setOutputVariablesFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.OperationVariable>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = operationVariableFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.outputVariables = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link inoutputVariables}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setInoutputVariablesFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.OperationVariable>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = operationVariableFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.inoutputVariables = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Operation} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Operation},
 * or an error if any
 */
export function operationFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Operation,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Operation>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Operation>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Operation>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForOperation();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_OPERATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Operation,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.Operation,
    DeserializationError
  >(
    new AasTypes.Operation(
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications,
      setter.inputVariables,
      setter.outputVariables,
      setter.inoutputVariables
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!OperationVariable}.
 */
class SetterForOperationVariable {
  value: AasTypes.ISubmodelElement | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = submodelElementFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!OperationVariable} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!OperationVariable},
 * or an error if any
 */
export function operationVariableFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.OperationVariable,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.OperationVariable>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.OperationVariable>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.OperationVariable>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForOperationVariable();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_OPERATION_VARIABLE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.OperationVariable,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.value === null) {
    return newDeserializationError<
      AasTypes.OperationVariable
    >(
      "The required property 'value' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.OperationVariable,
    DeserializationError
  >(
    new AasTypes.OperationVariable(
      setter.value
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Capability}.
 */
class SetterForCapability {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  semanticId: AasTypes.Reference | null = null;

  supplementalSemanticIds: Array<AasTypes.Reference> | null = null;

  qualifiers: Array<AasTypes.Qualifier> | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link semanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.semanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link supplementalSemanticIds}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSupplementalSemanticIdsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.supplementalSemanticIds = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link qualifiers}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setQualifiersFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Qualifier>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = qualifierFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.qualifiers = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Capability} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Capability},
 * or an error if any
 */
export function capabilityFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Capability,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Capability>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Capability>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Capability>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForCapability();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_CAPABILITY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Capability,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.Capability,
    DeserializationError
  >(
    new AasTypes.Capability(
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.semanticId,
      setter.supplementalSemanticIds,
      setter.qualifiers,
      setter.embeddedDataSpecifications
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ConceptDescription}.
 */
class SetterForConceptDescription {
  extensions: Array<AasTypes.Extension> | null = null;

  category: string | null = null;

  idShort: string | null = null;

  displayName: Array<AasTypes.LangStringNameType> | null = null;

  description: Array<AasTypes.LangStringTextType> | null = null;

  administration: AasTypes.AdministrativeInformation | null = null;

  id: string | null = null;

  embeddedDataSpecifications: Array<AasTypes.EmbeddedDataSpecification> | null = null;

  isCaseOf: Array<AasTypes.Reference> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link extensions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setExtensionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Extension>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = extensionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.extensions = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link category}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setCategoryFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.category = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link idShort}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdShortFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.idShort = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link displayName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDisplayNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringNameType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringNameTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.displayName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link description}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDescriptionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringTextType>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringTextTypeFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.description = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link administration}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAdministrationFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = administrativeInformationFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.administration = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link id}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.id = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link embeddedDataSpecifications}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setEmbeddedDataSpecificationsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.EmbeddedDataSpecification>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = embeddedDataSpecificationFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.embeddedDataSpecifications = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link isCaseOf}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setIsCaseOfFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Reference>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = referenceFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.isCaseOf = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!ConceptDescription} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ConceptDescription},
 * or an error if any
 */
export function conceptDescriptionFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.ConceptDescription,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.ConceptDescription>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.ConceptDescription>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.ConceptDescription>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForConceptDescription();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_CONCEPT_DESCRIPTION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.ConceptDescription,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.id === null) {
    return newDeserializationError<
      AasTypes.ConceptDescription
    >(
      "The required property 'id' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.ConceptDescription,
    DeserializationError
  >(
    new AasTypes.ConceptDescription(
      setter.id,
      setter.extensions,
      setter.category,
      setter.idShort,
      setter.displayName,
      setter.description,
      setter.administration,
      setter.embeddedDataSpecifications,
      setter.isCaseOf
    ),
    null
  );
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!ReferenceTypes}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function referenceTypesFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.ReferenceTypes, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.ReferenceTypes>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.referenceTypesFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.ReferenceTypes>(
      "Not a valid string representation of " +
        `a literal of ReferenceTypes: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.ReferenceTypes,
    DeserializationError
  >(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Reference}.
 */
class SetterForReference {
  type: AasTypes.ReferenceTypes | null = null;

  referredSemanticId: AasTypes.Reference | null = null;

  keys: Array<AasTypes.Key> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link type}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceTypesFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.type = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link referredSemanticId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setReferredSemanticIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.referredSemanticId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link keys}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setKeysFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Key>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = keyFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.keys = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Reference} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Reference},
 * or an error if any
 */
export function referenceFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Reference,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Reference>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Reference>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Reference>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForReference();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_REFERENCE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Reference,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.type === null) {
    return newDeserializationError<
      AasTypes.Reference
    >(
      "The required property 'type' is missing"
    );
  }

  if (setter.keys === null) {
    return newDeserializationError<
      AasTypes.Reference
    >(
      "The required property 'keys' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Reference,
    DeserializationError
  >(
    new AasTypes.Reference(
      setter.type,
      setter.keys,
      setter.referredSemanticId
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Key}.
 */
class SetterForKey {
  type: AasTypes.KeyTypes | null = null;

  value: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link type}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = keyTypesFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.type = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!Key} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Key},
 * or an error if any
 */
export function keyFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Key,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Key>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Key>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Key>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForKey();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_KEY.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Key,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.type === null) {
    return newDeserializationError<
      AasTypes.Key
    >(
      "The required property 'type' is missing"
    );
  }

  if (setter.value === null) {
    return newDeserializationError<
      AasTypes.Key
    >(
      "The required property 'value' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.Key,
    DeserializationError
  >(
    new AasTypes.Key(
      setter.type,
      setter.value
    ),
    null
  );
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!KeyTypes}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function keyTypesFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.KeyTypes, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.KeyTypes>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.keyTypesFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.KeyTypes>(
      "Not a valid string representation of " +
        `a literal of KeyTypes: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.KeyTypes,
    DeserializationError
  >(literal, null);
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!DataTypeDefXsd}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function dataTypeDefXsdFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.DataTypeDefXsd, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.DataTypeDefXsd>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.dataTypeDefXsdFromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.DataTypeDefXsd>(
      "Not a valid string representation of " +
        `a literal of DataTypeDefXsd: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.DataTypeDefXsd,
    DeserializationError
  >(literal, null);
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IAbstractLangString}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function abstractLangStringFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IAbstractLangString,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IAbstractLangString>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IAbstractLangString>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IAbstractLangString>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IAbstractLangString>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IAbstractLangString>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IAbstractLangString>(
      `Unexpected model type for IAbstractLangString: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringNameType}.
 */
class SetterForLangStringNameType {
  language: string | null = null;

  text: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringNameType} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringNameType},
 * or an error if any
 */
export function langStringNameTypeFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.LangStringNameType,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.LangStringNameType>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.LangStringNameType>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.LangStringNameType>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForLangStringNameType();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LANG_STRING_NAME_TYPE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.LangStringNameType,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.language === null) {
    return newDeserializationError<
      AasTypes.LangStringNameType
    >(
      "The required property 'language' is missing"
    );
  }

  if (setter.text === null) {
    return newDeserializationError<
      AasTypes.LangStringNameType
    >(
      "The required property 'text' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.LangStringNameType,
    DeserializationError
  >(
    new AasTypes.LangStringNameType(
      setter.language,
      setter.text
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringTextType}.
 */
class SetterForLangStringTextType {
  language: string | null = null;

  text: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringTextType} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringTextType},
 * or an error if any
 */
export function langStringTextTypeFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.LangStringTextType,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.LangStringTextType>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.LangStringTextType>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.LangStringTextType>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForLangStringTextType();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.LangStringTextType,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.language === null) {
    return newDeserializationError<
      AasTypes.LangStringTextType
    >(
      "The required property 'language' is missing"
    );
  }

  if (setter.text === null) {
    return newDeserializationError<
      AasTypes.LangStringTextType
    >(
      "The required property 'text' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.LangStringTextType,
    DeserializationError
  >(
    new AasTypes.LangStringTextType(
      setter.language,
      setter.text
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!Environment}.
 */
class SetterForEnvironment {
  assetAdministrationShells: Array<AasTypes.AssetAdministrationShell> | null = null;

  submodels: Array<AasTypes.Submodel> | null = null;

  conceptDescriptions: Array<AasTypes.ConceptDescription> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link assetAdministrationShells}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setAssetAdministrationShellsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.AssetAdministrationShell>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = assetAdministrationShellFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.assetAdministrationShells = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link submodels}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSubmodelsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.Submodel>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = submodelFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.submodels = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link conceptDescriptions}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setConceptDescriptionsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.ConceptDescription>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = conceptDescriptionFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.conceptDescriptions = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!Environment} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!Environment},
 * or an error if any
 */
export function environmentFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.Environment,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.Environment>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.Environment>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.Environment>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForEnvironment();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_ENVIRONMENT.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.Environment,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  return new AasCommon.Either<
    AasTypes.Environment,
    DeserializationError
  >(
    new AasTypes.Environment(
      setter.assetAdministrationShells,
      setter.submodels,
      setter.conceptDescriptions
    ),
    null
  );
}

/**
 * Parse `jsonable` as an instance
 * of {@link types!IDataSpecificationContent}.
 *
 * @param jsonable - to be parsed
 * @returns parsed instance, or error if `jsonable` is invalid
 */
export function dataSpecificationContentFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.IDataSpecificationContent,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.IDataSpecificationContent>(
      "Expected a JSON object, but got null"
    );
  }
  if (Array.isArray(jsonable)) {
    return newDeserializationError<AasTypes.IDataSpecificationContent>(
      "Expected a JSON object, but got a JSON array"
    );
  }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.IDataSpecificationContent>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const modelType = jsonable["modelType"];
  if (modelType === undefined) {
    return newDeserializationError<AasTypes.IDataSpecificationContent>(
      "Expected the property modelType, but got none"
    );
  }

  if (typeof modelType !== "string") {
    return newDeserializationError<AasTypes.IDataSpecificationContent>(
      `Expected the property modelType to be a string, but got: ${typeof modelType}`
    );
  }

  const dispatch = DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH.get(modelType);
  if (dispatch === undefined) {
    return newDeserializationError<AasTypes.IDataSpecificationContent>(
      `Unexpected model type for IDataSpecificationContent: ${modelType}`
    );
  }

  return dispatch(jsonable);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!EmbeddedDataSpecification}.
 */
class SetterForEmbeddedDataSpecification {
  dataSpecificationContent: AasTypes.IDataSpecificationContent | null = null;

  dataSpecification: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link dataSpecificationContent}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDataSpecificationContentFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataSpecificationContentFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.dataSpecificationContent = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link dataSpecification}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDataSpecificationFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.dataSpecification = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!EmbeddedDataSpecification} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!EmbeddedDataSpecification},
 * or an error if any
 */
export function embeddedDataSpecificationFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.EmbeddedDataSpecification,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.EmbeddedDataSpecification>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.EmbeddedDataSpecification>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForEmbeddedDataSpecification();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.EmbeddedDataSpecification,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.dataSpecificationContent === null) {
    return newDeserializationError<
      AasTypes.EmbeddedDataSpecification
    >(
      "The required property 'dataSpecificationContent' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.EmbeddedDataSpecification,
    DeserializationError
  >(
    new AasTypes.EmbeddedDataSpecification(
      setter.dataSpecificationContent,
      setter.dataSpecification
    ),
    null
  );
}

/**
 * Parse `jsonable` structure as a literal
 * of {@link types!DataTypeIec61360}.
 *
 * @param jsonable - to be parsed
 * @returns parsed literal, or an error if `jsonable` invalid
 */
export function dataTypeIec61360FromJsonable(
  jsonable: JsonValue
): AasCommon.Either<AasTypes.DataTypeIec61360, DeserializationError> {
  if (typeof jsonable !== "string") {
    return newDeserializationError<AasTypes.DataTypeIec61360>(
      `Expected a string, but got: ${typeof jsonable}`
    );
  }

  const literal = AasStringification.dataTypeIec61360FromString(jsonable);
  if (literal === null) {
    return newDeserializationError<AasTypes.DataTypeIec61360>(
      "Not a valid string representation of " +
        `a literal of DataTypeIec61360: ${jsonable}`
    );
  }

  return new AasCommon.Either<
    AasTypes.DataTypeIec61360,
    DeserializationError
  >(literal, null);
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LevelType}.
 */
class SetterForLevelType {
  min: boolean | null = null;

  nom: boolean | null = null;

  typ: boolean | null = null;

  max: boolean | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link min}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMinFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = booleanFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.min = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link nom}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setNomFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = booleanFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.nom = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link typ}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTypFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = booleanFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.typ = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link max}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setMaxFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = booleanFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.max = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LevelType} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LevelType},
 * or an error if any
 */
export function levelTypeFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.LevelType,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.LevelType>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.LevelType>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.LevelType>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForLevelType();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LEVEL_TYPE.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.LevelType,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.min === null) {
    return newDeserializationError<
      AasTypes.LevelType
    >(
      "The required property 'min' is missing"
    );
  }

  if (setter.nom === null) {
    return newDeserializationError<
      AasTypes.LevelType
    >(
      "The required property 'nom' is missing"
    );
  }

  if (setter.typ === null) {
    return newDeserializationError<
      AasTypes.LevelType
    >(
      "The required property 'typ' is missing"
    );
  }

  if (setter.max === null) {
    return newDeserializationError<
      AasTypes.LevelType
    >(
      "The required property 'max' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.LevelType,
    DeserializationError
  >(
    new AasTypes.LevelType(
      setter.min,
      setter.nom,
      setter.typ,
      setter.max
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ValueReferencePair}.
 */
class SetterForValueReferencePair {
  value: string | null = null;

  valueId: AasTypes.Reference | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueId = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!ValueReferencePair} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ValueReferencePair},
 * or an error if any
 */
export function valueReferencePairFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.ValueReferencePair,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.ValueReferencePair>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.ValueReferencePair>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.ValueReferencePair>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForValueReferencePair();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_VALUE_REFERENCE_PAIR.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.ValueReferencePair,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.value === null) {
    return newDeserializationError<
      AasTypes.ValueReferencePair
    >(
      "The required property 'value' is missing"
    );
  }

  if (setter.valueId === null) {
    return newDeserializationError<
      AasTypes.ValueReferencePair
    >(
      "The required property 'valueId' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.ValueReferencePair,
    DeserializationError
  >(
    new AasTypes.ValueReferencePair(
      setter.value,
      setter.valueId
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!ValueList}.
 */
class SetterForValueList {
  valueReferencePairs: Array<AasTypes.ValueReferencePair> | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueReferencePairs}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueReferencePairsFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.ValueReferencePair>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = valueReferencePairFromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.valueReferencePairs = items;
    return null;
  }
}

/**
 * Parse an instance of {@link types!ValueList} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!ValueList},
 * or an error if any
 */
export function valueListFromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.ValueList,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.ValueList>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.ValueList>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.ValueList>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForValueList();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_VALUE_LIST.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.ValueList,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.valueReferencePairs === null) {
    return newDeserializationError<
      AasTypes.ValueList
    >(
      "The required property 'valueReferencePairs' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.ValueList,
    DeserializationError
  >(
    new AasTypes.ValueList(
      setter.valueReferencePairs
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringPreferredNameTypeIec61360}.
 */
class SetterForLangStringPreferredNameTypeIec61360 {
  language: string | null = null;

  text: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringPreferredNameTypeIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringPreferredNameTypeIec61360},
 * or an error if any
 */
export function langStringPreferredNameTypeIec61360FromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.LangStringPreferredNameTypeIec61360,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.LangStringPreferredNameTypeIec61360>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForLangStringPreferredNameTypeIec61360();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.LangStringPreferredNameTypeIec61360,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.language === null) {
    return newDeserializationError<
      AasTypes.LangStringPreferredNameTypeIec61360
    >(
      "The required property 'language' is missing"
    );
  }

  if (setter.text === null) {
    return newDeserializationError<
      AasTypes.LangStringPreferredNameTypeIec61360
    >(
      "The required property 'text' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.LangStringPreferredNameTypeIec61360,
    DeserializationError
  >(
    new AasTypes.LangStringPreferredNameTypeIec61360(
      setter.language,
      setter.text
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringShortNameTypeIec61360}.
 */
class SetterForLangStringShortNameTypeIec61360 {
  language: string | null = null;

  text: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringShortNameTypeIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringShortNameTypeIec61360},
 * or an error if any
 */
export function langStringShortNameTypeIec61360FromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.LangStringShortNameTypeIec61360,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.LangStringShortNameTypeIec61360>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForLangStringShortNameTypeIec61360();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.LangStringShortNameTypeIec61360,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.language === null) {
    return newDeserializationError<
      AasTypes.LangStringShortNameTypeIec61360
    >(
      "The required property 'language' is missing"
    );
  }

  if (setter.text === null) {
    return newDeserializationError<
      AasTypes.LangStringShortNameTypeIec61360
    >(
      "The required property 'text' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.LangStringShortNameTypeIec61360,
    DeserializationError
  >(
    new AasTypes.LangStringShortNameTypeIec61360(
      setter.language,
      setter.text
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!LangStringDefinitionTypeIec61360}.
 */
class SetterForLangStringDefinitionTypeIec61360 {
  language: string | null = null;

  text: string | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link language}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLanguageFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.language = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link text}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setTextFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.text = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!LangStringDefinitionTypeIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!LangStringDefinitionTypeIec61360},
 * or an error if any
 */
export function langStringDefinitionTypeIec61360FromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.LangStringDefinitionTypeIec61360,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.LangStringDefinitionTypeIec61360>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForLangStringDefinitionTypeIec61360();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.LangStringDefinitionTypeIec61360,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.language === null) {
    return newDeserializationError<
      AasTypes.LangStringDefinitionTypeIec61360
    >(
      "The required property 'language' is missing"
    );
  }

  if (setter.text === null) {
    return newDeserializationError<
      AasTypes.LangStringDefinitionTypeIec61360
    >(
      "The required property 'text' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.LangStringDefinitionTypeIec61360,
    DeserializationError
  >(
    new AasTypes.LangStringDefinitionTypeIec61360(
      setter.language,
      setter.text
    ),
    null
  );
}

/**
 * Provide de-serialize & set methods for properties
 * of {@link types!DataSpecificationIec61360}.
 */
class SetterForDataSpecificationIec61360 {
  preferredName: Array<AasTypes.LangStringPreferredNameTypeIec61360> | null = null;

  shortName: Array<AasTypes.LangStringShortNameTypeIec61360> | null = null;

  unit: string | null = null;

  unitId: AasTypes.Reference | null = null;

  sourceOfDefinition: string | null = null;

  symbol: string | null = null;

  dataType: AasTypes.DataTypeIec61360 | null = null;

  definition: Array<AasTypes.LangStringDefinitionTypeIec61360> | null = null;

  valueFormat: string | null = null;

  valueList: AasTypes.ValueList | null = null;

  value: string | null = null;

  levelType: AasTypes.LevelType | null = null;

  /**
   * Ignore `jsonable` and do not set anything.
   *
   * @param jsonable - to be ignored instead of set
   * @returns error, if any
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ignore(jsonable: JsonValue): DeserializationError | null {
    // Intentionally empty.
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link preferredName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setPreferredNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringPreferredNameTypeIec61360>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringPreferredNameTypeIec61360FromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.preferredName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link shortName}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setShortNameFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringShortNameTypeIec61360>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringShortNameTypeIec61360FromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.shortName = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link unit}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setUnitFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.unit = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link unitId}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setUnitIdFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = referenceFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.unitId = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link sourceOfDefinition}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSourceOfDefinitionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.sourceOfDefinition = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link symbol}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setSymbolFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.symbol = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link dataType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDataTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = dataTypeIec61360FromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.dataType = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link definition}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setDefinitionFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    if (jsonable === null) {
      return new DeserializationError(
        "Expected an iterable, but got null"
      );
    }
    if (typeof jsonable !== "object") {
      return new DeserializationError(
        `Expected an iterable, but got: ${typeof jsonable}`
      );
    }
    if (typeof jsonable[Symbol.iterator] !== "function") {
      return new DeserializationError(
        "Expected an iterable with iterator function, " +
          `but got iterator of type: ${typeof jsonable[Symbol.iterator]}`
      );
    }

    const iterable = <Iterable<JsonValue>>jsonable;

    const items =
      new Array<AasTypes.LangStringDefinitionTypeIec61360>();

    let i = 0;
    for (const jsonableItem of iterable) {
      const itemOrError = langStringDefinitionTypeIec61360FromJsonable(
        jsonableItem
      );

      if (itemOrError.error !== null) {
        itemOrError.error.path.prepend(
          new IndexSegment(
            iterable,
            i
          )
        );
        return itemOrError.error;
      }

      items.push(itemOrError.mustValue());
      i++;
    }

    this.definition = items;
    return null;
  }

  /**
   * Parse `jsonable` as the value of {@link valueFormat}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFormatFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueFormat = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link valueList}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueListFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = valueListFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.valueList = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link value}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setValueFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = stringFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.value = parsedOrError.mustValue();
      return null;
    }
  }

  /**
   * Parse `jsonable` as the value of {@link levelType}.
   *
   * @param jsonable - to be parsed
   * @returns error, if any
   */
  setLevelTypeFromJsonable(
    jsonable: JsonValue
  ): DeserializationError | null {
    const parsedOrError = levelTypeFromJsonable(
      jsonable
    );
    if (parsedOrError.error !== null) {
      return parsedOrError.error;
    } else {
      this.levelType = parsedOrError.mustValue();
      return null;
    }
  }
}

/**
 * Parse an instance of {@link types!DataSpecificationIec61360} from the JSON-able
 * structure `jsonable`.
 *
 * @param jsonable - structure to be parsed
 * @returns parsed instance of {@link types!DataSpecificationIec61360},
 * or an error if any
 */
export function dataSpecificationIec61360FromJsonable(
  jsonable: JsonValue
): AasCommon.Either<
  AasTypes.DataSpecificationIec61360,
  DeserializationError
> {
  if (jsonable === null) {
    return newDeserializationError<AasTypes.DataSpecificationIec61360>(
      "Expected a JSON object, but got null"
    );
  }
    if (Array.isArray(jsonable)) {
      return newDeserializationError<AasTypes.DataSpecificationIec61360>(
        "Expected a JSON object, but got a JSON array"
      );
    }
  if (typeof jsonable !== "object") {
    return newDeserializationError<AasTypes.DataSpecificationIec61360>(
      `Expected a JSON object, but got: ${typeof jsonable}`
    );
  }

  const setter = new SetterForDataSpecificationIec61360();

  for (const key in jsonable) {
    const jsonableValue = jsonable[key];
    const setterMethod =
      SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360.get(key);

    // NOTE (mristin, 2022-11-30):
    // Since we conflate here a JavaScript object with a JSON object, we ignore
    // properties which we do not know how to de-serialize and assume they are
    // related to the *JavaScript* properties of the object or `Object` prototype.
    if (setterMethod === undefined) {
      continue;
    }

    const error = setterMethod.call(setter, jsonableValue);
    if (error !== null) {
      error.path.prepend(
        new PropertySegment(<JsonObject>jsonable, key)
      );
      return new AasCommon.Either<
        AasTypes.DataSpecificationIec61360,
        DeserializationError
      >(
          null,
          error
        );
    }
  }

  if (setter.preferredName === null) {
    return newDeserializationError<
      AasTypes.DataSpecificationIec61360
    >(
      "The required property 'preferredName' is missing"
    );
  }

  return new AasCommon.Either<
    AasTypes.DataSpecificationIec61360,
    DeserializationError
  >(
    new AasTypes.DataSpecificationIec61360(
      setter.preferredName,
      setter.shortName,
      setter.unit,
      setter.unitId,
      setter.sourceOfDefinition,
      setter.symbol,
      setter.dataType,
      setter.definition,
      setter.valueFormat,
      setter.valueList,
      setter.value,
      setter.levelType
    ),
    null
  );
}

const HAS_SEMANTICS_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IHasSemantics,
      DeserializationError
    >
  >(
    [
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ],
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ],
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "Capability",
        capabilityFromJsonable
      ],
      [
        "Entity",
        entityFromJsonable
      ],
      [
        "Extension",
        extensionFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Operation",
        operationFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Qualifier",
        qualifierFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ],
      [
        "SpecificAssetId",
        specificAssetIdFromJsonable
      ],
      [
        "Submodel",
        submodelFromJsonable
      ],
      [
        "SubmodelElementCollection",
        submodelElementCollectionFromJsonable
      ],
      [
        "SubmodelElementList",
        submodelElementListFromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_EXTENSION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "semanticId",
        SetterForExtension.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForExtension.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "name",
        SetterForExtension.prototype.setNameFromJsonable
      ],
      [
        "valueType",
        SetterForExtension.prototype.setValueTypeFromJsonable
      ],
      [
        "value",
        SetterForExtension.prototype.setValueFromJsonable
      ],
      [
        "refersTo",
        SetterForExtension.prototype.setRefersToFromJsonable
      ],
      [
        "modelType",
        SetterForExtension.prototype.ignore
      ]
    ]
  );

const HAS_EXTENSIONS_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IHasExtensions,
      DeserializationError
    >
  >(
    [
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ],
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "AssetAdministrationShell",
        assetAdministrationShellFromJsonable
      ],
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ],
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "Capability",
        capabilityFromJsonable
      ],
      [
        "ConceptDescription",
        conceptDescriptionFromJsonable
      ],
      [
        "Entity",
        entityFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Operation",
        operationFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ],
      [
        "Submodel",
        submodelFromJsonable
      ],
      [
        "SubmodelElementCollection",
        submodelElementCollectionFromJsonable
      ],
      [
        "SubmodelElementList",
        submodelElementListFromJsonable
      ]
    ]
  );

const REFERABLE_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IReferable,
      DeserializationError
    >
  >(
    [
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ],
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "AssetAdministrationShell",
        assetAdministrationShellFromJsonable
      ],
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ],
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "Capability",
        capabilityFromJsonable
      ],
      [
        "ConceptDescription",
        conceptDescriptionFromJsonable
      ],
      [
        "Entity",
        entityFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Operation",
        operationFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ],
      [
        "Submodel",
        submodelFromJsonable
      ],
      [
        "SubmodelElementCollection",
        submodelElementCollectionFromJsonable
      ],
      [
        "SubmodelElementList",
        submodelElementListFromJsonable
      ]
    ]
  );

const IDENTIFIABLE_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IIdentifiable,
      DeserializationError
    >
  >(
    [
      [
        "AssetAdministrationShell",
        assetAdministrationShellFromJsonable
      ],
      [
        "ConceptDescription",
        conceptDescriptionFromJsonable
      ],
      [
        "Submodel",
        submodelFromJsonable
      ]
    ]
  );

const HAS_KIND_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IHasKind,
      DeserializationError
    >
  >(
    [
      [
        "Submodel",
        submodelFromJsonable
      ]
    ]
  );

const HAS_DATA_SPECIFICATION_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IHasDataSpecification,
      DeserializationError
    >
  >(
    [
      [
        "AdministrativeInformation",
        administrativeInformationFromJsonable
      ],
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ],
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "AssetAdministrationShell",
        assetAdministrationShellFromJsonable
      ],
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ],
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "Capability",
        capabilityFromJsonable
      ],
      [
        "ConceptDescription",
        conceptDescriptionFromJsonable
      ],
      [
        "Entity",
        entityFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Operation",
        operationFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ],
      [
        "Submodel",
        submodelFromJsonable
      ],
      [
        "SubmodelElementCollection",
        submodelElementCollectionFromJsonable
      ],
      [
        "SubmodelElementList",
        submodelElementListFromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_ADMINISTRATIVE_INFORMATION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "embeddedDataSpecifications",
        SetterForAdministrativeInformation.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "version",
        SetterForAdministrativeInformation.prototype.setVersionFromJsonable
      ],
      [
        "revision",
        SetterForAdministrativeInformation.prototype.setRevisionFromJsonable
      ],
      [
        "creator",
        SetterForAdministrativeInformation.prototype.setCreatorFromJsonable
      ],
      [
        "templateId",
        SetterForAdministrativeInformation.prototype.setTemplateIdFromJsonable
      ],
      [
        "modelType",
        SetterForAdministrativeInformation.prototype.ignore
      ]
    ]
  );

const QUALIFIABLE_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IQualifiable,
      DeserializationError
    >
  >(
    [
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ],
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ],
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "Capability",
        capabilityFromJsonable
      ],
      [
        "Entity",
        entityFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Operation",
        operationFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ],
      [
        "Submodel",
        submodelFromJsonable
      ],
      [
        "SubmodelElementCollection",
        submodelElementCollectionFromJsonable
      ],
      [
        "SubmodelElementList",
        submodelElementListFromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_QUALIFIER =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "semanticId",
        SetterForQualifier.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForQualifier.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "kind",
        SetterForQualifier.prototype.setKindFromJsonable
      ],
      [
        "type",
        SetterForQualifier.prototype.setTypeFromJsonable
      ],
      [
        "valueType",
        SetterForQualifier.prototype.setValueTypeFromJsonable
      ],
      [
        "value",
        SetterForQualifier.prototype.setValueFromJsonable
      ],
      [
        "valueId",
        SetterForQualifier.prototype.setValueIdFromJsonable
      ],
      [
        "modelType",
        SetterForQualifier.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_ASSET_ADMINISTRATION_SHELL =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForAssetAdministrationShell.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForAssetAdministrationShell.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForAssetAdministrationShell.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForAssetAdministrationShell.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForAssetAdministrationShell.prototype.setDescriptionFromJsonable
      ],
      [
        "administration",
        SetterForAssetAdministrationShell.prototype.setAdministrationFromJsonable
      ],
      [
        "id",
        SetterForAssetAdministrationShell.prototype.setIdFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForAssetAdministrationShell.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "derivedFrom",
        SetterForAssetAdministrationShell.prototype.setDerivedFromFromJsonable
      ],
      [
        "assetInformation",
        SetterForAssetAdministrationShell.prototype.setAssetInformationFromJsonable
      ],
      [
        "submodels",
        SetterForAssetAdministrationShell.prototype.setSubmodelsFromJsonable
      ],
      [
        "modelType",
        SetterForAssetAdministrationShell.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_ASSET_INFORMATION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "assetKind",
        SetterForAssetInformation.prototype.setAssetKindFromJsonable
      ],
      [
        "globalAssetId",
        SetterForAssetInformation.prototype.setGlobalAssetIdFromJsonable
      ],
      [
        "specificAssetIds",
        SetterForAssetInformation.prototype.setSpecificAssetIdsFromJsonable
      ],
      [
        "assetType",
        SetterForAssetInformation.prototype.setAssetTypeFromJsonable
      ],
      [
        "defaultThumbnail",
        SetterForAssetInformation.prototype.setDefaultThumbnailFromJsonable
      ],
      [
        "modelType",
        SetterForAssetInformation.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_RESOURCE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "path",
        SetterForResource.prototype.setPathFromJsonable
      ],
      [
        "contentType",
        SetterForResource.prototype.setContentTypeFromJsonable
      ],
      [
        "modelType",
        SetterForResource.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_SPECIFIC_ASSET_ID =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "semanticId",
        SetterForSpecificAssetId.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForSpecificAssetId.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "name",
        SetterForSpecificAssetId.prototype.setNameFromJsonable
      ],
      [
        "value",
        SetterForSpecificAssetId.prototype.setValueFromJsonable
      ],
      [
        "externalSubjectId",
        SetterForSpecificAssetId.prototype.setExternalSubjectIdFromJsonable
      ],
      [
        "modelType",
        SetterForSpecificAssetId.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_SUBMODEL =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForSubmodel.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForSubmodel.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForSubmodel.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForSubmodel.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForSubmodel.prototype.setDescriptionFromJsonable
      ],
      [
        "administration",
        SetterForSubmodel.prototype.setAdministrationFromJsonable
      ],
      [
        "id",
        SetterForSubmodel.prototype.setIdFromJsonable
      ],
      [
        "kind",
        SetterForSubmodel.prototype.setKindFromJsonable
      ],
      [
        "semanticId",
        SetterForSubmodel.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForSubmodel.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForSubmodel.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForSubmodel.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "submodelElements",
        SetterForSubmodel.prototype.setSubmodelElementsFromJsonable
      ],
      [
        "modelType",
        SetterForSubmodel.prototype.ignore
      ]
    ]
  );

const SUBMODEL_ELEMENT_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.ISubmodelElement,
      DeserializationError
    >
  >(
    [
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ],
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ],
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "Capability",
        capabilityFromJsonable
      ],
      [
        "Entity",
        entityFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Operation",
        operationFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ],
      [
        "SubmodelElementCollection",
        submodelElementCollectionFromJsonable
      ],
      [
        "SubmodelElementList",
        submodelElementListFromJsonable
      ]
    ]
  );

const RELATIONSHIP_ELEMENT_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IRelationshipElement,
      DeserializationError
    >
  >(
    [
      [
        "AnnotatedRelationshipElement",
        annotatedRelationshipElementFromJsonable
      ],
      [
        "RelationshipElement",
        relationshipElementFromJsonableWithoutDispatch
      ]
    ]
  );

const SETTER_MAP_FOR_RELATIONSHIP_ELEMENT =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForRelationshipElement.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForRelationshipElement.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForRelationshipElement.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForRelationshipElement.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForRelationshipElement.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForRelationshipElement.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForRelationshipElement.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForRelationshipElement.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForRelationshipElement.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "first",
        SetterForRelationshipElement.prototype.setFirstFromJsonable
      ],
      [
        "second",
        SetterForRelationshipElement.prototype.setSecondFromJsonable
      ],
      [
        "modelType",
        SetterForRelationshipElement.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_SUBMODEL_ELEMENT_LIST =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForSubmodelElementList.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForSubmodelElementList.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForSubmodelElementList.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForSubmodelElementList.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForSubmodelElementList.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForSubmodelElementList.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForSubmodelElementList.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForSubmodelElementList.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForSubmodelElementList.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "orderRelevant",
        SetterForSubmodelElementList.prototype.setOrderRelevantFromJsonable
      ],
      [
        "semanticIdListElement",
        SetterForSubmodelElementList.prototype.setSemanticIdListElementFromJsonable
      ],
      [
        "typeValueListElement",
        SetterForSubmodelElementList.prototype.setTypeValueListElementFromJsonable
      ],
      [
        "valueTypeListElement",
        SetterForSubmodelElementList.prototype.setValueTypeListElementFromJsonable
      ],
      [
        "value",
        SetterForSubmodelElementList.prototype.setValueFromJsonable
      ],
      [
        "modelType",
        SetterForSubmodelElementList.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_SUBMODEL_ELEMENT_COLLECTION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForSubmodelElementCollection.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForSubmodelElementCollection.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForSubmodelElementCollection.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForSubmodelElementCollection.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForSubmodelElementCollection.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForSubmodelElementCollection.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForSubmodelElementCollection.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForSubmodelElementCollection.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForSubmodelElementCollection.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "value",
        SetterForSubmodelElementCollection.prototype.setValueFromJsonable
      ],
      [
        "modelType",
        SetterForSubmodelElementCollection.prototype.ignore
      ]
    ]
  );

const DATA_ELEMENT_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IDataElement,
      DeserializationError
    >
  >(
    [
      [
        "Blob",
        blobFromJsonable
      ],
      [
        "File",
        fileFromJsonable
      ],
      [
        "MultiLanguageProperty",
        multiLanguagePropertyFromJsonable
      ],
      [
        "Property",
        propertyFromJsonable
      ],
      [
        "Range",
        rangeFromJsonable
      ],
      [
        "ReferenceElement",
        referenceElementFromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_PROPERTY =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForProperty.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForProperty.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForProperty.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForProperty.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForProperty.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForProperty.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForProperty.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForProperty.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForProperty.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "valueType",
        SetterForProperty.prototype.setValueTypeFromJsonable
      ],
      [
        "value",
        SetterForProperty.prototype.setValueFromJsonable
      ],
      [
        "valueId",
        SetterForProperty.prototype.setValueIdFromJsonable
      ],
      [
        "modelType",
        SetterForProperty.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_MULTI_LANGUAGE_PROPERTY =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForMultiLanguageProperty.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForMultiLanguageProperty.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForMultiLanguageProperty.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForMultiLanguageProperty.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForMultiLanguageProperty.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForMultiLanguageProperty.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForMultiLanguageProperty.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForMultiLanguageProperty.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForMultiLanguageProperty.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "value",
        SetterForMultiLanguageProperty.prototype.setValueFromJsonable
      ],
      [
        "valueId",
        SetterForMultiLanguageProperty.prototype.setValueIdFromJsonable
      ],
      [
        "modelType",
        SetterForMultiLanguageProperty.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_RANGE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForRange.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForRange.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForRange.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForRange.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForRange.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForRange.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForRange.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForRange.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForRange.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "valueType",
        SetterForRange.prototype.setValueTypeFromJsonable
      ],
      [
        "min",
        SetterForRange.prototype.setMinFromJsonable
      ],
      [
        "max",
        SetterForRange.prototype.setMaxFromJsonable
      ],
      [
        "modelType",
        SetterForRange.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_REFERENCE_ELEMENT =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForReferenceElement.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForReferenceElement.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForReferenceElement.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForReferenceElement.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForReferenceElement.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForReferenceElement.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForReferenceElement.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForReferenceElement.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForReferenceElement.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "value",
        SetterForReferenceElement.prototype.setValueFromJsonable
      ],
      [
        "modelType",
        SetterForReferenceElement.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_BLOB =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForBlob.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForBlob.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForBlob.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForBlob.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForBlob.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForBlob.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForBlob.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForBlob.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForBlob.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "value",
        SetterForBlob.prototype.setValueFromJsonable
      ],
      [
        "contentType",
        SetterForBlob.prototype.setContentTypeFromJsonable
      ],
      [
        "modelType",
        SetterForBlob.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_FILE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForFile.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForFile.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForFile.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForFile.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForFile.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForFile.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForFile.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForFile.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForFile.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "value",
        SetterForFile.prototype.setValueFromJsonable
      ],
      [
        "contentType",
        SetterForFile.prototype.setContentTypeFromJsonable
      ],
      [
        "modelType",
        SetterForFile.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_ANNOTATED_RELATIONSHIP_ELEMENT =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForAnnotatedRelationshipElement.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForAnnotatedRelationshipElement.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForAnnotatedRelationshipElement.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForAnnotatedRelationshipElement.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForAnnotatedRelationshipElement.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForAnnotatedRelationshipElement.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForAnnotatedRelationshipElement.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForAnnotatedRelationshipElement.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForAnnotatedRelationshipElement.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "first",
        SetterForAnnotatedRelationshipElement.prototype.setFirstFromJsonable
      ],
      [
        "second",
        SetterForAnnotatedRelationshipElement.prototype.setSecondFromJsonable
      ],
      [
        "annotations",
        SetterForAnnotatedRelationshipElement.prototype.setAnnotationsFromJsonable
      ],
      [
        "modelType",
        SetterForAnnotatedRelationshipElement.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_ENTITY =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForEntity.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForEntity.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForEntity.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForEntity.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForEntity.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForEntity.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForEntity.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForEntity.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForEntity.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "statements",
        SetterForEntity.prototype.setStatementsFromJsonable
      ],
      [
        "entityType",
        SetterForEntity.prototype.setEntityTypeFromJsonable
      ],
      [
        "globalAssetId",
        SetterForEntity.prototype.setGlobalAssetIdFromJsonable
      ],
      [
        "specificAssetIds",
        SetterForEntity.prototype.setSpecificAssetIdsFromJsonable
      ],
      [
        "modelType",
        SetterForEntity.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_EVENT_PAYLOAD =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "source",
        SetterForEventPayload.prototype.setSourceFromJsonable
      ],
      [
        "sourceSemanticId",
        SetterForEventPayload.prototype.setSourceSemanticIdFromJsonable
      ],
      [
        "observableReference",
        SetterForEventPayload.prototype.setObservableReferenceFromJsonable
      ],
      [
        "observableSemanticId",
        SetterForEventPayload.prototype.setObservableSemanticIdFromJsonable
      ],
      [
        "topic",
        SetterForEventPayload.prototype.setTopicFromJsonable
      ],
      [
        "subjectId",
        SetterForEventPayload.prototype.setSubjectIdFromJsonable
      ],
      [
        "timeStamp",
        SetterForEventPayload.prototype.setTimeStampFromJsonable
      ],
      [
        "payload",
        SetterForEventPayload.prototype.setPayloadFromJsonable
      ],
      [
        "modelType",
        SetterForEventPayload.prototype.ignore
      ]
    ]
  );

const EVENT_ELEMENT_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IEventElement,
      DeserializationError
    >
  >(
    [
      [
        "BasicEventElement",
        basicEventElementFromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_BASIC_EVENT_ELEMENT =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForBasicEventElement.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForBasicEventElement.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForBasicEventElement.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForBasicEventElement.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForBasicEventElement.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForBasicEventElement.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForBasicEventElement.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForBasicEventElement.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForBasicEventElement.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "observed",
        SetterForBasicEventElement.prototype.setObservedFromJsonable
      ],
      [
        "direction",
        SetterForBasicEventElement.prototype.setDirectionFromJsonable
      ],
      [
        "state",
        SetterForBasicEventElement.prototype.setStateFromJsonable
      ],
      [
        "messageTopic",
        SetterForBasicEventElement.prototype.setMessageTopicFromJsonable
      ],
      [
        "messageBroker",
        SetterForBasicEventElement.prototype.setMessageBrokerFromJsonable
      ],
      [
        "lastUpdate",
        SetterForBasicEventElement.prototype.setLastUpdateFromJsonable
      ],
      [
        "minInterval",
        SetterForBasicEventElement.prototype.setMinIntervalFromJsonable
      ],
      [
        "maxInterval",
        SetterForBasicEventElement.prototype.setMaxIntervalFromJsonable
      ],
      [
        "modelType",
        SetterForBasicEventElement.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_OPERATION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForOperation.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForOperation.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForOperation.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForOperation.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForOperation.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForOperation.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForOperation.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForOperation.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForOperation.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "inputVariables",
        SetterForOperation.prototype.setInputVariablesFromJsonable
      ],
      [
        "outputVariables",
        SetterForOperation.prototype.setOutputVariablesFromJsonable
      ],
      [
        "inoutputVariables",
        SetterForOperation.prototype.setInoutputVariablesFromJsonable
      ],
      [
        "modelType",
        SetterForOperation.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_OPERATION_VARIABLE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "value",
        SetterForOperationVariable.prototype.setValueFromJsonable
      ],
      [
        "modelType",
        SetterForOperationVariable.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_CAPABILITY =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForCapability.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForCapability.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForCapability.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForCapability.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForCapability.prototype.setDescriptionFromJsonable
      ],
      [
        "semanticId",
        SetterForCapability.prototype.setSemanticIdFromJsonable
      ],
      [
        "supplementalSemanticIds",
        SetterForCapability.prototype.setSupplementalSemanticIdsFromJsonable
      ],
      [
        "qualifiers",
        SetterForCapability.prototype.setQualifiersFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForCapability.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "modelType",
        SetterForCapability.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_CONCEPT_DESCRIPTION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "extensions",
        SetterForConceptDescription.prototype.setExtensionsFromJsonable
      ],
      [
        "category",
        SetterForConceptDescription.prototype.setCategoryFromJsonable
      ],
      [
        "idShort",
        SetterForConceptDescription.prototype.setIdShortFromJsonable
      ],
      [
        "displayName",
        SetterForConceptDescription.prototype.setDisplayNameFromJsonable
      ],
      [
        "description",
        SetterForConceptDescription.prototype.setDescriptionFromJsonable
      ],
      [
        "administration",
        SetterForConceptDescription.prototype.setAdministrationFromJsonable
      ],
      [
        "id",
        SetterForConceptDescription.prototype.setIdFromJsonable
      ],
      [
        "embeddedDataSpecifications",
        SetterForConceptDescription.prototype.setEmbeddedDataSpecificationsFromJsonable
      ],
      [
        "isCaseOf",
        SetterForConceptDescription.prototype.setIsCaseOfFromJsonable
      ],
      [
        "modelType",
        SetterForConceptDescription.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_REFERENCE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "type",
        SetterForReference.prototype.setTypeFromJsonable
      ],
      [
        "referredSemanticId",
        SetterForReference.prototype.setReferredSemanticIdFromJsonable
      ],
      [
        "keys",
        SetterForReference.prototype.setKeysFromJsonable
      ],
      [
        "modelType",
        SetterForReference.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_KEY =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "type",
        SetterForKey.prototype.setTypeFromJsonable
      ],
      [
        "value",
        SetterForKey.prototype.setValueFromJsonable
      ],
      [
        "modelType",
        SetterForKey.prototype.ignore
      ]
    ]
  );

const ABSTRACT_LANG_STRING_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IAbstractLangString,
      DeserializationError
    >
  >(
    [
      [
        "LangStringDefinitionTypeIec61360",
        langStringDefinitionTypeIec61360FromJsonable
      ],
      [
        "LangStringNameType",
        langStringNameTypeFromJsonable
      ],
      [
        "LangStringPreferredNameTypeIec61360",
        langStringPreferredNameTypeIec61360FromJsonable
      ],
      [
        "LangStringShortNameTypeIec61360",
        langStringShortNameTypeIec61360FromJsonable
      ],
      [
        "LangStringTextType",
        langStringTextTypeFromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_LANG_STRING_NAME_TYPE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "language",
        SetterForLangStringNameType.prototype.setLanguageFromJsonable
      ],
      [
        "text",
        SetterForLangStringNameType.prototype.setTextFromJsonable
      ],
      [
        "modelType",
        SetterForLangStringNameType.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_LANG_STRING_TEXT_TYPE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "language",
        SetterForLangStringTextType.prototype.setLanguageFromJsonable
      ],
      [
        "text",
        SetterForLangStringTextType.prototype.setTextFromJsonable
      ],
      [
        "modelType",
        SetterForLangStringTextType.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_ENVIRONMENT =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "assetAdministrationShells",
        SetterForEnvironment.prototype.setAssetAdministrationShellsFromJsonable
      ],
      [
        "submodels",
        SetterForEnvironment.prototype.setSubmodelsFromJsonable
      ],
      [
        "conceptDescriptions",
        SetterForEnvironment.prototype.setConceptDescriptionsFromJsonable
      ],
      [
        "modelType",
        SetterForEnvironment.prototype.ignore
      ]
    ]
  );

const DATA_SPECIFICATION_CONTENT_FROM_JSONABLE_DISPATCH =
  new Map<
    string,
    (JsonValue) => AasCommon.Either<
      AasTypes.IDataSpecificationContent,
      DeserializationError
    >
  >(
    [
      [
        "DataSpecificationIec61360",
        dataSpecificationIec61360FromJsonable
      ]
    ]
  );

const SETTER_MAP_FOR_EMBEDDED_DATA_SPECIFICATION =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "dataSpecificationContent",
        SetterForEmbeddedDataSpecification.prototype.setDataSpecificationContentFromJsonable
      ],
      [
        "dataSpecification",
        SetterForEmbeddedDataSpecification.prototype.setDataSpecificationFromJsonable
      ],
      [
        "modelType",
        SetterForEmbeddedDataSpecification.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_LEVEL_TYPE =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "min",
        SetterForLevelType.prototype.setMinFromJsonable
      ],
      [
        "nom",
        SetterForLevelType.prototype.setNomFromJsonable
      ],
      [
        "typ",
        SetterForLevelType.prototype.setTypFromJsonable
      ],
      [
        "max",
        SetterForLevelType.prototype.setMaxFromJsonable
      ],
      [
        "modelType",
        SetterForLevelType.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_VALUE_REFERENCE_PAIR =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "value",
        SetterForValueReferencePair.prototype.setValueFromJsonable
      ],
      [
        "valueId",
        SetterForValueReferencePair.prototype.setValueIdFromJsonable
      ],
      [
        "modelType",
        SetterForValueReferencePair.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_VALUE_LIST =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "valueReferencePairs",
        SetterForValueList.prototype.setValueReferencePairsFromJsonable
      ],
      [
        "modelType",
        SetterForValueList.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_LANG_STRING_PREFERRED_NAME_TYPE_IEC_61360 =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "language",
        SetterForLangStringPreferredNameTypeIec61360.prototype.setLanguageFromJsonable
      ],
      [
        "text",
        SetterForLangStringPreferredNameTypeIec61360.prototype.setTextFromJsonable
      ],
      [
        "modelType",
        SetterForLangStringPreferredNameTypeIec61360.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_LANG_STRING_SHORT_NAME_TYPE_IEC_61360 =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "language",
        SetterForLangStringShortNameTypeIec61360.prototype.setLanguageFromJsonable
      ],
      [
        "text",
        SetterForLangStringShortNameTypeIec61360.prototype.setTextFromJsonable
      ],
      [
        "modelType",
        SetterForLangStringShortNameTypeIec61360.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_LANG_STRING_DEFINITION_TYPE_IEC_61360 =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "language",
        SetterForLangStringDefinitionTypeIec61360.prototype.setLanguageFromJsonable
      ],
      [
        "text",
        SetterForLangStringDefinitionTypeIec61360.prototype.setTextFromJsonable
      ],
      [
        "modelType",
        SetterForLangStringDefinitionTypeIec61360.prototype.ignore
      ]
    ]
  );

const SETTER_MAP_FOR_DATA_SPECIFICATION_IEC_61360 =
  new Map<
    string,
    (
      jsonable: JsonValue
    ) => DeserializationError | null
  >(
    [
      [
        "preferredName",
        SetterForDataSpecificationIec61360.prototype.setPreferredNameFromJsonable
      ],
      [
        "shortName",
        SetterForDataSpecificationIec61360.prototype.setShortNameFromJsonable
      ],
      [
        "unit",
        SetterForDataSpecificationIec61360.prototype.setUnitFromJsonable
      ],
      [
        "unitId",
        SetterForDataSpecificationIec61360.prototype.setUnitIdFromJsonable
      ],
      [
        "sourceOfDefinition",
        SetterForDataSpecificationIec61360.prototype.setSourceOfDefinitionFromJsonable
      ],
      [
        "symbol",
        SetterForDataSpecificationIec61360.prototype.setSymbolFromJsonable
      ],
      [
        "dataType",
        SetterForDataSpecificationIec61360.prototype.setDataTypeFromJsonable
      ],
      [
        "definition",
        SetterForDataSpecificationIec61360.prototype.setDefinitionFromJsonable
      ],
      [
        "valueFormat",
        SetterForDataSpecificationIec61360.prototype.setValueFormatFromJsonable
      ],
      [
        "valueList",
        SetterForDataSpecificationIec61360.prototype.setValueListFromJsonable
      ],
      [
        "value",
        SetterForDataSpecificationIec61360.prototype.setValueFromJsonable
      ],
      [
        "levelType",
        SetterForDataSpecificationIec61360.prototype.setLevelTypeFromJsonable
      ],
      [
        "modelType",
        SetterForDataSpecificationIec61360.prototype.ignore
      ]
    ]
  );

// endregion

// region Serialization

/**
 * Transform the instance to its JSON-able representation.
 */
class Serializer extends AasTypes.AbstractTransformer<JsonObject> {


  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformExtension(
    that: AasTypes.Extension
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    jsonable["name"] =
      that.name;

    if (that.valueType !== null) {
      jsonable["valueType"] =
        AasStringification.mustDataTypeDefXsdToString(
          that.valueType
        );
    }

    if (that.value !== null) {
      jsonable["value"] =
        that.value;
    }

    if (that.refersTo !== null) {
      const refersToArray = new Array<JsonObject>();
      for (const item of that.refersTo) {
        refersToArray.push(
          this.transform(item)
        );
      }
      jsonable["refersTo"] = refersToArray;
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAdministrativeInformation(
    that: AasTypes.AdministrativeInformation
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.version !== null) {
      jsonable["version"] =
        that.version;
    }

    if (that.revision !== null) {
      jsonable["revision"] =
        that.revision;
    }

    if (that.creator !== null) {
      jsonable["creator"] =
        this.transform(that.creator);
    }

    if (that.templateId !== null) {
      jsonable["templateId"] =
        that.templateId;
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformQualifier(
    that: AasTypes.Qualifier
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.kind !== null) {
      jsonable["kind"] =
        AasStringification.mustQualifierKindToString(
          that.kind
        );
    }

    jsonable["type"] =
      that.type;

    jsonable["valueType"] =
      AasStringification.mustDataTypeDefXsdToString(
        that.valueType
      );

    if (that.value !== null) {
      jsonable["value"] =
        that.value;
    }

    if (that.valueId !== null) {
      jsonable["valueId"] =
        this.transform(that.valueId);
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAssetAdministrationShell(
    that: AasTypes.AssetAdministrationShell
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.administration !== null) {
      jsonable["administration"] =
        this.transform(that.administration);
    }

    jsonable["id"] =
      that.id;

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.derivedFrom !== null) {
      jsonable["derivedFrom"] =
        this.transform(that.derivedFrom);
    }

    jsonable["assetInformation"] =
      this.transform(that.assetInformation);

    if (that.submodels !== null) {
      const submodelsArray = new Array<JsonObject>();
      for (const item of that.submodels) {
        submodelsArray.push(
          this.transform(item)
        );
      }
      jsonable["submodels"] = submodelsArray;
    }

    jsonable["modelType"] = "AssetAdministrationShell";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAssetInformation(
    that: AasTypes.AssetInformation
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["assetKind"] =
      AasStringification.mustAssetKindToString(
        that.assetKind
      );

    if (that.globalAssetId !== null) {
      jsonable["globalAssetId"] =
        that.globalAssetId;
    }

    if (that.specificAssetIds !== null) {
      const specificAssetIdsArray = new Array<JsonObject>();
      for (const item of that.specificAssetIds) {
        specificAssetIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["specificAssetIds"] = specificAssetIdsArray;
    }

    if (that.assetType !== null) {
      jsonable["assetType"] =
        that.assetType;
    }

    if (that.defaultThumbnail !== null) {
      jsonable["defaultThumbnail"] =
        this.transform(that.defaultThumbnail);
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformResource(
    that: AasTypes.Resource
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["path"] =
      that.path;

    if (that.contentType !== null) {
      jsonable["contentType"] =
        that.contentType;
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSpecificAssetId(
    that: AasTypes.SpecificAssetId
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    jsonable["name"] =
      that.name;

    jsonable["value"] =
      that.value;

    if (that.externalSubjectId !== null) {
      jsonable["externalSubjectId"] =
        this.transform(that.externalSubjectId);
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSubmodel(
    that: AasTypes.Submodel
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.administration !== null) {
      jsonable["administration"] =
        this.transform(that.administration);
    }

    jsonable["id"] =
      that.id;

    if (that.kind !== null) {
      jsonable["kind"] =
        AasStringification.mustModellingKindToString(
          that.kind
        );
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.submodelElements !== null) {
      const submodelElementsArray = new Array<JsonObject>();
      for (const item of that.submodelElements) {
        submodelElementsArray.push(
          this.transform(item)
        );
      }
      jsonable["submodelElements"] = submodelElementsArray;
    }

    jsonable["modelType"] = "Submodel";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformRelationshipElement(
    that: AasTypes.RelationshipElement
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    jsonable["first"] =
      this.transform(that.first);

    jsonable["second"] =
      this.transform(that.second);

    jsonable["modelType"] = "RelationshipElement";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSubmodelElementList(
    that: AasTypes.SubmodelElementList
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.orderRelevant !== null) {
      jsonable["orderRelevant"] =
        that.orderRelevant;
    }

    if (that.semanticIdListElement !== null) {
      jsonable["semanticIdListElement"] =
        this.transform(that.semanticIdListElement);
    }

    jsonable["typeValueListElement"] =
      AasStringification.mustAasSubmodelElementsToString(
        that.typeValueListElement
      );

    if (that.valueTypeListElement !== null) {
      jsonable["valueTypeListElement"] =
        AasStringification.mustDataTypeDefXsdToString(
          that.valueTypeListElement
        );
    }

    if (that.value !== null) {
      const valueArray = new Array<JsonObject>();
      for (const item of that.value) {
        valueArray.push(
          this.transform(item)
        );
      }
      jsonable["value"] = valueArray;
    }

    jsonable["modelType"] = "SubmodelElementList";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformSubmodelElementCollection(
    that: AasTypes.SubmodelElementCollection
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.value !== null) {
      const valueArray = new Array<JsonObject>();
      for (const item of that.value) {
        valueArray.push(
          this.transform(item)
        );
      }
      jsonable["value"] = valueArray;
    }

    jsonable["modelType"] = "SubmodelElementCollection";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformProperty(
    that: AasTypes.Property
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    jsonable["valueType"] =
      AasStringification.mustDataTypeDefXsdToString(
        that.valueType
      );

    if (that.value !== null) {
      jsonable["value"] =
        that.value;
    }

    if (that.valueId !== null) {
      jsonable["valueId"] =
        this.transform(that.valueId);
    }

    jsonable["modelType"] = "Property";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformMultiLanguageProperty(
    that: AasTypes.MultiLanguageProperty
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.value !== null) {
      const valueArray = new Array<JsonObject>();
      for (const item of that.value) {
        valueArray.push(
          this.transform(item)
        );
      }
      jsonable["value"] = valueArray;
    }

    if (that.valueId !== null) {
      jsonable["valueId"] =
        this.transform(that.valueId);
    }

    jsonable["modelType"] = "MultiLanguageProperty";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformRange(
    that: AasTypes.Range
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    jsonable["valueType"] =
      AasStringification.mustDataTypeDefXsdToString(
        that.valueType
      );

    if (that.min !== null) {
      jsonable["min"] =
        that.min;
    }

    if (that.max !== null) {
      jsonable["max"] =
        that.max;
    }

    jsonable["modelType"] = "Range";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformReferenceElement(
    that: AasTypes.ReferenceElement
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.value !== null) {
      jsonable["value"] =
        this.transform(that.value);
    }

    jsonable["modelType"] = "ReferenceElement";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformBlob(
    that: AasTypes.Blob
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.value !== null) {
      jsonable["value"] =
        AasCommon.base64Encode(that.value);
    }

    jsonable["contentType"] =
      that.contentType;

    jsonable["modelType"] = "Blob";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformFile(
    that: AasTypes.File
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.value !== null) {
      jsonable["value"] =
        that.value;
    }

    jsonable["contentType"] =
      that.contentType;

    jsonable["modelType"] = "File";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformAnnotatedRelationshipElement(
    that: AasTypes.AnnotatedRelationshipElement
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    jsonable["first"] =
      this.transform(that.first);

    jsonable["second"] =
      this.transform(that.second);

    if (that.annotations !== null) {
      const annotationsArray = new Array<JsonObject>();
      for (const item of that.annotations) {
        annotationsArray.push(
          this.transform(item)
        );
      }
      jsonable["annotations"] = annotationsArray;
    }

    jsonable["modelType"] = "AnnotatedRelationshipElement";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEntity(
    that: AasTypes.Entity
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.statements !== null) {
      const statementsArray = new Array<JsonObject>();
      for (const item of that.statements) {
        statementsArray.push(
          this.transform(item)
        );
      }
      jsonable["statements"] = statementsArray;
    }

    jsonable["entityType"] =
      AasStringification.mustEntityTypeToString(
        that.entityType
      );

    if (that.globalAssetId !== null) {
      jsonable["globalAssetId"] =
        that.globalAssetId;
    }

    if (that.specificAssetIds !== null) {
      const specificAssetIdsArray = new Array<JsonObject>();
      for (const item of that.specificAssetIds) {
        specificAssetIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["specificAssetIds"] = specificAssetIdsArray;
    }

    jsonable["modelType"] = "Entity";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEventPayload(
    that: AasTypes.EventPayload
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["source"] =
      this.transform(that.source);

    if (that.sourceSemanticId !== null) {
      jsonable["sourceSemanticId"] =
        this.transform(that.sourceSemanticId);
    }

    jsonable["observableReference"] =
      this.transform(that.observableReference);

    if (that.observableSemanticId !== null) {
      jsonable["observableSemanticId"] =
        this.transform(that.observableSemanticId);
    }

    if (that.topic !== null) {
      jsonable["topic"] =
        that.topic;
    }

    if (that.subjectId !== null) {
      jsonable["subjectId"] =
        this.transform(that.subjectId);
    }

    jsonable["timeStamp"] =
      that.timeStamp;

    if (that.payload !== null) {
      jsonable["payload"] =
        AasCommon.base64Encode(that.payload);
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformBasicEventElement(
    that: AasTypes.BasicEventElement
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    jsonable["observed"] =
      this.transform(that.observed);

    jsonable["direction"] =
      AasStringification.mustDirectionToString(
        that.direction
      );

    jsonable["state"] =
      AasStringification.mustStateOfEventToString(
        that.state
      );

    if (that.messageTopic !== null) {
      jsonable["messageTopic"] =
        that.messageTopic;
    }

    if (that.messageBroker !== null) {
      jsonable["messageBroker"] =
        this.transform(that.messageBroker);
    }

    if (that.lastUpdate !== null) {
      jsonable["lastUpdate"] =
        that.lastUpdate;
    }

    if (that.minInterval !== null) {
      jsonable["minInterval"] =
        that.minInterval;
    }

    if (that.maxInterval !== null) {
      jsonable["maxInterval"] =
        that.maxInterval;
    }

    jsonable["modelType"] = "BasicEventElement";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformOperation(
    that: AasTypes.Operation
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.inputVariables !== null) {
      const inputVariablesArray = new Array<JsonObject>();
      for (const item of that.inputVariables) {
        inputVariablesArray.push(
          this.transform(item)
        );
      }
      jsonable["inputVariables"] = inputVariablesArray;
    }

    if (that.outputVariables !== null) {
      const outputVariablesArray = new Array<JsonObject>();
      for (const item of that.outputVariables) {
        outputVariablesArray.push(
          this.transform(item)
        );
      }
      jsonable["outputVariables"] = outputVariablesArray;
    }

    if (that.inoutputVariables !== null) {
      const inoutputVariablesArray = new Array<JsonObject>();
      for (const item of that.inoutputVariables) {
        inoutputVariablesArray.push(
          this.transform(item)
        );
      }
      jsonable["inoutputVariables"] = inoutputVariablesArray;
    }

    jsonable["modelType"] = "Operation";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformOperationVariable(
    that: AasTypes.OperationVariable
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["value"] =
      this.transform(that.value);

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformCapability(
    that: AasTypes.Capability
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.semanticId !== null) {
      jsonable["semanticId"] =
        this.transform(that.semanticId);
    }

    if (that.supplementalSemanticIds !== null) {
      const supplementalSemanticIdsArray = new Array<JsonObject>();
      for (const item of that.supplementalSemanticIds) {
        supplementalSemanticIdsArray.push(
          this.transform(item)
        );
      }
      jsonable["supplementalSemanticIds"] = supplementalSemanticIdsArray;
    }

    if (that.qualifiers !== null) {
      const qualifiersArray = new Array<JsonObject>();
      for (const item of that.qualifiers) {
        qualifiersArray.push(
          this.transform(item)
        );
      }
      jsonable["qualifiers"] = qualifiersArray;
    }

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    jsonable["modelType"] = "Capability";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformConceptDescription(
    that: AasTypes.ConceptDescription
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.extensions !== null) {
      const extensionsArray = new Array<JsonObject>();
      for (const item of that.extensions) {
        extensionsArray.push(
          this.transform(item)
        );
      }
      jsonable["extensions"] = extensionsArray;
    }

    if (that.category !== null) {
      jsonable["category"] =
        that.category;
    }

    if (that.idShort !== null) {
      jsonable["idShort"] =
        that.idShort;
    }

    if (that.displayName !== null) {
      const displayNameArray = new Array<JsonObject>();
      for (const item of that.displayName) {
        displayNameArray.push(
          this.transform(item)
        );
      }
      jsonable["displayName"] = displayNameArray;
    }

    if (that.description !== null) {
      const descriptionArray = new Array<JsonObject>();
      for (const item of that.description) {
        descriptionArray.push(
          this.transform(item)
        );
      }
      jsonable["description"] = descriptionArray;
    }

    if (that.administration !== null) {
      jsonable["administration"] =
        this.transform(that.administration);
    }

    jsonable["id"] =
      that.id;

    if (that.embeddedDataSpecifications !== null) {
      const embeddedDataSpecificationsArray = new Array<JsonObject>();
      for (const item of that.embeddedDataSpecifications) {
        embeddedDataSpecificationsArray.push(
          this.transform(item)
        );
      }
      jsonable["embeddedDataSpecifications"] = embeddedDataSpecificationsArray;
    }

    if (that.isCaseOf !== null) {
      const isCaseOfArray = new Array<JsonObject>();
      for (const item of that.isCaseOf) {
        isCaseOfArray.push(
          this.transform(item)
        );
      }
      jsonable["isCaseOf"] = isCaseOfArray;
    }

    jsonable["modelType"] = "ConceptDescription";

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformReference(
    that: AasTypes.Reference
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["type"] =
      AasStringification.mustReferenceTypesToString(
        that.type
      );

    if (that.referredSemanticId !== null) {
      jsonable["referredSemanticId"] =
        this.transform(that.referredSemanticId);
    }

    const keysArray = new Array<JsonObject>();
    for (const item of that.keys) {
      keysArray.push(
        this.transform(item)
      );
    }
    jsonable["keys"] = keysArray;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformKey(
    that: AasTypes.Key
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["type"] =
      AasStringification.mustKeyTypesToString(
        that.type
      );

    jsonable["value"] =
      that.value;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringNameType(
    that: AasTypes.LangStringNameType
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["language"] =
      that.language;

    jsonable["text"] =
      that.text;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringTextType(
    that: AasTypes.LangStringTextType
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["language"] =
      that.language;

    jsonable["text"] =
      that.text;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEnvironment(
    that: AasTypes.Environment
  ): JsonObject {
    const jsonable: JsonObject = {};

    if (that.assetAdministrationShells !== null) {
      const assetAdministrationShellsArray = new Array<JsonObject>();
      for (const item of that.assetAdministrationShells) {
        assetAdministrationShellsArray.push(
          this.transform(item)
        );
      }
      jsonable["assetAdministrationShells"] = assetAdministrationShellsArray;
    }

    if (that.submodels !== null) {
      const submodelsArray = new Array<JsonObject>();
      for (const item of that.submodels) {
        submodelsArray.push(
          this.transform(item)
        );
      }
      jsonable["submodels"] = submodelsArray;
    }

    if (that.conceptDescriptions !== null) {
      const conceptDescriptionsArray = new Array<JsonObject>();
      for (const item of that.conceptDescriptions) {
        conceptDescriptionsArray.push(
          this.transform(item)
        );
      }
      jsonable["conceptDescriptions"] = conceptDescriptionsArray;
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformEmbeddedDataSpecification(
    that: AasTypes.EmbeddedDataSpecification
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["dataSpecificationContent"] =
      this.transform(that.dataSpecificationContent);

    if (that.dataSpecification !== null) {
      jsonable["dataSpecification"] =
        this.transform(that.dataSpecification);
    }

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLevelType(
    that: AasTypes.LevelType
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["min"] =
      that.min;

    jsonable["nom"] =
      that.nom;

    jsonable["typ"] =
      that.typ;

    jsonable["max"] =
      that.max;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformValueReferencePair(
    that: AasTypes.ValueReferencePair
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["value"] =
      that.value;

    jsonable["valueId"] =
      this.transform(that.valueId);

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformValueList(
    that: AasTypes.ValueList
  ): JsonObject {
    const jsonable: JsonObject = {};

    const valueReferencePairsArray = new Array<JsonObject>();
    for (const item of that.valueReferencePairs) {
      valueReferencePairsArray.push(
        this.transform(item)
      );
    }
    jsonable["valueReferencePairs"] = valueReferencePairsArray;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringPreferredNameTypeIec61360(
    that: AasTypes.LangStringPreferredNameTypeIec61360
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["language"] =
      that.language;

    jsonable["text"] =
      that.text;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringShortNameTypeIec61360(
    that: AasTypes.LangStringShortNameTypeIec61360
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["language"] =
      that.language;

    jsonable["text"] =
      that.text;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformLangStringDefinitionTypeIec61360(
    that: AasTypes.LangStringDefinitionTypeIec61360
  ): JsonObject {
    const jsonable: JsonObject = {};

    jsonable["language"] =
      that.language;

    jsonable["text"] =
      that.text;

    return jsonable;
  }

  /**
   * Serialize `that` to a JSON-able representation.
   *
   * @param that - instance to be serialization
   * @returns JSON-able representation
   */
  transformDataSpecificationIec61360(
    that: AasTypes.DataSpecificationIec61360
  ): JsonObject {
    const jsonable: JsonObject = {};

    const preferredNameArray = new Array<JsonObject>();
    for (const item of that.preferredName) {
      preferredNameArray.push(
        this.transform(item)
      );
    }
    jsonable["preferredName"] = preferredNameArray;

    if (that.shortName !== null) {
      const shortNameArray = new Array<JsonObject>();
      for (const item of that.shortName) {
        shortNameArray.push(
          this.transform(item)
        );
      }
      jsonable["shortName"] = shortNameArray;
    }

    if (that.unit !== null) {
      jsonable["unit"] =
        that.unit;
    }

    if (that.unitId !== null) {
      jsonable["unitId"] =
        this.transform(that.unitId);
    }

    if (that.sourceOfDefinition !== null) {
      jsonable["sourceOfDefinition"] =
        that.sourceOfDefinition;
    }

    if (that.symbol !== null) {
      jsonable["symbol"] =
        that.symbol;
    }

    if (that.dataType !== null) {
      jsonable["dataType"] =
        AasStringification.mustDataTypeIec61360ToString(
          that.dataType
        );
    }

    if (that.definition !== null) {
      const definitionArray = new Array<JsonObject>();
      for (const item of that.definition) {
        definitionArray.push(
          this.transform(item)
        );
      }
      jsonable["definition"] = definitionArray;
    }

    if (that.valueFormat !== null) {
      jsonable["valueFormat"] =
        that.valueFormat;
    }

    if (that.valueList !== null) {
      jsonable["valueList"] =
        this.transform(that.valueList);
    }

    if (that.value !== null) {
      jsonable["value"] =
        that.value;
    }

    if (that.levelType !== null) {
      jsonable["levelType"] =
        this.transform(that.levelType);
    }

    jsonable["modelType"] = "DataSpecificationIec61360";

    return jsonable;
  }
}

const SERIALIZER = new Serializer();

/**
 * Convert `that` to a JSON-able structure.
 *
 * @param that - AAS data to be recursively converted to a JSON-able structure
 * @returns
 * JSON-able structure which can be further processed with, say,
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify|JSON.stringify})
 */
export function toJsonable(that: AasTypes.Class): JsonObject {
  return SERIALIZER.transform(that);
}

// endregion

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
