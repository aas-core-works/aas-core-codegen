/**
 * Verify that the instances of the meta-model satisfy the invariants.
 *
 * Here is an example how to verify an instance of {@link types.Extension}:
 *
 * ```ts
 * import * as AasTypes from "@aas-core-works/aas-core3.0rc02-typescript/types";
 * import * as AasVerification from "@aas-core-works/aas-core3.0rc02-typescript/verification";
 *
 * const anInstance = new AasTypes.Extension(
 *   // ... some constructor arguments ...
 * );
 *
 * for (const error of AasVerification.verify(anInstance)) {
 *   console.log(`${error.message} at: ${error.path}`);
 * }
 * ```
 */

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import * as AasCommon from "./common";
import * as AasConstants from "./constants";
import * as AasTypes from "./types";

/**
 * Represent a property access on a path to an erroneous value.
 */
export class PropertySegment {
  /**
   * Instance containing the property
   */
  readonly instance: AasTypes.Class;

  /**
   * Name of the property
   */
  readonly name: string;

  constructor(instance: AasTypes.Class, name: string) {
    this.instance = instance;
    this.name = name;
  }

  toString(): string {
    return `.${this.name}`;
  }
}

/**
 * Represent an index access on a path to an erroneous value.
 */
export class IndexSegment {
  /**
   * Sequence containing the item at {@link index}
   */
  readonly sequence: Array<AasTypes.Class>;

  /**
   * Index of the item in the {@link sequence}
   */
  readonly index: number;

  constructor(sequence: Array<AasTypes.Class>, index: number) {
    this.sequence = sequence;
    this.index = index;
  }

  toString(): string {
    return `[${this.index}]`;
  }
}

export type Segment = PropertySegment | IndexSegment;

/**
 * Represent the relative path to the erroneous value.
 */
export class Path {
  readonly segments: Array<Segment> = [];

  prepend(segment: Segment): void {
    this.segments.unshift(segment);
  }

  toString(): string {
    return this.segments.join("");
  }
}

/**
 * Represent a verification error in the data.
 */
export class VerificationError {
  // NOTE (mristin, 2022-11-12):
  // The name `VerificationError` is redundant since it lives in `verification` module,
  // and it would have made more sense to call it simply `Error`. Unfortunately in this case,
  // `Error` is a reserved name by JavaScript.

  /**
   * Human-readable description of the error
   */
  readonly message: string;

  /**
   * Path to the erroneous value
   */
  readonly path: Path = new Path();

  /**
   * Initialize with the given `message` and `path`.
   *
   * @remarks
   * If no `path` is specified, initialize with an empty path.
   */
  constructor(message: string, path: Path | null = null) {
    this.message = message;
    this.path = (path !== null)
      ? path
      : new Path();
  }
}

function constructMatchesIdShort(): RegExp {
  const pattern = "^[a-zA-Z][a-zA-Z0-9_]*$";

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_ID_SHORT = constructMatchesIdShort();

/**
 * Check that `text` is a valid short ID.
 */
export function matchesIdShort(text: string): boolean {
  return REGEXP_MATCHES_ID_SHORT.test(text);
}

function constructMatchesVersionType(): RegExp {
  const pattern = "^(0|[1-9][0-9]*)$";

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_VERSION_TYPE = constructMatchesVersionType();

/**
 * Check that `text` is a valid version string.
 */
export function matchesVersionType(text: string): boolean {
  return REGEXP_MATCHES_VERSION_TYPE.test(text);
}

function constructMatchesRevisionType(): RegExp {
  const pattern = "^(0|[1-9][0-9]*)$";

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_REVISION_TYPE = constructMatchesRevisionType();

/**
 * Check that `text` is a valid revision string.
 */
export function matchesRevisionType(text: string): boolean {
  return REGEXP_MATCHES_REVISION_TYPE.test(text);
}

function constructMatchesXsDateTimeUtc(): RegExp {
  const digit = "[0-9]";
  const yearFrag = `-?(([1-9]${digit}${digit}${digit}+)|(0${digit}${digit}${digit}))`;
  const monthFrag = "((0[1-9])|(1[0-2]))";
  const dayFrag = `((0[1-9])|([12]${digit})|(3[01]))`;
  const hourFrag = `(([01]${digit})|(2[0-3]))`;
  const minuteFrag = `[0-5]${digit}`;
  const secondFrag = `([0-5]${digit})(\\.${digit}+)?`;
  const endOfDayFrag = "24:00:00(\\.0+)?";
  const timezoneFrag = "(Z|\\+00:00|-00:00)";
  const dateTimeLexicalRep = `${yearFrag}-${monthFrag}-${dayFrag}T((${hourFrag}:${minuteFrag}:${secondFrag})|${endOfDayFrag})${timezoneFrag}`;
  const pattern = `^${dateTimeLexicalRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_DATE_TIME_UTC = constructMatchesXsDateTimeUtc();

/**
 * Check that `text` conforms to the pattern of an `xs:dateTime`.
 *
 * @remarks
 *
 * The time zone must be fixed to UTC. We verify only that the `text` matches
 * a pre-defined pattern. We *do not* verify that the day of month is
 * correct nor do we check for leap seconds.
 *
 * See: https://www.w3.org/TR/xmlschema-2/#dateTime
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsDateTimeUtc(text: string): boolean {
  return REGEXP_MATCHES_XS_DATE_TIME_UTC.test(text);
}

/**
 * Check that `value` is a valid `xs:dateTime` with
 * the time zone set to UTC.
 *
 * @param value - to be checked
 * @returns `true` if `value` is a valid `xs:dateTime` with the UTC time zone
 */
export function isXsDateTimeUtc(
  value: string
): boolean {
  if (!matchesXsDateTimeUtc(value)) {
    return false;
  }

  const date = value.split("T", 1)[0];
  return isXsDate(date);
}

function constructMatchesMimeType(): RegExp {
  const tchar = "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]";
  const token = `(${tchar})+`;
  const type = `${token}`;
  const subtype = `${token}`;
  const ows = "[ \\t]*";
  const obsText = "[\\u{80}-\\u{ff}]";
  const qdText = `([\\t !#-\\[\\]-~]|${obsText})`;
  const quotedPair = `\\\\([\\t !-~]|${obsText})`;
  const quotedString = `"(${qdText}|${quotedPair})*"`;
  const parameter = `${token}=(${token}|${quotedString})`;
  const mediaType = `^${type}/${subtype}(${ows};${ows}${parameter})*$`;

  return new RegExp(mediaType, "u");
}

const REGEXP_MATCHES_MIME_TYPE = constructMatchesMimeType();

/**
 * Check that `text` conforms to the pattern of MIME type.
 *
 * @remarks
 *
 * The definition has been taken from:
 * https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
 * https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
 * https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesMimeType(text: string): boolean {
  return REGEXP_MATCHES_MIME_TYPE.test(text);
}

function constructMatchesRfc8089Path(): RegExp {
  const h16 = "[0-9A-Fa-f]{1,4}";
  const decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
  const ipv4address = `${decOctet}\\.${decOctet}\\.${decOctet}\\.${decOctet}`;
  const ls32 = `(${h16}:${h16}|${ipv4address})`;
  const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:)?${h16})?::(${h16}:){3}${ls32}|((${h16}:){2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){3}${h16})?::${h16}:${ls32}|((${h16}:){4}${h16})?::${ls32}|((${h16}:){5}${h16})?::${h16}|((${h16}:){6}${h16})?::)`;
  const unreserved = "[a-zA-Z0-9\\-._~]";
  const subDelims = "[!$&'()*+,;=]";
  const ipvfuture = `[vV][0-9A-Fa-f]+\\.(${unreserved}|${subDelims}|:)+`;
  const ipLiteral = `\\[(${ipv6address}|${ipvfuture})\\]`;
  const pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
  const regName = `(${unreserved}|${pctEncoded}|${subDelims})*`;
  const host = `(${ipLiteral}|${ipv4address}|${regName})`;
  const fileAuth = `(localhost|${host})`;
  const pchar = `(${unreserved}|${pctEncoded}|${subDelims}|[:@])`;
  const segmentNz = `(${pchar})+`;
  const segment = `(${pchar})*`;
  const pathAbsolute = `/(${segmentNz}(/${segment})*)?`;
  const authPath = `(${fileAuth})?${pathAbsolute}`;
  const localPath = `${pathAbsolute}`;
  const fileHierPart = `(//${authPath}|${localPath})`;
  const fileScheme = "file";
  const fileUri = `${fileScheme}:${fileHierPart}`;
  const pattern = `^${fileUri}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_RFC_8089_PATH = constructMatchesRfc8089Path();

/**
 * Check that `text` is a path conforming to the pattern of RFC 8089.
 *
 * @remarks
 *
 * The definition has been taken from:
 * https://datatracker.ietf.org/doc/html/rfc8089
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesRfc8089Path(text: string): boolean {
  return REGEXP_MATCHES_RFC_8089_PATH.test(text);
}

function constructMatchesBcp47(): RegExp {
  const alphanum = "[a-zA-Z0-9]";
  const singleton = "[0-9A-WY-Za-wy-z]";
  const extension = `${singleton}(-(${alphanum}){2,8})+`;
  const extlang = "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}";
  const irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)";
  const regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)";
  const grandfathered = `(${irregular}|${regular})`;
  const language = `([a-zA-Z]{2,3}(-${extlang})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})`;
  const script = "[a-zA-Z]{4}";
  const region = "([a-zA-Z]{2}|[0-9]{3})";
  const variant = `((${alphanum}){5,8}|[0-9](${alphanum}){3})`;
  const privateuse = `[xX](-(${alphanum}){1,8})+`;
  const langtag = `${language}(-${script})?(-${region})?(-${variant})*(-${extension})*(-${privateuse})?`;
  const languageTag = `(${langtag}|${privateuse}|${grandfathered})`;
  const pattern = `^${languageTag}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_BCP_47 = constructMatchesBcp47();

/**
 * Check that `text` is a valid BCP 47 language tag.
 *
 * @remarks
 *
 * See: https://en.wikipedia.org/wiki/IETF_language_tag
 */
export function matchesBcp47(text: string): boolean {
  return REGEXP_MATCHES_BCP_47.test(text);
}

/**
 * Check that `langStrings` are specified each for a unique
 * language.
 *
 * @param langStrings - to be verified
 * @returns `true` if the check passes
 */
export function langStringsHaveUniqueLanguages(
  langStrings: Iterable<AasTypes.LangString>
): boolean {
  const languageSet = new Set<string>();

  for (const langString of langStrings) {
    if (languageSet.has(langString.language)) {
      return false;
    }

    languageSet.add(langString.language);
  }

  return true;
}

/**
 * Check that there are no duplication {@link types.Qualifier.type}'s
 * in the `qualifiers`.
 *
 * @param qualifiers - to be verified
 * @returns `true` if the check passes
 */
export function qualifierTypesAreUnique(
  qualifiers: Iterable<AasTypes.Qualifier>
): boolean {
  const typeSet = new Set<string>();

  for (const qualifier of qualifiers) {
    if (typeSet.has(qualifier.type)) {
      return false;
    }

    typeSet.add(qualifier.type);
  }

  return true;
}

function constructMatchesXmlSerializableString(): RegExp {
  const pattern = "^[\\u{9}\\u{a}\\u{d}\\u{20}-\\u{d7ff}\\u{e000}-\\u{fffd}\\u{10000}-\\u{10ffff}]*$";

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XML_SERIALIZABLE_STRING = constructMatchesXmlSerializableString();

/**
 * Check that `text` conforms to the pattern of the Constraint AASd-130.
 *
 * @remarks
 *
 * Ensures that encoding is possible and interoperability between different
 * serializations is possible.
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXmlSerializableString(text: string): boolean {
  return REGEXP_MATCHES_XML_SERIALIZABLE_STRING.test(text);
}

function constructMatchesXsAnyUri(): RegExp {
  const scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*";
  const ucschar = "[\\u{a0}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{ffef}\\u{10000}-\\u{1fffd}\\u{20000}-\\u{2fffd}\\u{30000}-\\u{3fffd}\\u{40000}-\\u{4fffd}\\u{50000}-\\u{5fffd}\\u{60000}-\\u{6fffd}\\u{70000}-\\u{7fffd}\\u{80000}-\\u{8fffd}\\u{90000}-\\u{9fffd}\\u{a0000}-\\u{afffd}\\u{b0000}-\\u{bfffd}\\u{c0000}-\\u{cfffd}\\u{d0000}-\\u{dfffd}\\u{e1000}-\\u{efffd}]";
  const iunreserved = `([a-zA-Z0-9\\-._~]|${ucschar})`;
  const pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
  const subDelims = "[!$&'()*+,;=]";
  const iuserinfo = `(${iunreserved}|${pctEncoded}|${subDelims}|:)*`;
  const h16 = "[0-9A-Fa-f]{1,4}";
  const decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
  const ipv4address = `${decOctet}\\.${decOctet}\\.${decOctet}\\.${decOctet}`;
  const ls32 = `(${h16}:${h16}|${ipv4address})`;
  const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:)?${h16})?::(${h16}:){3}${ls32}|((${h16}:){2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){3}${h16})?::${h16}:${ls32}|((${h16}:){4}${h16})?::${ls32}|((${h16}:){5}${h16})?::${h16}|((${h16}:){6}${h16})?::)`;
  const unreserved = "[a-zA-Z0-9\\-._~]";
  const ipvfuture = `[vV][0-9A-Fa-f]+\\.(${unreserved}|${subDelims}|:)+`;
  const ipLiteral = `\\[(${ipv6address}|${ipvfuture})\\]`;
  const iregName = `(${iunreserved}|${pctEncoded}|${subDelims})*`;
  const ihost = `(${ipLiteral}|${ipv4address}|${iregName})`;
  const port = "[0-9]*";
  const iauthority = `(${iuserinfo}@)?${ihost}(:${port})?`;
  const ipchar = `(${iunreserved}|${pctEncoded}|${subDelims}|[:@])`;
  const isegment = `(${ipchar})*`;
  const ipathAbempty = `(/${isegment})*`;
  const isegmentNz = `(${ipchar})+`;
  const ipathAbsolute = `/(${isegmentNz}(/${isegment})*)?`;
  const ipathRootless = `${isegmentNz}(/${isegment})*`;
  const ipathEmpty = `(${ipchar}){0}`;
  const ihierPart = `(//${iauthority}${ipathAbempty}|${ipathAbsolute}|${ipathRootless}|${ipathEmpty})`;
  const iprivate = "[\\u{e000}-\\u{f8ff}\\u{f0000}-\\u{ffffd}\\u{100000}-\\u{10fffd}]";
  const iquery = `(${ipchar}|${iprivate}|[/?])*`;
  const ifragment = `(${ipchar}|[/?])*`;
  const isegmentNzNc = `(${iunreserved}|${pctEncoded}|${subDelims}|@)+`;
  const ipathNoscheme = `${isegmentNzNc}(/${isegment})*`;
  const irelativePart = `(//${iauthority}${ipathAbempty}|${ipathAbsolute}|${ipathNoscheme}|${ipathEmpty})`;
  const irelativeRef = `${irelativePart}(\\?${iquery})?(#${ifragment})?`;
  const iri = `${scheme}:${ihierPart}(\\?${iquery})?(#${ifragment})?`;
  const iriReference = `(${iri}|${irelativeRef})`;
  const pattern = `^${iriReference}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_ANY_URI = constructMatchesXsAnyUri();

/**
 * Check that `text` conforms to the pattern of an `xs:anyURI`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#anyURI and
 * https://datatracker.ietf.org/doc/html/rfc3987
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsAnyUri(text: string): boolean {
  return REGEXP_MATCHES_XS_ANY_URI.test(text);
}

function constructMatchesXsBase64Binary(): RegExp {
  const b04Char = "[AQgw]";
  const b04 = `${b04Char}\\u{20}?`;
  const b16Char = "[AEIMQUYcgkosw048]";
  const b16 = `${b16Char}\\u{20}?`;
  const b64Char = "[A-Za-z0-9+/]";
  const b64 = `${b64Char}\\u{20}?`;
  const b64quad = `(${b64}${b64}${b64}${b64})`;
  const b64FinalQuad = `(${b64}${b64}${b64}${b64Char})`;
  const padded8 = `${b64}${b04}= ?=`;
  const padded16 = `${b64}${b64}${b16}=`;
  const b64final = `(${b64FinalQuad}|${padded16}|${padded8})`;
  const base64Binary = `(${b64quad}*${b64final})?`;
  const pattern = `^${base64Binary}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_BASE_64_BINARY = constructMatchesXsBase64Binary();

/**
 * Check that `text` conforms to the pattern of an `xs:base64Binary`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#base64Binary
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsBase64Binary(text: string): boolean {
  return REGEXP_MATCHES_XS_BASE_64_BINARY.test(text);
}

function constructMatchesXsBoolean(): RegExp {
  const pattern = "^(true|false|1|0)$";

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_BOOLEAN = constructMatchesXsBoolean();

/**
 * Check that `text` conforms to the pattern of an `xs:boolean`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#boolean
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsBoolean(text: string): boolean {
  return REGEXP_MATCHES_XS_BOOLEAN.test(text);
}

function constructMatchesXsDate(): RegExp {
  const digit = "[0-9]";
  const yearFrag = `-?(([1-9]${digit}${digit}${digit}+)|(0${digit}${digit}${digit}))`;
  const monthFrag = "((0[1-9])|(1[0-2]))";
  const dayFrag = `((0[1-9])|([12]${digit})|(3[01]))`;
  const minuteFrag = `[0-5]${digit}`;
  const timezoneFrag = `(Z|(\\+|-)(0${digit}|1[0-3]):${minuteFrag}|14:00)`;
  const dateLexicalRep = `${yearFrag}-${monthFrag}-${dayFrag}${timezoneFrag}?`;
  const pattern = `^${dateLexicalRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_DATE = constructMatchesXsDate();

/**
 * Check that `text` conforms to the pattern of an `xs:date`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#date
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsDate(text: string): boolean {
  return REGEXP_MATCHES_XS_DATE.test(text);
}

function constructMatchesXsDateTime(): RegExp {
  const digit = "[0-9]";
  const yearFrag = `-?(([1-9]${digit}${digit}${digit}+)|(0${digit}${digit}${digit}))`;
  const monthFrag = "((0[1-9])|(1[0-2]))";
  const dayFrag = `((0[1-9])|([12]${digit})|(3[01]))`;
  const hourFrag = `(([01]${digit})|(2[0-3]))`;
  const minuteFrag = `[0-5]${digit}`;
  const secondFrag = `([0-5]${digit})(\\.${digit}+)?`;
  const endOfDayFrag = "24:00:00(\\.0+)?";
  const timezoneFrag = `(Z|(\\+|-)(0${digit}|1[0-3]):${minuteFrag}|14:00)`;
  const dateTimeLexicalRep = `${yearFrag}-${monthFrag}-${dayFrag}T((${hourFrag}:${minuteFrag}:${secondFrag})|${endOfDayFrag})${timezoneFrag}?`;
  const pattern = `^${dateTimeLexicalRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_DATE_TIME = constructMatchesXsDateTime();

/**
 * Check that `text` conforms to the pattern of an `xs:dateTime`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#dateTime
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsDateTime(text: string): boolean {
  return REGEXP_MATCHES_XS_DATE_TIME.test(text);
}

/**
 * Check that `value` is a valid `xs:dateTime`.
 *
 * @remarks
 * Year 1 BCE is the last leap BCE year.
 * See https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:dateTime`
 */
export function isXsDateTime(value: string): boolean {
  // NOTE (mristin, 2022-11-23):
  // We can not use date functions from the standard library as it does not
  // handle years BCE (*e.g.*, `-0003-01-02`).

  if (!matchesXsDateTime(value)) {
    return false;
  }

  const date = value.split("T", 1)[0];
  return isXsDate(date);
}

function constructMatchesXsDecimal(): RegExp {
  const digit = "[0-9]";
  const unsignedNoDecimalPtNumeral = `${digit}+`;
  const noDecimalPtNumeral = `(\\+|-)?${unsignedNoDecimalPtNumeral}`;
  const fracFrag = `${digit}+`;
  const unsignedDecimalPtNumeral = `(${unsignedNoDecimalPtNumeral}\\.${fracFrag}|\\.${fracFrag})`;
  const decimalPtNumeral = `(\\+|-)?${unsignedDecimalPtNumeral}`;
  const decimalLexicalRep = `(${decimalPtNumeral}|${noDecimalPtNumeral})`;
  const pattern = `^${decimalLexicalRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_DECIMAL = constructMatchesXsDecimal();

/**
 * Check that `text` conforms to the pattern of an `xs:decimal`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#decimal
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsDecimal(text: string): boolean {
  return REGEXP_MATCHES_XS_DECIMAL.test(text);
}

function constructMatchesXsDouble(): RegExp {
  const doubleRep = "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)";
  const pattern = `^${doubleRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_DOUBLE = constructMatchesXsDouble();

/**
 * Check that `text` conforms to the pattern of an `xs:double`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#double
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsDouble(text: string): boolean {
  return REGEXP_MATCHES_XS_DOUBLE.test(text);
}

function constructMatchesXsDuration(): RegExp {
  const durationRep = "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))";
  const pattern = `^${durationRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_DURATION = constructMatchesXsDuration();

/**
 * Check that `text` conforms to the pattern of an `xs:duration`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#duration
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsDuration(text: string): boolean {
  return REGEXP_MATCHES_XS_DURATION.test(text);
}

function constructMatchesXsFloat(): RegExp {
  const floatRep = "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)";
  const pattern = `^${floatRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_FLOAT = constructMatchesXsFloat();

/**
 * Check that `text` conforms to the pattern of an `xs:float`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#float
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsFloat(text: string): boolean {
  return REGEXP_MATCHES_XS_FLOAT.test(text);
}

function constructMatchesXsGDay(): RegExp {
  const gDayLexicalRep = "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
  const pattern = `^${gDayLexicalRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_G_DAY = constructMatchesXsGDay();

/**
 * Check that `text` conforms to the pattern of an `xs:gDay`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gDay
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsGDay(text: string): boolean {
  return REGEXP_MATCHES_XS_G_DAY.test(text);
}

function constructMatchesXsGMonth(): RegExp {
  const gMonthLexicalRep = "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
  const pattern = `^${gMonthLexicalRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_G_MONTH = constructMatchesXsGMonth();

/**
 * Check that `text` conforms to the pattern of an `xs:gMonth`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gMonth
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsGMonth(text: string): boolean {
  return REGEXP_MATCHES_XS_G_MONTH.test(text);
}

function constructMatchesXsGMonthDay(): RegExp {
  const gMonthDayRep = "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
  const pattern = `^${gMonthDayRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_G_MONTH_DAY = constructMatchesXsGMonthDay();

/**
 * Check that `text` conforms to the pattern of an `xs:gMonthDay`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gMonthDay
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsGMonthDay(text: string): boolean {
  return REGEXP_MATCHES_XS_G_MONTH_DAY.test(text);
}

function constructMatchesXsGYear(): RegExp {
  const gYearRep = "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
  const pattern = `^${gYearRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_G_YEAR = constructMatchesXsGYear();

/**
 * Check that `text` conforms to the pattern of an `xs:gYear`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gYear
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsGYear(text: string): boolean {
  return REGEXP_MATCHES_XS_G_YEAR.test(text);
}

function constructMatchesXsGYearMonth(): RegExp {
  const gYearMonthRep = "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
  const pattern = `^${gYearMonthRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_G_YEAR_MONTH = constructMatchesXsGYearMonth();

/**
 * Check that `text` conforms to the pattern of an `xs:gYearMonth`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#gYearMonth
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsGYearMonth(text: string): boolean {
  return REGEXP_MATCHES_XS_G_YEAR_MONTH.test(text);
}

function constructMatchesXsHexBinary(): RegExp {
  const hexBinary = "([0-9a-fA-F]{2})*";
  const pattern = `^${hexBinary}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_HEX_BINARY = constructMatchesXsHexBinary();

/**
 * Check that `text` conforms to the pattern of an `xs:hexBinary`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#hexBinary
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsHexBinary(text: string): boolean {
  return REGEXP_MATCHES_XS_HEX_BINARY.test(text);
}

function constructMatchesXsTime(): RegExp {
  const timeRep = "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
  const pattern = `^${timeRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_TIME = constructMatchesXsTime();

/**
 * Check that `text` conforms to the pattern of an `xs:time`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#time
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsTime(text: string): boolean {
  return REGEXP_MATCHES_XS_TIME.test(text);
}

function constructMatchesXsInteger(): RegExp {
  const integerRep = "[-+]?[0-9]+";
  const pattern = `^${integerRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_INTEGER = constructMatchesXsInteger();

/**
 * Check that `text` conforms to the pattern of an `xs:integer`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#integer
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsInteger(text: string): boolean {
  return REGEXP_MATCHES_XS_INTEGER.test(text);
}

function constructMatchesXsLong(): RegExp {
  const longRep = "[-+]?0*[0-9]{1,20}";
  const pattern = `^${longRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_LONG = constructMatchesXsLong();

/**
 * Check that `text` conforms to the pattern of an `xs:long`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#long
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsLong(text: string): boolean {
  return REGEXP_MATCHES_XS_LONG.test(text);
}

function constructMatchesXsInt(): RegExp {
  const intRep = "[-+]?0*[0-9]{1,10}";
  const pattern = `^${intRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_INT = constructMatchesXsInt();

/**
 * Check that `text` conforms to the pattern of an `xs:int`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#int
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsInt(text: string): boolean {
  return REGEXP_MATCHES_XS_INT.test(text);
}

function constructMatchesXsShort(): RegExp {
  const shortRep = "[-+]?0*[0-9]{1,5}";
  const pattern = `^${shortRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_SHORT = constructMatchesXsShort();

/**
 * Check that `text` conforms to the pattern of an `xs:short`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#short
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsShort(text: string): boolean {
  return REGEXP_MATCHES_XS_SHORT.test(text);
}

function constructMatchesXsByte(): RegExp {
  const byteRep = "[-+]?0*[0-9]{1,3}";
  const pattern = `^${byteRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_BYTE = constructMatchesXsByte();

/**
 * Check that `text` conforms to the pattern of an `xs:byte`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#byte
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsByte(text: string): boolean {
  return REGEXP_MATCHES_XS_BYTE.test(text);
}

function constructMatchesXsNonNegativeInteger(): RegExp {
  const nonNegativeIntegerRep = "(-0|\\+?[0-9]+)";
  const pattern = `^${nonNegativeIntegerRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_NON_NEGATIVE_INTEGER = constructMatchesXsNonNegativeInteger();

/**
 * Check that `text` conforms to the pattern of an `xs:nonNegativeInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsNonNegativeInteger(text: string): boolean {
  return REGEXP_MATCHES_XS_NON_NEGATIVE_INTEGER.test(text);
}

function constructMatchesXsPositiveInteger(): RegExp {
  const positiveIntegerRep = "\\+?0*[1-9][0-9]*";
  const pattern = `^${positiveIntegerRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_POSITIVE_INTEGER = constructMatchesXsPositiveInteger();

/**
 * Check that `text` conforms to the pattern of an `xs:positiveInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#positiveInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsPositiveInteger(text: string): boolean {
  return REGEXP_MATCHES_XS_POSITIVE_INTEGER.test(text);
}

function constructMatchesXsUnsignedLong(): RegExp {
  const unsignedLongRep = "(-0|\\+?0*[0-9]{1,20})";
  const pattern = `^${unsignedLongRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_UNSIGNED_LONG = constructMatchesXsUnsignedLong();

/**
 * Check that `text` conforms to the pattern of an `xs:unsignedLong`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedLong
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsUnsignedLong(text: string): boolean {
  return REGEXP_MATCHES_XS_UNSIGNED_LONG.test(text);
}

function constructMatchesXsUnsignedInt(): RegExp {
  const unsignedIntRep = "(-0|\\+?0*[0-9]{1,10})";
  const pattern = `^${unsignedIntRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_UNSIGNED_INT = constructMatchesXsUnsignedInt();

/**
 * Check that `text` conforms to the pattern of an `xs:unsignedInt`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedInt
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsUnsignedInt(text: string): boolean {
  return REGEXP_MATCHES_XS_UNSIGNED_INT.test(text);
}

function constructMatchesXsUnsignedShort(): RegExp {
  const unsignedShortRep = "(-0|\\+?0*[0-9]{1,5})";
  const pattern = `^${unsignedShortRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_UNSIGNED_SHORT = constructMatchesXsUnsignedShort();

/**
 * Check that `text` conforms to the pattern of an `xs:unsignedShort`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedShort
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsUnsignedShort(text: string): boolean {
  return REGEXP_MATCHES_XS_UNSIGNED_SHORT.test(text);
}

function constructMatchesXsUnsignedByte(): RegExp {
  const unsignedByteRep = "(-0|\\+?0*[0-9]{1,3})";
  const pattern = `^${unsignedByteRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_UNSIGNED_BYTE = constructMatchesXsUnsignedByte();

/**
 * Check that `text` conforms to the pattern of an `xs:unsignedByte`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#unsignedByte
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsUnsignedByte(text: string): boolean {
  return REGEXP_MATCHES_XS_UNSIGNED_BYTE.test(text);
}

function constructMatchesXsNonPositiveInteger(): RegExp {
  const nonPositiveIntegerRep = "(\\+0|0|-[0-9]+)";
  const pattern = `^${nonPositiveIntegerRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_NON_POSITIVE_INTEGER = constructMatchesXsNonPositiveInteger();

/**
 * Check that `text` conforms to the pattern of an `xs:nonPositiveInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsNonPositiveInteger(text: string): boolean {
  return REGEXP_MATCHES_XS_NON_POSITIVE_INTEGER.test(text);
}

function constructMatchesXsNegativeInteger(): RegExp {
  const negativeIntegerRep = "(-0*[1-9][0-9]*)";
  const pattern = `^${negativeIntegerRep}$`;

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_NEGATIVE_INTEGER = constructMatchesXsNegativeInteger();

/**
 * Check that `text` conforms to the pattern of an `xs:negativeInteger`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#negativeInteger
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsNegativeInteger(text: string): boolean {
  return REGEXP_MATCHES_XS_NEGATIVE_INTEGER.test(text);
}

function constructMatchesXsString(): RegExp {
  const pattern = "^[\\u{9}\\u{a}\\u{d}\\u{20}-\\u{d7ff}\\u{e000}-\\u{fffd}\\u{10000}-\\u{10ffff}]*$";

  return new RegExp(pattern, "u");
}

const REGEXP_MATCHES_XS_STRING = constructMatchesXsString();

/**
 * Check that `text` conforms to the pattern of an `xs:string`.
 *
 * @remarks
 *
 * See: https://www.w3.org/TR/xmlschema-2/#string
 *
 * @param text - Text to be checked
 *
 * @returns True if the `text` conforms to the pattern
 */
export function matchesXsString(text: string): boolean {
  return REGEXP_MATCHES_XS_STRING.test(text);
}

/**
 * Check if `year` is a leap year.
 *
 * @remarks
 * Year 1 BCE is the last leap BCE year.
 * See https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * @param year - to be checked
 * @returns `true` if `year` is a leap year.
 */
export function isLeapYear(year: number): boolean {
  // We consider the years B.C. to be one-off.
  //
  // See the note at: https://www.w3.org/TR/xmlschema-2///dateTime:
  // "'-0001' is the lexical representation of the year 1 Before Common Era
  // (1 BCE, sometimes written "1 BC")."
  //
  // Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
  if (year < 0) {
    year = -year - 1;
  }

  // See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
  if (year % 4 > 0) {
    return false;
  }

  if (year % 100 > 0) {
    return true;
  }

  if (year % 400 > 0) {
    return false;
  }

  return true;
}

const DAYS_IN_MONTH = new Map<number, number>(
  [
    [1, 31],
    // Please use isLeapYear if you need to check
    // whether a concrete February has 28 or 29 days.
    [2, 29],
    [3, 31],
    [4, 30],
    [5, 31],
    [6, 30],
    [7, 31],
    [8, 31],
    [9, 30],
    [10, 31],
    [11, 30],
    [12, 31]
  ]
);

const DATE_PREFIX_RE = new RegExp("^(-?[0-9]+)-([0-9]{2})-([0-9]{2})");

/**
 * Check that `value` is a valid `xs:date`.
 *
 * @remarks
 * Year 1 BCE is the last leap BCE year.
 * See https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:date`
 */
export function isXsDate(value: string): boolean {
  // NOTE (mristin, 2022-11-23):
  // We can not use date functions from the standard library as it does not
  // handle years BCE (*e.g.*, `-0003-01-02`).

  if (!matchesXsDate(value)) {
    return false;
  }

  // NOTE (mristin, 2022-11-23):
  // We need to match the prefix as zone offsets are allowed in the dates. Optimally,
  // we would re-use the pattern matching from `matchesXsDate`, but this
  // would make the code generation and constraint inference for schemas much more
  // difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code
  // generation.

  const match = DATE_PREFIX_RE.exec(value);

  const year = parseInt(match[1], 10);
  const month = parseInt(match[2], 10);
  const day = parseInt(match[3], 10);

  // We do not accept year zero,
  // see the note at: https://www.w3.org/TR/xmlschema-2/#dateTime
  if (year === 0) {
    return false;
  }

  if (day <= 0) {
    return false;
  }

  if (month <= 0 || month >= 13) {
    return false;
  }

  const maxDays = (month === 2)
    ? (isLeapYear(year) ? 29 : 28)
    : DAYS_IN_MONTH.get(month);

  if (day > maxDays) {
    return false;
  }

  return true;
}

/**
 * Check that `value` is a valid `xs:double`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:double`
 */
export function isXsDouble(value: string): boolean {
  // NOTE (mristin, 2022-11-23):
  // We need to check explicitly for the regular expression since
  // `parseFloat` expects `Infinity`  instead of `INF`.
  if (!matchesXsDouble(value)) {
    return false;
  }

  if (value !== "INF" && value !== "-INF" && value !== "NaN") {
    // NOTE (mristin, 2022-11-23):
    // Check that the value is not too big to be represented as a double-precision
    // floating point number.
    //
    // For example, `parseFloat("1e400")` gives `Infinity`.
    const converted = parseFloat(value);

    if (!isFinite(converted)) {
      return false;
    }
  }

  return true;
}

/**
 * Check that `value` is a valid `xs:float`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:float`
 */
export function isXsFloat(value: string): boolean {
  // NOTE (mristin, 2022-11-23):
  // We need to check explicitly for the regular expression since
  // `parseFloat` expects `Infinity`  instead of `INF`.
  if (!matchesXsFloat(value)) {
    return false;
  }

  if (value !== "INF" && value !== "-INF" && value !== "NaN") {
    // NOTE (mristin, 2022-11-23):
    // Check that the value is not too big to be represented as a double-precision
    // floating point number.
    //
    // For example, `parseFloat("1e400")` gives `Infinity`.
    const converted = parseFloat(value);

    if (!isFinite(converted)) {
      return false;
    }

    // NOTE (mristin, 2022-11-23):
    // TypeScript represents numbers as 64-bit floating point numbers. While there
    // is no easy way to deal with the precision, as precision is silently
    // gutted during the parsing, we can still check if the number is too large
    // to fit in a 32-bit float.
    const rounded = Math.fround(converted);
    if (!isFinite(rounded)) {
      return false;
    }
  }

  return true;
}

/**
 * Check that `value` is a valid `xs:gMonthDay`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:gMonthDay`
 */
export function isXsGMonthDay(value: string): boolean {
  if (!matchesXsGMonthDay(value)) {
    return false;
  }

  const month = parseInt(value.substring(2, 4), 10);
  const day = parseInt(value.substring(5, 7), 10);

  const maxDays = DAYS_IN_MONTH.get(month);
  return day <= maxDays;
}

const LONG_RE = new RegExp("^([\-+])?0*([0-9]{1,20})$");

const SMALLEST_LONG_WITHOUT_SIGN_AS_STRING = "9223372036854775808";
const LARGEST_LONG_AS_STRING = "9223372036854775807";

/**
 * Check that `value` is a valid `xs:long`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:long`
 */
export function isXsLong(value: string): boolean {
  // NOTE (mristin, 2022-11-23):
  // We need to operate on the value as string since TypeScript represents numbers as
  // 64-bit floating-point numbers which can not capture 64-bit integers.

  const match = value.match(LONG_RE);
  if (!match) {
    return false;
  }

  const numberPart = match[2];

  const limit = (match[1] === "-")
    ? SMALLEST_LONG_WITHOUT_SIGN_AS_STRING
    : LARGEST_LONG_AS_STRING;

  if (numberPart.length < limit.length) {
    return true;
  }

  if (numberPart.length > limit.length) {
    return false;
  }

  for (let i = numberPart.length - 1; i >= 0; i--) {
    const thisDigit = numberPart.charCodeAt(i);
    const limitDigit = limit.charCodeAt(i);

    if (thisDigit > limitDigit) {
      return false;
    } else if (thisDigit < limitDigit) {
      return true;
    } else {
      // Pass, we have to compare against the next digit from the left.
    }
  }

  // The number is exactly the limit.
  return true;
}

/**
 * Check that `value` is a valid `xs:int`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:int`
 */
export function isXsInt(value: string): boolean {
  if (!matchesXsInt(value)) {
    return false;
  }

  const converted = parseInt(value, 10);
  return -2147483648 <= converted && converted <= 2147483647;
}

/**
 * Check that `value` is a valid `xs:short`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:short`
 */
export function isXsShort(value: string): boolean {
  if (!matchesXsShort(value)) {
    return false;
  }

  const converted = parseInt(value, 10);
  return -32768 <= converted && converted <= 32767;
}

/**
 * Check that `value` is a valid `xs:byte`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:byte`
 */
export function isXsByte(value: string): boolean {
  if (!matchesXsByte(value)) {
    return false;
  }

  const converted = parseInt(value, 10);
  return -128 <= converted && converted <= 127;
}

const UNSIGNED_LONG_RE = new RegExp("^(-0|\\+?0*([0-9]{1,20}))$");

const LARGEST_UNSIGNED_LONG_AS_STRING = "18446744073709551615";

/**
 * Check that `value` is a valid `xs:unsignedLong`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedLong`
 */
export function isXsUnsignedLong(value: string): boolean {
  // NOTE (mristin, 2022-11-23):
  // We need to operate on the value as string since TypeScript represents numbers as
  // 64-bit floating-point numbers which can not capture 64-bit integers.

  const match = value.match(UNSIGNED_LONG_RE);
  if (!match) {
    return false;
  }

  const numberPart = match[2];

  if (numberPart.length < LARGEST_UNSIGNED_LONG_AS_STRING.length) {
    return true;
  }

  if (numberPart.length > LARGEST_UNSIGNED_LONG_AS_STRING.length) {
    return false;
  }

  for (let i = numberPart.length - 1; i >= 0; i--) {
    const thisDigit = numberPart.charCodeAt(i);
    const limitDigit = LARGEST_UNSIGNED_LONG_AS_STRING.charCodeAt(i);

    if (thisDigit > limitDigit) {
      return false;
    } else if (thisDigit < limitDigit) {
      return true;
    } else {
      // Pass, we have to compare against the next digit from the left.
    }
  }

  // The number is exactly the limit.
  return true;
}

/**
 * Check that `value` is a valid `xs:unsignedInt`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedInt`
 */
export function isXsUnsignedInt(value: string): boolean {
  if (!matchesXsUnsignedInt(value)) {
    return false;
  }

  const converted = parseInt(value, 10);
  return 0 <= converted && converted <= 4294967295;
}

/**
 * Check that `value` is a valid `xs:unsignedShort`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedShort`
 */
export function isXsUnsignedShort(value: string): boolean {
  if (!matchesXsUnsignedShort(value)) {
    return false;
  }

  const converted = parseInt(value, 10);
  return 0 <= converted && converted <= 65535;
}

/**
 * Check that `value` is a valid `xs:unsignedByte`.
 *
 * @param value - to be be checked
 * @returns `true` if `value` is a valid `xs:unsignedByte`
 */
export function isXsUnsignedByte(value: string): boolean {
  if (!matchesXsUnsignedByte(value)) {
    return false;
  }

  const converted = parseInt(value, 10);
  return 0 <= converted && converted <= 255;
}


const DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY =
  new Map<AasTypes.DataTypeDefXsd, (string) => boolean>(
  [
    [AasTypes.DataTypeDefXsd.AnyUri, matchesXsAnyUri],
    [AasTypes.DataTypeDefXsd.Base64Binary, matchesXsBase64Binary],
    [AasTypes.DataTypeDefXsd.Boolean, matchesXsBoolean],
    [AasTypes.DataTypeDefXsd.Byte, isXsByte],
    [AasTypes.DataTypeDefXsd.Date, isXsDate],
    [AasTypes.DataTypeDefXsd.DateTime, isXsDateTime],
    [AasTypes.DataTypeDefXsd.Decimal, matchesXsDecimal],
    [AasTypes.DataTypeDefXsd.Double, isXsDouble],
    [AasTypes.DataTypeDefXsd.Duration, matchesXsDuration],
    [AasTypes.DataTypeDefXsd.Float, isXsFloat],
    [AasTypes.DataTypeDefXsd.GDay, matchesXsGDay],
    [AasTypes.DataTypeDefXsd.GMonth, matchesXsGMonth],
    [AasTypes.DataTypeDefXsd.GMonthDay, isXsGMonthDay],
    [AasTypes.DataTypeDefXsd.GYear, matchesXsGYear],
    [AasTypes.DataTypeDefXsd.GYearMonth, matchesXsGYearMonth],
    [AasTypes.DataTypeDefXsd.HexBinary, matchesXsHexBinary],
    [AasTypes.DataTypeDefXsd.Int, isXsInt],
    [AasTypes.DataTypeDefXsd.Integer, matchesXsInteger],
    [AasTypes.DataTypeDefXsd.Long, isXsLong],
    [AasTypes.DataTypeDefXsd.NegativeInteger, matchesXsNegativeInteger],
    [AasTypes.DataTypeDefXsd.NonNegativeInteger, matchesXsNonNegativeInteger],
    [AasTypes.DataTypeDefXsd.NonPositiveInteger, matchesXsNonPositiveInteger],
    [AasTypes.DataTypeDefXsd.PositiveInteger, matchesXsPositiveInteger],
    [AasTypes.DataTypeDefXsd.Short, isXsShort],
    [AasTypes.DataTypeDefXsd.String, matchesXsString],
    [AasTypes.DataTypeDefXsd.Time, matchesXsTime],
    [AasTypes.DataTypeDefXsd.UnsignedByte, isXsUnsignedByte],
    [AasTypes.DataTypeDefXsd.UnsignedInt, isXsUnsignedInt],
    [AasTypes.DataTypeDefXsd.UnsignedLong, isXsUnsignedLong],
    [AasTypes.DataTypeDefXsd.UnsignedShort, isXsUnsignedShort],
  ]);

function assertAllDataTypeDefXsdCovered() {
  for (const literal of AasTypes.overDataTypeDefXsd()) {
    if (!DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY.has(literal)) {
      throw new Error(
        `The enumeration key ${literal} of AasTypes.DataTypeDefXsd ` +
          "is not covered in DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY"
      );
    }
  }
}
assertAllDataTypeDefXsdCovered();

/**
 * Check that `value` is consistent with the given `valueType`.
 *
 * @param value - expected to be consistent with `valueType`
 * @param valueType - expected XSD type of `value`
 * @returns `true` if `value` consistent with `valueType`
 */
export function valueConsistentWithXsdType(
  value: string,
  valueType: AasTypes.DataTypeDefXsd
): boolean {
  const verifier = DATA_TYPE_DEF_XSD_TO_VALUE_CONSISTENCY.get(valueType);
  if (verifier === undefined) {
    throw new Error(
      "The value type is invalid. Expected a literal of DataTypeDefXsd, " +
      `but got: ${valueType}`
    );
  }
  return verifier(value);
}

/**
 * Check that the target of the model reference matches the `expectedType`.
 */
export function isModelReferenceTo(
  reference: AasTypes.Reference,
  expectedType: AasTypes.KeyTypes
): boolean {
  return (
    (
      reference.type == AasTypes.ReferenceTypes.ModelReference
      && reference.keys.length != 0
      && AasCommon.at(reference.keys, -1).type == expectedType
    ));
}

/**
 * Check that the target of the reference matches a {@link constants!AAS_REFERABLES}.
 */
export function isModelReferenceToReferable(
  reference: AasTypes.Reference
): boolean {
  return (
    (
      reference.type == AasTypes.ReferenceTypes.ModelReference
      && reference.keys.length != 0
      && (AasConstants.AAS_REFERABLES.has(AasCommon.at(reference.keys, -1).type))
    ));
}

/**
 * Check that all {@link types.IReferable.idShort}'s are unique
 * among `referables`.
 *
 * @param referables - to be verified
 * @returns `true` if the check passes
 */
export function idShortsAreUnique(
  referables: Iterable<AasTypes.IReferable>
): boolean {
  const idShortSet = new Set<string>();
  for (const referable of referables) {
    if (idShortSet.has(referable.idShort)) {
      return false;
    }

    idShortSet.add(referable.idShort);
  }

  return true;
}

/**
 * Check that all {@link types.IReferable.idShort}'s are unique
 * among `inputVariables`, `outputVariables` and `inoutputVariables`.
 *
 * @param referables - to be verified
 * @returns `true` if the check passes
 */
export function idShortsOfVariablesAreUnique(
  inputVariables: Iterable<AasTypes.IReferable> | null,
  outputVariables: Iterable<AasTypes.IReferable> | null,
  inoutputVariables: Iterable<AasTypes.IReferable> | null,
): boolean {
  const idShortSet = new Set<string>();

  for (const variable of inputVariables) {
    if (idShortSet.has(variable.idShort)) {
      return false;
    }

    idShortSet.add(variable.idShort);
  }

  for (const variable of outputVariables) {
    if (idShortSet.has(variable.idShort)) {
      return false;
    }

    idShortSet.add(variable.idShort);
  }

  for (const variable of inoutputVariables) {
    if (idShortSet.has(variable.idShort)) {
      return false;
    }

    idShortSet.add(variable.idShort);
  }

  return true;
}

/**
 * Check that all {@link types.Extension.name} are unique
 * among `extensions`.
 *
 * @param extensions - to be verified
 * @returns `true` if the check passes
 */
export function extensionNamesAreUnique(
  extensions: Iterable<AasTypes.Extension>
): boolean {
  const nameSet = new Set<string>();
  for (const extension of extensions) {
    if (nameSet.has(extension.name)) {
      return false;
    }

    nameSet.add(extension.name);
  }

  return true;
}

/**
 * Check that all `elements` have the identical
 * {@link types.ISubmodelElement.semanticId}.
 *
 * @param elements - to be checked
 * @returns `true` if all the semantic IDs are identical
 */
export function submodelElementsHaveIdenticalSemanticIds(
  elements: Iterable<AasTypes.ISubmodelElement>
): boolean {
  let thatSemanticId: AasTypes.Reference | null = null;
  for (const element of elements) {
    if (element.semanticId === null) {
      continue;
    }

    if (thatSemanticId === null) {
      thatSemanticId = element.semanticId;
      continue;
    }

    const thisSemanticId = element.semanticId;

    if (thisSemanticId.keys.length != thatSemanticId.keys.length) {
      return false;
    }

    for (let i = 0; i < thatSemanticId.keys.length; i++) {
      if (thisSemanticId.keys[i].value !== thatSemanticId.keys[i].value) {
        return false;
      }
    }
  }

  return true;
}

const AAS_SUBMODEL_ELEMENTS_TO_IS =
  new Map<AasTypes.AasSubmodelElements, (that: AasTypes.Class) => boolean>(
    [
      [
        AasTypes.AasSubmodelElements.AnnotatedRelationshipElement,
        AasTypes.isAnnotatedRelationshipElement
      ],
      [
        AasTypes.AasSubmodelElements.BasicEventElement,
        AasTypes.isBasicEventElement
      ],
      [
        AasTypes.AasSubmodelElements.Blob,
        AasTypes.isBlob
      ],
      [
        AasTypes.AasSubmodelElements.Capability,
        AasTypes.isCapability
      ],
      [
        AasTypes.AasSubmodelElements.DataElement,
        AasTypes.isDataElement
      ],
      [
        AasTypes.AasSubmodelElements.Entity,
        AasTypes.isEntity
      ],
      [
        AasTypes.AasSubmodelElements.EventElement,
        AasTypes.isEventElement
      ],
      [
        AasTypes.AasSubmodelElements.File,
        AasTypes.isFile
      ],
      [
        AasTypes.AasSubmodelElements.MultiLanguageProperty,
        AasTypes.isMultiLanguageProperty
      ],
      [
        AasTypes.AasSubmodelElements.Operation,
        AasTypes.isOperation
      ],
      [
        AasTypes.AasSubmodelElements.Property,
        AasTypes.isProperty
      ],
      [
        AasTypes.AasSubmodelElements.Range,
        AasTypes.isRange
      ],
      [
        AasTypes.AasSubmodelElements.ReferenceElement,
        AasTypes.isReferenceElement
      ],
      [
        AasTypes.AasSubmodelElements.RelationshipElement,
        AasTypes.isRelationshipElement
      ],
      [
        AasTypes.AasSubmodelElements.SubmodelElement,
        AasTypes.isSubmodelElement
      ],
      [
        AasTypes.AasSubmodelElements.SubmodelElementList,
        AasTypes.isSubmodelElementList
      ],
      [
        AasTypes.AasSubmodelElements.SubmodelElementCollection,
        AasTypes.isSubmodelElementCollection
      ]
    ]);

function assertAllTypesCoveredInAasSubmodelElementsToIs() {
  for (const literal of AasTypes.overAasSubmodelElements()) {
    if (!AAS_SUBMODEL_ELEMENTS_TO_IS.has(literal)) {
      throw new Error(
        `The enumeration literal ${literal} of AasTypes.AasSubmodelElements ` +
          "is not covered in AAS_SUBMODEL_ELEMENTS_TO_IS"
      );
    }
  }
}
assertAllTypesCoveredInAasSubmodelElementsToIs();

/**
 * Check that `element` is an instance of class corresponding to
 * `expectedType`.
 *
 * @param element - to be checked for type
 * @param expectedType - in the check
 * @returns `true` if `element` corresponds to `expectedType`
 */
export function submodelElementIsOfType(
  element: AasTypes.ISubmodelElement,
  expectedType: AasTypes.AasSubmodelElements
): boolean {
  const isFunc = AAS_SUBMODEL_ELEMENTS_TO_IS.get(expectedType);
  return isFunc(element);
}

/**
 * Check that `elements` which are {@link types.Property} or {@link types.Range}
 * have the given `valueType`.
 *
 * @param elements - to be verified
 * @returns `true` if the check passes
 */
export function propertiesOrRangesHaveValueType(
  elements: Iterable<AasTypes.ISubmodelElement>,
  valueType: AasTypes.DataTypeDefXsd
): boolean {
  for (const element of elements) {
    if (AasTypes.isProperty(element) || AasTypes.isRange(element)) {
      if (element.valueType !== valueType) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Check that the two references, `that` and `other`,
 * are equal by comparing their {@link types.Reference.keys}
 * by {@link types.Key.value}'s.
 *
 * @param that - reference to be compared
 * @param other - to be compared against
 * @returns `true` if the key values are are equal
 */
export function referenceKeyValuesEqual(
  that: AasTypes.Reference,
  other: AasTypes.Reference
): boolean {
  if (that.keys.length != other.keys.length) {
    return false;
  }

  for (let i = 0; i < that.keys.length; i++) {
    if (that.keys[i].value !== other.keys[i].value) {
      return false;
    }
  }

  return true;
}

/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined appropriately for all data specifications whose content is given
 * as IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export function dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(
  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>
): boolean {
  for (const embeddedDataSpecification of embeddedDataSpecifications) {
    const content = embeddedDataSpecification.dataSpecificationContent;
    if (AasTypes.isDataSpecificationIec61360(content)) {
      if (
        content.dataType === null
        || !AasConstants.DATA_TYPE_IEC_61360_FOR_PROPERTY_OR_VALUE.has(content.dataType)
      ) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined appropriately for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export function dataSpecificationIec61360sForReferenceHaveAppropriateDataType(
  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>
): boolean {
  for (const embeddedDataSpecification of embeddedDataSpecifications) {
    const content = embeddedDataSpecification.dataSpecificationContent;
    if (AasTypes.isDataSpecificationIec61360(content)) {
      if (
        content.dataType === null
        || !AasConstants.DATA_TYPE_IEC_61360_FOR_REFERENCE.has(content.dataType)
      ) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined appropriately for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export function dataSpecificationIec61360sForDocumentHaveAppropriateDataType(
  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>
): boolean {
  for (const embeddedDataSpecification of embeddedDataSpecifications) {
    const content = embeddedDataSpecification.dataSpecificationContent;
    if (AasTypes.isDataSpecificationIec61360(content)) {
      if (
        content.dataType === null
        || !AasConstants.DATA_TYPE_IEC_61360_FOR_DOCUMENT.has(content.dataType)
      ) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Check that {@link types.DataSpecificationIec61360.dataType}
 * is defined for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export function dataSpecificationIec61360sHaveDataType(
  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>
): boolean {
  for (const embeddedDataSpecification of embeddedDataSpecifications) {
    const content = embeddedDataSpecification.dataSpecificationContent;
    if (AasTypes.isDataSpecificationIec61360(content)) {
      if (content.dataType === null) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Check that {@link types.DataSpecificationIec61360.value}
 * is defined for all data specifications whose content is given as
 * IEC 61360.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export function dataSpecificationIec61360sHaveValue(
  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>
): boolean {
  for (const embeddedDataSpecification of embeddedDataSpecifications) {
    const content = embeddedDataSpecification.dataSpecificationContent;
    if (AasTypes.isDataSpecificationIec61360(content)) {
      if (content.value === null) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Check that {@link types.DataSpecificationIec61360.definition}
 * is defined for all data specifications whose content is given as
 * IEC 61360 at least in English.
 *
 * @param embeddedDataSpecifications - to be verified
 * @returns `true` if the check passes
 */
export function dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
  embeddedDataSpecifications: Iterable<AasTypes.EmbeddedDataSpecification>
): boolean {
  for (const embeddedDataSpecification of embeddedDataSpecifications) {
    const content = embeddedDataSpecification.dataSpecificationContent;
    if (AasTypes.isDataSpecificationIec61360(content)) {
      if (content.definition === null) {
        return false;
      }

      let noDefinitionInEnglish = true;
      for (const langString of content.definition) {
        if (isBcp47ForEnglish(langString.language)) {
          noDefinitionInEnglish = false;
          break;
        }
      }

      if (noDefinitionInEnglish === true) {
        return false;
      }
    }
  }

  return true;
}

function constructIsBcp47ForEnglish(): RegExp {
  const pattern = "^(en|EN)(-.*)?$";

  return new RegExp(pattern, "u");
}

const REGEXP_IS_BCP_47_FOR_ENGLISH = constructIsBcp47ForEnglish();

/**
 * Check that the `text` corresponds to a BCP47 code for english.
 */
export function isBcp47ForEnglish(text: string): boolean {
  return REGEXP_IS_BCP_47_FOR_ENGLISH.test(text);
}

/**
 * Verify an instance of the model recursively or non-recursively (depending on the context).
 */
class Verifier
  extends AasTypes.AbstractTransformerWithContext<
    boolean, IterableIterator<VerificationError>
  > {
  *transformExtensionWithContext(
    that: AasTypes.Extension,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.refersTo !== null)
      || (that.refersTo.length >= 1)
    )) {
      yield new VerificationError(
        "Refers-to must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.value !== null)
      || valueConsistentWithXsdType(
        that.value,
        that.valueTypeOrDefault()
      )
    )) {
      yield new VerificationError(
        "The value must match the value type."
      )
    }

    for (const error of verifyNameType(that.name)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "name"
        )
      );
      yield error;
    }

    if (that.value !== null) {
      for (const error of verifyValueDataType(that.value)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.refersTo !== null) {
        let refersToIndex = 0;
        for (const item of that.refersTo) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.refersTo,
                refersToIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "refersTo"
              )
            );
            yield error;
          }
          refersToIndex++;
        }
      }
    }
  }

  *transformAdministrativeInformationWithContext(
    that: AasTypes.AdministrativeInformation,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.revision !== null)
      || matchesRevisionType(that.revision)
    )) {
      yield new VerificationError(
        "Revision shall match the revision pattern"
      )
    }

    if (!(
      !(that.version !== null)
      || matchesVersionType(that.version)
    )) {
      yield new VerificationError(
        "Version shall match the version pattern"
      )
    }

    if (!(
      !(that.revision !== null)
      || (
        (
          that.revision.length > 0
          && that.revision.length <= 4
        )
      )
    )) {
      yield new VerificationError(
        "Revision shall have a length of maximum 4 characters and " +
        "minimum 1 character."
      )
    }

    if (!(
      !(that.version !== null)
      || (
        (
          that.version.length > 0
          && that.version.length <= 4
        )
      )
    )) {
      yield new VerificationError(
        "Version shall have a length of maximum 4 characters and " +
        "minimum 1 character."
      )
    }

    if (!(
      !(that.revision !== null)
      || (that.version !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-005: If version is not specified then also " +
        "revision shall be unspecified. This means, a revision " +
        "requires a version. If there is no version there is no " +
        "revision either. Revision is optional."
      )
    }

    if (that.version !== null) {
      for (const error of verifyNonEmptyXmlSerializableString(that.version)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "version"
          )
        );
        yield error;
      }
    }

    if (that.revision !== null) {
      for (const error of verifyNonEmptyXmlSerializableString(
          that.revision)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "revision"
          )
        );
        yield error;
      }
    }

    if (that.templateId !== null) {
      for (const error of verifyIdentifier(that.templateId)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "templateId"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.creator !== null) {
        for (const error of this.transformWithContext(that.creator, context)) {
          error.path.prepend(
            new PropertySegment(
              that,
              "creator"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformQualifierWithContext(
    that: AasTypes.Qualifier,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.value !== null)
      || valueConsistentWithXsdType(
        that.value,
        that.valueType
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-020: The value shall be consistent to " +
        "the data type as defined in value type."
      )
    }

    for (const error of verifyQualifierType(that.type)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "type"
        )
      );
      yield error;
    }

    if (that.value !== null) {
      for (const error of verifyValueDataType(that.value)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.valueId !== null) {
        for (const error of this.transformWithContext(that.valueId, context)) {
          error.path.prepend(
            new PropertySegment(
              that,
              "valueId"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformAssetAdministrationShellWithContext(
    that: AasTypes.AssetAdministrationShell,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.submodels !== null)
      || (that.submodels.length >= 1)
    )) {
      yield new VerificationError(
        "Submodels must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.derivedFrom !== null)
      || isModelReferenceTo(
        that.derivedFrom,
        AasTypes.KeyTypes.AssetAdministrationShell
      )
    )) {
      yield new VerificationError(
        "Derived-from must be a model reference to an asset " +
        "administration shell."
      )
    }

    if (!(
      !(that.submodels !== null)
      || (
        AasCommon.every(
          AasCommon.map(
            that.submodels,
            reference =>
              isModelReferenceTo(
                reference,
                AasTypes.KeyTypes.Submodel
              )
          )
        )
      )
    )) {
      yield new VerificationError(
        "All submodels must be model references to a submodel."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    for (const error of verifyIdentifier(that.id)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "id"
        )
      );
      yield error;
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.administration !== null) {
        for (const error of this.transformWithContext(
            that.administration, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "administration"
            )
          );
          yield error;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.derivedFrom !== null) {
        for (const error of this.transformWithContext(
            that.derivedFrom, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "derivedFrom"
            )
          );
          yield error;
        }
      }

      for (const error of this.transformWithContext(
          that.assetInformation, context)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "assetInformation"
          )
        );
        yield error;
      }

      if (that.submodels !== null) {
        let submodelsIndex = 0;
        for (const item of that.submodels) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.submodels,
                submodelsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "submodels"
              )
            );
            yield error;
          }
          submodelsIndex++;
        }
      }
    }
  }

  *transformAssetInformationWithContext(
    that: AasTypes.AssetInformation,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.specificAssetIds !== null)
      || (
        AasCommon.every(
          AasCommon.map(
            that.specificAssetIds,
            specificAssetId =>
              (
                specificAssetId.name != "globalAssetId"
                || (
                  (
                    specificAssetId.name == "globalAssetId"
                    && specificAssetId.value == that.globalAssetId
                  )
                )
              )
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-116: ``globalAssetId`` is a reserved key. " +
        "If used as value for the name of specific asset ID then " +
        "the value of specific asset ID shall be identical to " +
        "the global asset ID."
      )
    }

    if (!(
      (
        (
        (
          (that.globalAssetId !== null)
          && (that.specificAssetIds === null)
        )
      )
        || (
          (
            (that.globalAssetId === null)
            && (that.specificAssetIds !== null)
            && that.specificAssetIds.length >= 1
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-131: Either the global asset ID shall be " +
        "defined or at least one specific asset ID."
      )
    }

    if (!(
      !(that.specificAssetIds !== null)
      || (that.specificAssetIds.length >= 1)
    )) {
      yield new VerificationError(
        "Specific asset IDs must be either not set or have at least " +
        "one item"
      )
    }

    if (that.globalAssetId !== null) {
      for (const error of verifyIdentifier(that.globalAssetId)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "globalAssetId"
          )
        );
        yield error;
      }
    }

    if (that.assetType !== null) {
      for (const error of verifyIdentifier(that.assetType)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "assetType"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.specificAssetIds !== null) {
        let specificAssetIdsIndex = 0;
        for (const item of that.specificAssetIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.specificAssetIds,
                specificAssetIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "specificAssetIds"
              )
            );
            yield error;
          }
          specificAssetIdsIndex++;
        }
      }

      if (that.defaultThumbnail !== null) {
        for (const error of this.transformWithContext(
            that.defaultThumbnail, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "defaultThumbnail"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformResourceWithContext(
    that: AasTypes.Resource,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    for (const error of verifyPathType(that.path)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "path"
        )
      );
      yield error;
    }

    if (that.contentType !== null) {
      for (const error of verifyContentType(that.contentType)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "contentType"
          )
        );
        yield error;
      }
    }
  }

  *transformSpecificAssetIdWithContext(
    that: AasTypes.SpecificAssetId,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.externalSubjectId !== null)
      || (that.externalSubjectId.type == AasTypes.ReferenceTypes.ExternalReference)
    )) {
      yield new VerificationError(
        "Constraint AASd-133: SpecificAssetId/externalSubjectId " +
        "shall be a global reference, i.e. Reference/type = " +
        "GlobalReference."
      )
    }

    for (const error of verifyLabelType(that.name)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "name"
        )
      );
      yield error;
    }

    for (const error of verifyIdentifier(that.value)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "value"
        )
      );
      yield error;
    }

    if (context === true) {
      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.externalSubjectId !== null) {
        for (const error of this.transformWithContext(
            that.externalSubjectId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "externalSubjectId"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformSubmodelWithContext(
    that: AasTypes.Submodel,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.submodelElements !== null)
      || (that.submodelElements.length >= 1)
    )) {
      yield new VerificationError(
        "Submodel elements must be either not set or have at least " +
        "one item"
      )
    }

    if (!(
      !(that.submodelElements !== null)
      || (
        AasCommon.every(
          AasCommon.map(
            that.submodelElements,
            element =>
              element.idShort !== null
          )
        )
      )
    )) {
      yield new VerificationError(
        "ID-shorts need to be defined for all the submodel elements."
      )
    }

    if (!(
      !(that.submodelElements !== null)
      || idShortsAreUnique(that.submodelElements)
    )) {
      yield new VerificationError(
        "Constraint AASd-022: ID-short of non-identifiable " +
        "referables within the same name space shall be unique " +
        "(case-sensitive)."
      )
    }

    if (!(
      !(that.submodelElements !== null)
      || (
        !(
          AasCommon.some(
            AasCommon.map(
              that.submodelElements,
              submodelElement =>
                !(submodelElement.qualifiers !== null)
                || (
                  AasCommon.some(
                    AasCommon.map(
                      submodelElement.qualifiers,
                      qualifier =>
                        qualifier.kindOrDefault() == AasTypes.QualifierKind.TemplateQualifier
                    )
                  )
                )
            )
          )
        )
        || (that.kind == AasTypes.ModellingKind.Template)
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-129: If any qualifier kind value of " +
        "a Submodel element qualifier (attribute qualifier inherited " +
        "via Qualifiable) is equal to TemplateQualifier then " +
        "the submodel element shall be part of a submodel template, " +
        "i.e. a Submodel with submodel kind (attribute kind " +
        "inherited via HasKind) value is equal to Template"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (
        !(
          AasCommon.some(
            AasCommon.map(
              that.qualifiers,
              qualifier =>
                qualifier.kindOrDefault() == AasTypes.QualifierKind.TemplateQualifier
            )
          )
        )
        || (that.kindOrDefault() == AasTypes.ModellingKind.Template)
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-119: If any qualifier kind value of " +
        "a qualifiable qualifier is equal to template qualifier and " +
        "the qualified element has kind then the qualified element " +
        "shall be of kind template."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    for (const error of verifyIdentifier(that.id)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "id"
        )
      );
      yield error;
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.administration !== null) {
        for (const error of this.transformWithContext(
            that.administration, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "administration"
            )
          );
          yield error;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.submodelElements !== null) {
        let submodelElementsIndex = 0;
        for (const item of that.submodelElements) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.submodelElements,
                submodelElementsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "submodelElements"
              )
            );
            yield error;
          }
          submodelElementsIndex++;
        }
      }
    }
  }

  *transformRelationshipElementWithContext(
    that: AasTypes.RelationshipElement,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      for (const error of this.transformWithContext(that.first, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "first"
          )
        );
        yield error;
      }

      for (const error of this.transformWithContext(that.second, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "second"
          )
        );
        yield error;
      }
    }
  }

  *transformSubmodelElementListWithContext(
    that: AasTypes.SubmodelElementList,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.value !== null)
      || (that.value.length >= 1)
    )) {
      yield new VerificationError(
        "Value must be either not set or have at least one item"
      )
    }

    if (!(
      !(
        (
          (that.value !== null)
          && (that.semanticIdListElement !== null)
        )
      )
      || (
        AasCommon.every(
          AasCommon.map(
            that.value,
            child =>
              !(child.semanticId !== null)
              || referenceKeyValuesEqual(
                child.semanticId,
                that.semanticIdListElement
              )
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-107: If a first level child element has " +
        "a semantic ID it shall be identical to semantic ID list " +
        "element."
      )
    }

    if (!(
      !(that.value !== null)
      || submodelElementsHaveIdenticalSemanticIds(that.value)
    )) {
      yield new VerificationError(
        "Constraint AASd-114: If two first level child elements have " +
        "a semantic ID then they shall be identical."
      )
    }

    if (!(
      !(that.value !== null)
      || (
        AasCommon.every(
          AasCommon.map(
            that.value,
            element =>
              submodelElementIsOfType(
                element,
                that.typeValueListElement
              )
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-108: All first level child elements shall " +
        "have the same submodel element type as specified in type " +
        "value list element."
      )
    }

    if (!(
      !(
        (
          (that.value !== null)
          && (
            (
              that.typeValueListElement == AasTypes.AasSubmodelElements.Property
              || that.typeValueListElement == AasTypes.AasSubmodelElements.Range
            )
          )
        )
      )
      || (
        (
          (that.valueTypeListElement !== null)
          && propertiesOrRangesHaveValueType(
            that.value,
            that.valueTypeListElement
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-109: If type value list element is equal to " +
        "Property or Range value type list element shall be set and " +
        "all first level child elements shall have the value type as " +
        "specified in value type list element."
      )
    }

    if (!(
      !(that.value !== null)
      || (
        AasCommon.every(
          AasCommon.map(
            that.value,
            element =>
              element.idShort === null
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-120: idShort of submodel elements being " +
        "a direct child of a  SubmodelElementList shall not be " +
        "specified."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.semanticIdListElement !== null) {
        for (const error of this.transformWithContext(
            that.semanticIdListElement, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticIdListElement"
            )
          );
          yield error;
        }
      }

      if (that.value !== null) {
        let valueIndex = 0;
        for (const item of that.value) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.value,
                valueIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "value"
              )
            );
            yield error;
          }
          valueIndex++;
        }
      }
    }
  }

  *transformSubmodelElementCollectionWithContext(
    that: AasTypes.SubmodelElementCollection,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.value !== null)
      || (that.value.length >= 1)
    )) {
      yield new VerificationError(
        "Value must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.value !== null)
      || (
        AasCommon.every(
          AasCommon.map(
            that.value,
            element =>
              element.idShort !== null
          )
        )
      )
    )) {
      yield new VerificationError(
        "ID-shorts need to be defined for all the elements."
      )
    }

    if (!(
      !(that.value !== null)
      || idShortsAreUnique(that.value)
    )) {
      yield new VerificationError(
        "ID-shorts of the value must be unique."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.value !== null) {
        let valueIndex = 0;
        for (const item of that.value) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.value,
                valueIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "value"
              )
            );
            yield error;
          }
          valueIndex++;
        }
      }
    }
  }

  *transformPropertyWithContext(
    that: AasTypes.Property,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.category !== null)
      || (AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category))
    )) {
      yield new VerificationError(
        "Constraint AASd-090: For data elements category shall be " +
        "one of the following values: CONSTANT, PARAMETER or VARIABLE"
      )
    }

    if (!(
      !(that.value !== null)
      || valueConsistentWithXsdType(
        that.value,
        that.valueType
      )
    )) {
      yield new VerificationError(
        "Value must be consistent with the value type."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (that.value !== null) {
      for (const error of verifyValueDataType(that.value)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.valueId !== null) {
        for (const error of this.transformWithContext(that.valueId, context)) {
          error.path.prepend(
            new PropertySegment(
              that,
              "valueId"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformMultiLanguagePropertyWithContext(
    that: AasTypes.MultiLanguageProperty,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.category !== null)
      || (AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category))
    )) {
      yield new VerificationError(
        "Constraint AASd-090: For data elements category shall be " +
        "one of the following values: CONSTANT, PARAMETER or VARIABLE"
      )
    }

    if (!(
      !(that.value !== null)
      || langStringsHaveUniqueLanguages(that.value)
    )) {
      yield new VerificationError(
        "Value specifies no duplicate languages"
      )
    }

    if (!(
      !(that.value !== null)
      || (that.value.length >= 1)
    )) {
      yield new VerificationError(
        "Value must be either not set or have at least one item"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.value !== null) {
        let valueIndex = 0;
        for (const item of that.value) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.value,
                valueIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "value"
              )
            );
            yield error;
          }
          valueIndex++;
        }
      }

      if (that.valueId !== null) {
        for (const error of this.transformWithContext(that.valueId, context)) {
          error.path.prepend(
            new PropertySegment(
              that,
              "valueId"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformRangeWithContext(
    that: AasTypes.Range,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.category !== null)
      || (AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category))
    )) {
      yield new VerificationError(
        "Constraint AASd-090: For data elements category shall be " +
        "one of the following values: CONSTANT, PARAMETER or VARIABLE"
      )
    }

    if (!(
      !(that.max !== null)
      || valueConsistentWithXsdType(that.max, that.valueType)
    )) {
      yield new VerificationError(
        "Max must be consistent with the value type."
      )
    }

    if (!(
      !(that.min !== null)
      || valueConsistentWithXsdType(that.min, that.valueType)
    )) {
      yield new VerificationError(
        "Min must be consistent with the value type."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (that.min !== null) {
      for (const error of verifyValueDataType(that.min)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "min"
          )
        );
        yield error;
      }
    }

    if (that.max !== null) {
      for (const error of verifyValueDataType(that.max)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "max"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }
    }
  }

  *transformReferenceElementWithContext(
    that: AasTypes.ReferenceElement,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.category !== null)
      || (AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category))
    )) {
      yield new VerificationError(
        "Constraint AASd-090: For data elements category shall be " +
        "one of the following values: CONSTANT, PARAMETER or VARIABLE"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.value !== null) {
        for (const error of this.transformWithContext(that.value, context)) {
          error.path.prepend(
            new PropertySegment(
              that,
              "value"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformBlobWithContext(
    that: AasTypes.Blob,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.category !== null)
      || (AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category))
    )) {
      yield new VerificationError(
        "Constraint AASd-090: For data elements category shall be " +
        "one of the following values: CONSTANT, PARAMETER or VARIABLE"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (that.value !== null) {
      for (const error of verifyBlobType(that.value)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }

    for (const error of verifyContentType(that.contentType)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "contentType"
        )
      );
      yield error;
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }
    }
  }

  *transformFileWithContext(
    that: AasTypes.File,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.category !== null)
      || (AasConstants.VALID_CATEGORIES_FOR_DATA_ELEMENT.has(that.category))
    )) {
      yield new VerificationError(
        "Constraint AASd-090: For data elements category shall be " +
        "one of the following values: CONSTANT, PARAMETER or VARIABLE"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (that.value !== null) {
      for (const error of verifyPathType(that.value)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }

    for (const error of verifyContentType(that.contentType)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "contentType"
        )
      );
      yield error;
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }
    }
  }

  *transformAnnotatedRelationshipElementWithContext(
    that: AasTypes.AnnotatedRelationshipElement,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.annotations !== null)
      || (that.annotations.length >= 1)
    )) {
      yield new VerificationError(
        "Annotations must be either not set or have at least one item"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      for (const error of this.transformWithContext(that.first, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "first"
          )
        );
        yield error;
      }

      for (const error of this.transformWithContext(that.second, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "second"
          )
        );
        yield error;
      }

      if (that.annotations !== null) {
        let annotationsIndex = 0;
        for (const item of that.annotations) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.annotations,
                annotationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "annotations"
              )
            );
            yield error;
          }
          annotationsIndex++;
        }
      }
    }
  }

  *transformEntityWithContext(
    that: AasTypes.Entity,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.statements !== null)
      || (that.statements.length >= 1)
    )) {
      yield new VerificationError(
        "Statements must be either not set or have at least one item"
      )
    }

    if (!(
      (
        (
        (
          that.entityType == AasTypes.EntityType.SelfManagedEntity
          && (
            (
              (
              (
                (that.globalAssetId !== null)
                && (that.specificAssetIds === null)
              )
            )
              || (
                (
                  (that.globalAssetId === null)
                  && (that.specificAssetIds !== null)
                  && that.specificAssetIds.length >= 1
                )
              )
            )
          )
        )
      )
        || (
          (
            (that.globalAssetId === null)
            && (that.specificAssetIds === null)
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-014: Either the attribute global asset ID " +
        "or specific asset ID must be set if entity type is set to " +
        "'SelfManagedEntity'. They are not existing otherwise."
      )
    }

    if (!(
      !(that.specificAssetIds !== null)
      || (that.specificAssetIds.length >= 1)
    )) {
      yield new VerificationError(
        "Specific asset IDs must be either not set or have at least " +
        "one item"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (that.globalAssetId !== null) {
      for (const error of verifyIdentifier(that.globalAssetId)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "globalAssetId"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.statements !== null) {
        let statementsIndex = 0;
        for (const item of that.statements) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.statements,
                statementsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "statements"
              )
            );
            yield error;
          }
          statementsIndex++;
        }
      }

      if (that.specificAssetIds !== null) {
        let specificAssetIdsIndex = 0;
        for (const item of that.specificAssetIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.specificAssetIds,
                specificAssetIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "specificAssetIds"
              )
            );
            yield error;
          }
          specificAssetIdsIndex++;
        }
      }
    }
  }

  *transformEventPayloadWithContext(
    that: AasTypes.EventPayload,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      (
        isModelReferenceTo(
        that.source,
        AasTypes.KeyTypes.EventElement
      )
        || isModelReferenceTo(
          that.source,
          AasTypes.KeyTypes.BasicEventElement
        )
      )
    )) {
      yield new VerificationError(
        "Source must be a model reference to an EventElement."
      )
    }

    if (!(
      isModelReferenceToReferable(
        that.observableReference
      )
    )) {
      yield new VerificationError(
        "Observable reference must be a model reference to " +
        "a referable."
      )
    }

    if (that.topic !== null) {
      for (const error of verifyMessageTopicType(that.topic)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "topic"
          )
        );
        yield error;
      }
    }

    for (const error of verifyDateTimeUtc(that.timeStamp)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "timeStamp"
        )
      );
      yield error;
    }

    if (that.payload !== null) {
      for (const error of verifyBlobType(that.payload)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "payload"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      for (const error of this.transformWithContext(that.source, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "source"
          )
        );
        yield error;
      }

      if (that.sourceSemanticId !== null) {
        for (const error of this.transformWithContext(
            that.sourceSemanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "sourceSemanticId"
            )
          );
          yield error;
        }
      }

      for (const error of this.transformWithContext(
          that.observableReference, context)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "observableReference"
          )
        );
        yield error;
      }

      if (that.observableSemanticId !== null) {
        for (const error of this.transformWithContext(
            that.observableSemanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "observableSemanticId"
            )
          );
          yield error;
        }
      }

      if (that.subjectId !== null) {
        for (const error of this.transformWithContext(
            that.subjectId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "subjectId"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformBasicEventElementWithContext(
    that: AasTypes.BasicEventElement,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.direction == AasTypes.Direction.Input)
      || (that.maxInterval === null)
    )) {
      yield new VerificationError(
        "Max. interval is not applicable for input direction"
      )
    }

    if (!isModelReferenceToReferable(that.observed)) {
      yield new VerificationError(
        "Observed must be a model reference to a referable."
      )
    }

    if (!(
      !(that.messageBroker !== null)
      || isModelReferenceToReferable(that.messageBroker)
    )) {
      yield new VerificationError(
        "Message broker must be a model reference to a referable."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (that.messageTopic !== null) {
      for (const error of verifyMessageTopicType(that.messageTopic)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "messageTopic"
          )
        );
        yield error;
      }
    }

    if (that.lastUpdate !== null) {
      for (const error of verifyDateTimeUtc(that.lastUpdate)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "lastUpdate"
          )
        );
        yield error;
      }
    }

    if (that.minInterval !== null) {
      for (const error of verifyDuration(that.minInterval)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "minInterval"
          )
        );
        yield error;
      }
    }

    if (that.maxInterval !== null) {
      for (const error of verifyDuration(that.maxInterval)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "maxInterval"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      for (const error of this.transformWithContext(that.observed, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "observed"
          )
        );
        yield error;
      }

      if (that.messageBroker !== null) {
        for (const error of this.transformWithContext(
            that.messageBroker, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "messageBroker"
            )
          );
          yield error;
        }
      }
    }
  }

  *transformOperationWithContext(
    that: AasTypes.Operation,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      idShortsOfVariablesAreUnique(
        that.inputVariables,
        that.outputVariables,
        that.inoutputVariables
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-134: For an Operation the ID-short of all " +
        "values of input, output and in/output variables."
      )
    }

    if (!(
      !(that.inputVariables !== null)
      || (that.inputVariables.length >= 1)
    )) {
      yield new VerificationError(
        "Input variables must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.outputVariables !== null)
      || (that.outputVariables.length >= 1)
    )) {
      yield new VerificationError(
        "Output variables must be either not set or have at least " +
        "one item"
      )
    }

    if (!(
      !(that.inoutputVariables !== null)
      || (that.inoutputVariables.length >= 1)
    )) {
      yield new VerificationError(
        "Inoutput variables must be either not set or have at least " +
        "one item"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.inputVariables !== null) {
        let inputVariablesIndex = 0;
        for (const item of that.inputVariables) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.inputVariables,
                inputVariablesIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "inputVariables"
              )
            );
            yield error;
          }
          inputVariablesIndex++;
        }
      }

      if (that.outputVariables !== null) {
        let outputVariablesIndex = 0;
        for (const item of that.outputVariables) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.outputVariables,
                outputVariablesIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "outputVariables"
              )
            );
            yield error;
          }
          outputVariablesIndex++;
        }
      }

      if (that.inoutputVariables !== null) {
        let inoutputVariablesIndex = 0;
        for (const item of that.inoutputVariables) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.inoutputVariables,
                inoutputVariablesIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "inoutputVariables"
              )
            );
            yield error;
          }
          inoutputVariablesIndex++;
        }
      }
    }
  }

  *transformOperationVariableWithContext(
    that: AasTypes.OperationVariable,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (context === true) {
      for (const error of this.transformWithContext(that.value, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }
  }

  *transformCapabilityWithContext(
    that: AasTypes.Capability,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.supplementalSemanticIds.length >= 1)
    )) {
      yield new VerificationError(
        "Supplemental semantic IDs must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.supplementalSemanticIds !== null)
      || (that.semanticId !== null)
    )) {
      yield new VerificationError(
        "Constraint AASd-118: If there are supplemental semantic IDs " +
        "defined then there shall be also a main semantic ID."
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || (that.qualifiers.length >= 1)
    )) {
      yield new VerificationError(
        "Qualifiers must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.qualifiers !== null)
      || qualifierTypesAreUnique(that.qualifiers)
    )) {
      yield new VerificationError(
        "Constraint AASd-021: Every qualifiable can only have one " +
        "qualifier with the same type."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.semanticId !== null) {
        for (const error of this.transformWithContext(
            that.semanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "semanticId"
            )
          );
          yield error;
        }
      }

      if (that.supplementalSemanticIds !== null) {
        let supplementalSemanticIdsIndex = 0;
        for (const item of that.supplementalSemanticIds) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.supplementalSemanticIds,
                supplementalSemanticIdsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "supplementalSemanticIds"
              )
            );
            yield error;
          }
          supplementalSemanticIdsIndex++;
        }
      }

      if (that.qualifiers !== null) {
        let qualifiersIndex = 0;
        for (const item of that.qualifiers) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.qualifiers,
                qualifiersIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "qualifiers"
              )
            );
            yield error;
          }
          qualifiersIndex++;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }
    }
  }

  *transformConceptDescriptionWithContext(
    that: AasTypes.ConceptDescription,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.extensions !== null)
      || (that.extensions.length >= 1)
    )) {
      yield new VerificationError(
        "Extensions must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.extensions !== null)
      || extensionNamesAreUnique(that.extensions)
    )) {
      yield new VerificationError(
        "Constraint AASd-077: The name of an extension " +
        "(Extension/name) within Has-Extensions needs to be unique."
      )
    }

    if (!(
      !(that.description !== null)
      || (that.description.length >= 1)
    )) {
      yield new VerificationError(
        "Description must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.description !== null)
      || langStringsHaveUniqueLanguages(that.description)
    )) {
      yield new VerificationError(
        "Description specifies no duplicate languages"
      )
    }

    if (!(
      !(that.displayName !== null)
      || (that.displayName.length >= 1)
    )) {
      yield new VerificationError(
        "Display name must be either not set or have at least one " +
        "item"
      )
    }

    if (!(
      !(that.displayName !== null)
      || langStringsHaveUniqueLanguages(that.displayName)
    )) {
      yield new VerificationError(
        "Display name specifies no duplicate languages"
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (that.embeddedDataSpecifications.length >= 1)
    )) {
      yield new VerificationError(
        "Embedded data specifications must be either not set or have " +
        "at least one item"
      )
    }

    if (!(
      !(that.isCaseOf !== null)
      || (that.isCaseOf.length >= 1)
    )) {
      yield new VerificationError(
        "Is-case-of must be either not set or have at least one item"
      )
    }

    if (!(
      !(
        (
          (that.category !== null)
          && that.category != "VALUE"
          && (that.embeddedDataSpecifications !== null)
        )
      )
      || dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
        that.embeddedDataSpecifications
      )
    )) {
      yield new VerificationError(
        "For a ConceptDescription referenced via value ID in a value " +
        "list and using data specification template IEC61360 " +
        "(http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0), " +
        "value shall be set."
      )
    }

    if (!(
      !(that.embeddedDataSpecifications !== null)
      || (
        (
          dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
          that.embeddedDataSpecifications
        )
          || dataSpecificationIec61360sHaveValue(
            that.embeddedDataSpecifications
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-008: For a concept description using " +
        "data specification template IEC 61360, the definition is " +
        "mandatory and shall be defined at least in English. " +
        "Exception: The concept description describes a value"
      )
    }

    if (!(
      !(
        (
          (that.category !== null)
          && that.category == "QUALIFIER_TYPE"
          && (that.embeddedDataSpecifications !== null)
        )
      )
      || dataSpecificationIec61360sHaveDataType(
        that.embeddedDataSpecifications
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-007: For a concept description with " +
        "category QUALIFIER_TYPE using data specification IEC 61360, " +
        "the data type of the data specification is mandatory and " +
        "shall be defined."
      )
    }

    if (!(
      !(
        (
          (that.category !== null)
          && that.category == "DOCUMENT"
          && (that.embeddedDataSpecifications !== null)
        )
      )
      || dataSpecificationIec61360sForDocumentHaveAppropriateDataType(
        that.embeddedDataSpecifications
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-006: For a concept description with " +
        "category DOCUMENT using data specification IEC 61360, " +
        "the data type of the data specification shall be one of: " +
        "FILE, BLOB, HTML."
      )
    }

    if (!(
      !(
        (
          (that.category !== null)
          && that.category == "REFERENCE"
          && (that.embeddedDataSpecifications !== null)
        )
      )
      || dataSpecificationIec61360sForReferenceHaveAppropriateDataType(
        that.embeddedDataSpecifications
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-005: For a concept description with " +
        "category REFERENCE using data specification IEC 61360, " +
        "the data type of the data specification shall be one of: " +
        "STRING, IRI, IRDI."
      )
    }

    if (!(
      !(
        (
          (that.category !== null)
          && (
            (
              that.category == "PROPERTY"
              || that.category == "VALUE"
            )
          )
          && (that.embeddedDataSpecifications !== null)
        )
      )
      || dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(
        that.embeddedDataSpecifications
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-004: For a concept description with " +
        "category PROPERTY or VALUE using data specification IEC " +
        "61360, the data type of the data specification is mandatory " +
        "and shall be one of: DATE, STRING, STRING_TRANSLATABLE, " +
        "INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, " +
        "REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, " +
        "RATIONAL_MEASURE, TIME, TIMESTAMP."
      )
    }

    if (that.category !== null) {
      for (const error of verifyNameType(that.category)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "category"
          )
        );
        yield error;
      }
    }

    if (that.idShort !== null) {
      for (const error of verifyIdShortType(that.idShort)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "idShort"
          )
        );
        yield error;
      }
    }

    for (const error of verifyIdentifier(that.id)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "id"
        )
      );
      yield error;
    }

    if (context === true) {
      if (that.extensions !== null) {
        let extensionsIndex = 0;
        for (const item of that.extensions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.extensions,
                extensionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "extensions"
              )
            );
            yield error;
          }
          extensionsIndex++;
        }
      }

      if (that.displayName !== null) {
        let displayNameIndex = 0;
        for (const item of that.displayName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.displayName,
                displayNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "displayName"
              )
            );
            yield error;
          }
          displayNameIndex++;
        }
      }

      if (that.description !== null) {
        let descriptionIndex = 0;
        for (const item of that.description) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.description,
                descriptionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "description"
              )
            );
            yield error;
          }
          descriptionIndex++;
        }
      }

      if (that.administration !== null) {
        for (const error of this.transformWithContext(
            that.administration, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "administration"
            )
          );
          yield error;
        }
      }

      if (that.embeddedDataSpecifications !== null) {
        let embeddedDataSpecificationsIndex = 0;
        for (const item of that.embeddedDataSpecifications) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.embeddedDataSpecifications,
                embeddedDataSpecificationsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "embeddedDataSpecifications"
              )
            );
            yield error;
          }
          embeddedDataSpecificationsIndex++;
        }
      }

      if (that.isCaseOf !== null) {
        let isCaseOfIndex = 0;
        for (const item of that.isCaseOf) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.isCaseOf,
                isCaseOfIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "isCaseOf"
              )
            );
            yield error;
          }
          isCaseOfIndex++;
        }
      }
    }
  }

  *transformReferenceWithContext(
    that: AasTypes.Reference,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.keys.length >= 1)) {
      yield new VerificationError(
        "Keys must contain at least one item."
      )
    }

    if (!(
      !(that.keys.length >= 1)
      || (AasConstants.GLOBALLY_IDENTIFIABLES.has(AasCommon.at(that.keys, 0).type))
    )) {
      yield new VerificationError(
        "Constraint AASd-121: For References the value of Key/type " +
        "of the first key of Reference/keys shall be one of " +
        "GloballyIdentifiables."
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ExternalReference
          && that.keys.length >= 1
        )
      )
      || (AasConstants.GENERIC_GLOBALLY_IDENTIFIABLES.has(AasCommon.at(that.keys, 0).type))
    )) {
      yield new VerificationError(
        "Constraint AASd-122: For external references the value of " +
        "Key/type of the first key of Reference/keys shall be one of " +
        "Generic globally identifiables."
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ModelReference
          && that.keys.length >= 1
        )
      )
      || (AasConstants.AAS_IDENTIFIABLES.has(AasCommon.at(that.keys, 0).type))
    )) {
      yield new VerificationError(
        "Constraint AASd-123: For model references the value of " +
        "Key/type of the first key of Reference/keys shall be one of " +
        "AAS identifiables."
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ExternalReference
          && that.keys.length >= 1
        )
      )
      || (
        (
          (AasConstants.GENERIC_GLOBALLY_IDENTIFIABLES.has(AasCommon.at(that.keys, -1).type))
          || (AasConstants.GENERIC_FRAGMENT_KEYS.has(AasCommon.at(that.keys, -1).type))
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-124: For external references the last key " +
        "of Reference/keys shall be either one of Generic globally " +
        "identifiables or one of Generic fragment keys."
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ModelReference
          && that.keys.length > 1
        )
      )
      || (
        AasCommon.every(
          AasCommon.map(
            AasCommon.range(
              1,
              that.keys.length
            ),
            i =>
              AasConstants.FRAGMENT_KEYS.has(AasCommon.at(that.keys, i).type)
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-125: For model references with more than " +
        "one key in Reference/keys the value of Key/type of each of " +
        "the keys following the first key of Reference/keys shall be " +
        "one of Fragment keys."
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ModelReference
          && that.keys.length > 1
        )
      )
      || (
        AasCommon.every(
          AasCommon.map(
            AasCommon.range(
              0,
              that.keys.length - 1
            ),
            i =>
              !(AasConstants.GENERIC_FRAGMENT_KEYS.has(AasCommon.at(that.keys, i).type))
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-126: For model references with more than " +
        "one key in Reference/keys the value of Key/type of the last " +
        "key in the reference key chain may be one of Generic " +
        "fragment keys or no key at all shall have a value out of " +
        "Generic fragment keys."
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ModelReference
          && that.keys.length > 1
          && AasCommon.at(that.keys, -1).type == AasTypes.KeyTypes.FragmentReference
        )
      )
      || (
        (
          AasCommon.at(that.keys, -2).type == AasTypes.KeyTypes.File
          || AasCommon.at(that.keys, -2).type == AasTypes.KeyTypes.Blob
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-127: For model references, with more than " +
        "one key in Reference/keys a key with Key/type Fragment " +
        "reference shall be preceded by a key with Key/type File or " +
        "Blob. "
      )
    }

    if (!(
      !(
        (
          that.type == AasTypes.ReferenceTypes.ModelReference
          && that.keys.length > 2
        )
      )
      || (
        AasCommon.every(
          AasCommon.map(
            AasCommon.range(
              0,
              that.keys.length - 1
            ),
            i =>
              !(AasCommon.at(that.keys, i).type == AasTypes.KeyTypes.SubmodelElementList)
              || matchesXsPositiveInteger(
                AasCommon.at(that.keys, i + 1).value
              )
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASd-128: For model references, the value of " +
        "a key preceded by a key with type Submodel element list is " +
        "an integer number denoting the position in the array of " +
        "the submodel element list."
      )
    }

    if (context === true) {
      if (that.referredSemanticId !== null) {
        for (const error of this.transformWithContext(
            that.referredSemanticId, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "referredSemanticId"
            )
          );
          yield error;
        }
      }

      let keysIndex = 0;
      for (const item of that.keys) {
        for (const error of this.transformWithContext(item, context)) {
          error.path.prepend(
            new IndexSegment(
              that.keys,
              keysIndex
            )
          );
          error.path.prepend(
            new PropertySegment(
              that,
              "keys"
            )
          );
          yield error;
        }
        keysIndex++;
      }
    }
  }

  *transformKeyWithContext(
    that: AasTypes.Key,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    for (const error of verifyIdentifier(that.value)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "value"
        )
      );
      yield error;
    }
  }

  *transformLangStringNameTypeWithContext(
    that: AasTypes.LangStringNameType,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.text.length <= 128)) {
      yield new VerificationError(
        "String shall have a maximum length of 128 characters."
      )
    }

    for (const error of verifyBcp47LanguageTag(that.language)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "language"
        )
      );
      yield error;
    }

    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "text"
        )
      );
      yield error;
    }
  }

  *transformLangStringTextTypeWithContext(
    that: AasTypes.LangStringTextType,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.text.length <= 1023)) {
      yield new VerificationError(
        "String shall have a maximum length of 1023 characters."
      )
    }

    for (const error of verifyBcp47LanguageTag(that.language)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "language"
        )
      );
      yield error;
    }

    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "text"
        )
      );
      yield error;
    }
  }

  *transformEnvironmentWithContext(
    that: AasTypes.Environment,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      !(that.conceptDescriptions !== null)
      || (that.conceptDescriptions.length >= 1)
    )) {
      yield new VerificationError(
        "Concept descriptions must be either not set or have at " +
        "least one item"
      )
    }

    if (!(
      !(that.submodels !== null)
      || (that.submodels.length >= 1)
    )) {
      yield new VerificationError(
        "Submodels must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.assetAdministrationShells !== null)
      || (that.assetAdministrationShells.length >= 1)
    )) {
      yield new VerificationError(
        "Asset administration shells must be either not set or have " +
        "at least one item"
      )
    }

    if (context === true) {
      if (that.assetAdministrationShells !== null) {
        let assetAdministrationShellsIndex = 0;
        for (const item of that.assetAdministrationShells) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.assetAdministrationShells,
                assetAdministrationShellsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "assetAdministrationShells"
              )
            );
            yield error;
          }
          assetAdministrationShellsIndex++;
        }
      }

      if (that.submodels !== null) {
        let submodelsIndex = 0;
        for (const item of that.submodels) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.submodels,
                submodelsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "submodels"
              )
            );
            yield error;
          }
          submodelsIndex++;
        }
      }

      if (that.conceptDescriptions !== null) {
        let conceptDescriptionsIndex = 0;
        for (const item of that.conceptDescriptions) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.conceptDescriptions,
                conceptDescriptionsIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "conceptDescriptions"
              )
            );
            yield error;
          }
          conceptDescriptionsIndex++;
        }
      }
    }
  }

  *transformEmbeddedDataSpecificationWithContext(
    that: AasTypes.EmbeddedDataSpecification,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (context === true) {
      for (const error of this.transformWithContext(
          that.dataSpecification, context)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "dataSpecification"
          )
        );
        yield error;
      }

      for (const error of this.transformWithContext(
          that.dataSpecificationContent, context)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "dataSpecificationContent"
          )
        );
        yield error;
      }
    }
  }

  *transformLevelTypeWithContext(
    that: AasTypes.LevelType,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    // No verification has been defined for LevelType.
  }

  *transformValueReferencePairWithContext(
    that: AasTypes.ValueReferencePair,
    context: boolean
  ): IterableIterator<VerificationError> {
    for (const error of verifyValueTypeIec61360(that.value)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "value"
        )
      );
      yield error;
    }

    if (context === true) {
      for (const error of this.transformWithContext(that.valueId, context)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "valueId"
          )
        );
        yield error;
      }
    }
  }

  *transformValueListWithContext(
    that: AasTypes.ValueList,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.valueReferencePairs.length >= 1)) {
      yield new VerificationError(
        "Value reference pair types must contain at least one item."
      )
    }

    if (context === true) {
      let valueReferencePairsIndex = 0;
      for (const item of that.valueReferencePairs) {
        for (const error of this.transformWithContext(item, context)) {
          error.path.prepend(
            new IndexSegment(
              that.valueReferencePairs,
              valueReferencePairsIndex
            )
          );
          error.path.prepend(
            new PropertySegment(
              that,
              "valueReferencePairs"
            )
          );
          yield error;
        }
        valueReferencePairsIndex++;
      }
    }
  }

  *transformLangStringPreferredNameTypeIec61360WithContext(
    that: AasTypes.LangStringPreferredNameTypeIec61360,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.text.length <= 255)) {
      yield new VerificationError(
        "String shall have a maximum length of 1023 characters."
      )
    }

    for (const error of verifyBcp47LanguageTag(that.language)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "language"
        )
      );
      yield error;
    }

    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "text"
        )
      );
      yield error;
    }
  }

  *transformLangStringShortNameTypeIec61360WithContext(
    that: AasTypes.LangStringShortNameTypeIec61360,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.text.length <= 18)) {
      yield new VerificationError(
        "String shall have a maximum length of 1023 characters."
      )
    }

    for (const error of verifyBcp47LanguageTag(that.language)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "language"
        )
      );
      yield error;
    }

    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "text"
        )
      );
      yield error;
    }
  }

  *transformLangStringDefinitionTypeIec61360WithContext(
    that: AasTypes.LangStringDefinitionTypeIec61360,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(that.text.length <= 1023)) {
      yield new VerificationError(
        "String shall have a maximum length of 1023 characters."
      )
    }

    for (const error of verifyBcp47LanguageTag(that.language)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "language"
        )
      );
      yield error;
    }

    for (const error of verifyNonEmptyXmlSerializableString(that.text)) {
      error.path.prepend(
        new PropertySegment(
          that,
          "text"
        )
      );
      yield error;
    }
  }

  *transformDataSpecificationIec61360WithContext(
    that: AasTypes.DataSpecificationIec61360,
    context: boolean
  ): IterableIterator<VerificationError> {
    if (!(
      (
        (
        (
          (that.value !== null)
          && (that.valueList === null)
        )
      )
        || (
          (
            (that.value === null)
            && (that.valueList !== null)
            && that.valueList.valueReferencePairs.length >= 1
          )
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-010: If value is not empty then value " +
        "list shall be empty and vice versa."
      )
    }

    if (!(
      !(
        (
          (that.dataType === null)
          && (AasConstants.IEC_61360_DATA_TYPES_WITH_UNIT.has(that.dataType))
        )
      )
      || (
        (
          (that.unit !== null)
          || (that.unitId !== null)
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-3a-009: If data type is a an integer, real " +
        "or rational with a measure or currency, unit or unit ID " +
        "shall be defined."
      )
    }

    if (!(
      !(that.definition !== null)
      || (that.definition.length >= 1)
    )) {
      yield new VerificationError(
        "Definition must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.definition !== null)
      || langStringsHaveUniqueLanguages(that.definition)
    )) {
      yield new VerificationError(
        "Definition specifies no duplicate languages"
      )
    }

    if (!(
      !(that.shortName !== null)
      || (that.shortName.length >= 1)
    )) {
      yield new VerificationError(
        "Short name must be either not set or have at least one item"
      )
    }

    if (!(
      !(that.shortName !== null)
      || langStringsHaveUniqueLanguages(that.shortName)
    )) {
      yield new VerificationError(
        "Short name specifies no duplicate languages"
      )
    }

    if (!(that.preferredName.length >= 1)) {
      yield new VerificationError(
        "Preferred name must have at least one item"
      )
    }

    if (!langStringsHaveUniqueLanguages(that.preferredName)) {
      yield new VerificationError(
        "Preferred name specifies no duplicate languages"
      )
    }

    if (!(
      AasCommon.some(
        AasCommon.map(
          that.preferredName,
          langString =>
            isBcp47ForEnglish(langString.language)
        )
      )
    )) {
      yield new VerificationError(
        "Constraint AASc-002: preferred name shall be provided at " +
        "least in English."
      )
    }

    if (that.unit !== null) {
      for (const error of verifyNonEmptyXmlSerializableString(that.unit)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "unit"
          )
        );
        yield error;
      }
    }

    if (that.sourceOfDefinition !== null) {
      for (const error of verifyNonEmptyXmlSerializableString(
          that.sourceOfDefinition)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "sourceOfDefinition"
          )
        );
        yield error;
      }
    }

    if (that.symbol !== null) {
      for (const error of verifyNonEmptyXmlSerializableString(that.symbol)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "symbol"
          )
        );
        yield error;
      }
    }

    if (that.valueFormat !== null) {
      for (const error of verifyNonEmptyXmlSerializableString(
          that.valueFormat)
      ) {
        error.path.prepend(
          new PropertySegment(
            that,
            "valueFormat"
          )
        );
        yield error;
      }
    }

    if (that.value !== null) {
      for (const error of verifyValueTypeIec61360(that.value)) {
        error.path.prepend(
          new PropertySegment(
            that,
            "value"
          )
        );
        yield error;
      }
    }

    if (context === true) {
      let preferredNameIndex = 0;
      for (const item of that.preferredName) {
        for (const error of this.transformWithContext(item, context)) {
          error.path.prepend(
            new IndexSegment(
              that.preferredName,
              preferredNameIndex
            )
          );
          error.path.prepend(
            new PropertySegment(
              that,
              "preferredName"
            )
          );
          yield error;
        }
        preferredNameIndex++;
      }

      if (that.shortName !== null) {
        let shortNameIndex = 0;
        for (const item of that.shortName) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.shortName,
                shortNameIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "shortName"
              )
            );
            yield error;
          }
          shortNameIndex++;
        }
      }

      if (that.unitId !== null) {
        for (const error of this.transformWithContext(that.unitId, context)) {
          error.path.prepend(
            new PropertySegment(
              that,
              "unitId"
            )
          );
          yield error;
        }
      }

      if (that.definition !== null) {
        let definitionIndex = 0;
        for (const item of that.definition) {
          for (const error of this.transformWithContext(item, context)) {
            error.path.prepend(
              new IndexSegment(
                that.definition,
                definitionIndex
              )
            );
            error.path.prepend(
              new PropertySegment(
                that,
                "definition"
              )
            );
            yield error;
          }
          definitionIndex++;
        }
      }

      if (that.valueList !== null) {
        for (const error of this.transformWithContext(
            that.valueList, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "valueList"
            )
          );
          yield error;
        }
      }

      if (that.levelType !== null) {
        for (const error of this.transformWithContext(
            that.levelType, context)
        ) {
          error.path.prepend(
            new PropertySegment(
              that,
              "levelType"
            )
          );
          yield error;
        }
      }
    }
  }
}

const VERIFIER = new Verifier();

/**
 * Verify the constraints of `that`.
 *
 * @param that - instance to be verified
 * @param recurse - if set, continue the verification recursively
 * @returns a stream of verification errors
 */
export function *verify(
  that: AasTypes.Class,
  recurse = true
): IterableIterator<VerificationError> {
  yield * VERIFIER.transformWithContext(that, recurse);
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyNonEmptyXmlSerializableString(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyDateTimeUtc(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXsDateTimeUtc(that)) {
    yield new VerificationError(
      "The value must match the pattern of xs:dateTime with " +
      "the time zone fixed to UTC."
    )
  }

  if (!isXsDateTimeUtc(that)) {
    yield new VerificationError(
      "The value must represent a valid xs:dateTime with the time " +
      "zone fixed to UTC."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyDuration(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXsDuration(that)) {
    yield new VerificationError(
      "The value must match the pattern of xs:duration"
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyBlobType(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  that: Uint8Array
): IterableIterator<VerificationError> {
  // There is no verification specified.
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyIdentifier(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 2000)) {
    yield new VerificationError(
      "Identifier shall have a maximum length of 2000 characters."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyValueTypeIec61360(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 2000)) {
    yield new VerificationError(
      "ValueTypeIec61360 shall have a maximum length of 2000 " +
      "characters."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyNameType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 128)) {
    yield new VerificationError(
      "NameType shall have a maximum length of 128 characters."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyLabelType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 64)) {
    yield new VerificationError(
      "LabelType shall have a maximum length of 64 characters."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyMessageTopicType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 255)) {
    yield new VerificationError(
      "LabelType shall have a maximum length of 255 characters."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyBcp47LanguageTag(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesBcp47(that)) {
    yield new VerificationError(
      "The value must represent a value language tag conformant to " +
      "BCP 47."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyContentType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 100)) {
    yield new VerificationError(
      "ContentType shall have a maximum length of 100 characters."
    )
  }

  if (!matchesMimeType(that)) {
    yield new VerificationError(
      "The value must represent a valid content MIME type " +
      "according to RFC 2046."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyPathType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 2000)) {
    yield new VerificationError(
      "Identifier shall have a maximum length of 2000 characters."
    )
  }

  if (!matchesRfc8089Path(that)) {
    yield new VerificationError(
      "The value must represent a valid file URI scheme according " +
      "to RFC 8089."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyQualifierType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 128)) {
    yield new VerificationError(
      "NameType shall have a maximum length of 128 characters."
    )
  }
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyValueDataType(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  that: string
): IterableIterator<VerificationError> {
  // There is no verification specified.
}

/**
 * Verify the constraints of `that` value.
 *
 * @param that - to be verified
 * @returns errors, if any
 */
export function *verifyIdShortType(
  that: string
): IterableIterator<VerificationError> {
  if (!matchesXmlSerializableString(that)) {
    yield new VerificationError(
      "Constraint AASd-130: An attribute with data type 'string' " +
      "shall consist of these characters only: " +
      "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$"
    )
  }

  if (!(that.length >= 1)) {
    yield new VerificationError(
      "Check if string is not empty."
    )
  }

  if (!(that.length <= 128)) {
    yield new VerificationError(
      "NameType shall have a maximum length of 128 characters."
    )
  }

  if (!matchesIdShort(that)) {
    yield new VerificationError(
      "ID-short of Referables shall only feature letters, digits, " +
      "underscore (``_``); starting mandatory with a letter. " +
      "*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``."
    )
  }
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
