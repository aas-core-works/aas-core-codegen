// Package jsonization de/serializes model instances to and from JSON.
//
// We can not use one-pass deserialization for JSON since the object
// properties do not have fixed order, and hence we can not read
// `modelType` property ahead of the remaining properties.
//
// To de-serialize, call one of the `*FromJsonable` functions.
//
// To serialize, call [ToJsonable] function.
package jsonization

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	"fmt"
	"math"
	b64 "encoding/base64"
	aasreporting "github.com/aas-core-works/aas-core3.0-golang/reporting"
	aasstringification "github.com/aas-core-works/aas-core3.0-golang/stringification"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
)

// region De-serialization

// Represent an error during the de-serialization.
//
// Implements `error`.
type DeserializationError struct{
	Path *aasreporting.Path
	Message string
}

func newDeserializationError(message string) *DeserializationError {
	return &DeserializationError{
		Path: &aasreporting.Path{},
		Message: message,
	}
}

func (de *DeserializationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		de.PathString(),
		de.Message,
	)
}

// Render the path as a string.
func (de *DeserializationError) PathString() string {
	return aasreporting.ToJSONPath(de.Path)
}

// Parse `jsonable` as a boolean, or return an error.
func boolFromJsonable(
	jsonable interface{},
) (result bool, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a boolean, but got null",
		)
		return
	}

	var ok bool
	result, ok = jsonable.(bool)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf("Expected a boolean, but got %T", jsonable),
		)

		return
	}

	return
}

// Parse `jsonable` as a 64-bit integer, or return an error.
func int64FromJsonable(
	jsonable interface{},
) (result int64, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected an integer number, but got null",
		)
		return
	}

	f, ok := jsonable.(float64)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an integer number, but got %T",
				jsonable,
			),
		)
		return
	}

	if math.IsNaN(f) {
		err = newDeserializationError(
			"Expected an integer number, but got a NaN",
		)
		return
	}

	if math.IsInf(f, 0) {
		err = newDeserializationError(
			"Expected an integer number, but got an infinity",
		)
		return
	}

	if f != math.Trunc(f) {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an integer number, but got a non-integer: %v",
				f,
			),
		)
		return
	}

	result = int64(f)
	if f != float64(result) {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an integer number fitting into int64, but got: %v",
				jsonable,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as a 64-bit float, or return an error.
func float64FromJsonable(
	jsonable interface{},
) (result float64, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a number, but got null",
		)
		return
	}

	var ok bool
	result, ok = jsonable.(float64)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a number, but got %T",
				jsonable,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as a string, or return an error.
func stringFromJsonable(
	jsonable interface{},
) (result string, error *DeserializationError) {
	if jsonable == nil {
		error = newDeserializationError(
			"Expected a string, but got null",
		)
		return
	}

	var ok bool
	result, ok = jsonable.(string)
	if ok {
		return
	} else {
		error = newDeserializationError(
			fmt.Sprintf("Expected a boolean, but got %T", jsonable),
		)
		return
	}
}

// Parse `jsonable` as a byte array, or return an error.
func bytesFromJsonable(
	jsonable interface{},
) (result []byte, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a base64-encoded string, but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a base64-encoded string, but got %T",
				jsonable,
			),
		)
		return
	}

	var decodingErr error
	result, decodingErr = b64.StdEncoding.DecodeString(text)
	if decodingErr != nil {
		err = newDeserializationError(
			fmt.Sprintf(
				"String could not be decoded as base64: %s",
				decodingErr.Error(),
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasSemantics],
// or return an error.
func HasSemanticsFromJsonable(
	jsonable interface{},
) (
	result aastypes.IHasSemantics,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = hasSemanticsFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IExtension],
// or return an error.
func ExtensionFromJsonable(
	jsonable interface{},
) (
	result aastypes.IExtension,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = extensionFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IExtension] from a map,
// or return an error, if any.
func extensionFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IExtension,
	err *DeserializationError,
) {
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theName string
	var theValueType *aastypes.DataTypeDefXSD
	var theValue *string
	var theRefersTo []aastypes.IReference

	foundName := false

	for k, v := range m {
		switch k {
		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "name":
			theName, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "name",
					},
				)
				return
			}
			foundName = true

		case "valueType":
			var parsed aastypes.DataTypeDefXSD
			parsed, err = DataTypeDefXSDFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType",
					},
				)
				return
			}
			theValueType = &parsed

		case "value":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			theValue = &parsed

		case "refersTo":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "refersTo",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "refersTo",
						},
					)

					return
				}

				array[i] = item
			}
			theRefersTo = array

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundName {
		err = newDeserializationError(
			"The required property 'name' is missing",
		)
		return
	}

	result = aastypes.NewExtension(
		theName,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetValueType(
		theValueType,
	)
	result.SetValue(
		theValue,
	)
	result.SetRefersTo(
		theRefersTo,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasExtensions],
// or return an error.
func HasExtensionsFromJsonable(
	jsonable interface{},
) (
	result aastypes.IHasExtensions,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = hasExtensionsFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IReferable],
// or return an error.
func ReferableFromJsonable(
	jsonable interface{},
) (
	result aastypes.IReferable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = referableFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IIdentifiable],
// or return an error.
func IdentifiableFromJsonable(
	jsonable interface{},
) (
	result aastypes.IIdentifiable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = identifiableFromMap(m)

	return
}

// Parse `jsonable` as a literal of [aastypes.ModellingKind],
// or return an error.
func ModellingKindFromJsonable(
	jsonable interface{},
) (result aastypes.ModellingKind, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of ModellingKind, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ModellingKind, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.ModellingKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ModellingKind, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasKind],
// or return an error.
func HasKindFromJsonable(
	jsonable interface{},
) (
	result aastypes.IHasKind,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = hasKindFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasDataSpecification],
// or return an error.
func HasDataSpecificationFromJsonable(
	jsonable interface{},
) (
	result aastypes.IHasDataSpecification,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = hasDataSpecificationFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IAdministrativeInformation],
// or return an error.
func AdministrativeInformationFromJsonable(
	jsonable interface{},
) (
	result aastypes.IAdministrativeInformation,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = administrativeInformationFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IAdministrativeInformation] from a map,
// or return an error, if any.
func administrativeInformationFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IAdministrativeInformation,
	err *DeserializationError,
) {
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theVersion *string
	var theRevision *string
	var theCreator aastypes.IReference
	var theTemplateID *string

	for k, v := range m {
		switch k {
		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "version":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "version",
					},
				)
				return
			}
			theVersion = &parsed

		case "revision":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "revision",
					},
				)
				return
			}
			theRevision = &parsed

		case "creator":
			theCreator, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "creator",
					},
				)
				return
			}

		case "templateId":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "templateId",
					},
				)
				return
			}
			theTemplateID = &parsed

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewAdministrativeInformation()
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetVersion(
		theVersion,
	)
	result.SetRevision(
		theRevision,
	)
	result.SetCreator(
		theCreator,
	)
	result.SetTemplateID(
		theTemplateID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IQualifiable],
// or return an error.
func QualifiableFromJsonable(
	jsonable interface{},
) (
	result aastypes.IQualifiable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = qualifiableFromMap(m)

	return
}

// Parse `jsonable` as a literal of [aastypes.QualifierKind],
// or return an error.
func QualifierKindFromJsonable(
	jsonable interface{},
) (result aastypes.QualifierKind, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of QualifierKind, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of QualifierKind, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.QualifierKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of QualifierKind, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IQualifier],
// or return an error.
func QualifierFromJsonable(
	jsonable interface{},
) (
	result aastypes.IQualifier,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = qualifierFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IQualifier] from a map,
// or return an error, if any.
func qualifierFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IQualifier,
	err *DeserializationError,
) {
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theKind *aastypes.QualifierKind
	var theType string
	var theValueType aastypes.DataTypeDefXSD
	var theValue *string
	var theValueID aastypes.IReference

	foundType := false
	foundValueType := false

	for k, v := range m {
		switch k {
		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "kind":
			var parsed aastypes.QualifierKind
			parsed, err = QualifierKindFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "kind",
					},
				)
				return
			}
			theKind = &parsed

		case "type":
			theType, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "type",
					},
				)
				return
			}
			foundType = true

		case "valueType":
			theValueType, err = DataTypeDefXSDFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType",
					},
				)
				return
			}
			foundValueType = true

		case "value":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			theValue = &parsed

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId",
					},
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing",
		)
		return
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing",
		)
		return
	}

	result = aastypes.NewQualifier(
		theType,
		theValueType,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetKind(
		theKind,
	)
	result.SetValue(
		theValue,
	)
	result.SetValueID(
		theValueID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IAssetAdministrationShell],
// or return an error.
func AssetAdministrationShellFromJsonable(
	jsonable interface{},
) (
	result aastypes.IAssetAdministrationShell,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = assetAdministrationShellFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IAssetAdministrationShell] from a map,
// or return an error, if any.
func assetAdministrationShellFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IAssetAdministrationShell,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theAdministration aastypes.IAdministrativeInformation
	var theID string
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theDerivedFrom aastypes.IReference
	var theAssetInformation aastypes.IAssetInformation
	var theSubmodels []aastypes.IReference

	foundID := false
	foundAssetInformation := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "administration":
			theAdministration, err = AdministrativeInformationFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "administration",
					},
				)
				return
			}

		case "id":
			theID, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "id",
					},
				)
				return
			}
			foundID = true

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "derivedFrom":
			theDerivedFrom, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "derivedFrom",
					},
				)
				return
			}

		case "assetInformation":
			theAssetInformation, err = AssetInformationFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetInformation",
					},
				)
				return
			}
			foundAssetInformation = true

		case "submodels":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "submodels",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "submodels",
						},
					)

					return
				}

				array[i] = item
			}
			theSubmodels = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing",
		)
		return
	}

	if !foundAssetInformation {
		err = newDeserializationError(
			"The required property 'assetInformation' is missing",
		)
		return
	}

	result = aastypes.NewAssetAdministrationShell(
		theID,
		theAssetInformation,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetAdministration(
		theAdministration,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetDerivedFrom(
		theDerivedFrom,
	)
	result.SetSubmodels(
		theSubmodels,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IAssetInformation],
// or return an error.
func AssetInformationFromJsonable(
	jsonable interface{},
) (
	result aastypes.IAssetInformation,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = assetInformationFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IAssetInformation] from a map,
// or return an error, if any.
func assetInformationFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IAssetInformation,
	err *DeserializationError,
) {
	var theAssetKind aastypes.AssetKind
	var theGlobalAssetID *string
	var theSpecificAssetIDs []aastypes.ISpecificAssetID
	var theAssetType *string
	var theDefaultThumbnail aastypes.IResource

	foundAssetKind := false

	for k, v := range m {
		switch k {
		case "assetKind":
			theAssetKind, err = AssetKindFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetKind",
					},
				)
				return
			}
			foundAssetKind = true

		case "globalAssetId":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "globalAssetId",
					},
				)
				return
			}
			theGlobalAssetID = &parsed

		case "specificAssetIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "specificAssetIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISpecificAssetID,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISpecificAssetID
				item, err = SpecificAssetIDFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "specificAssetIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSpecificAssetIDs = array

		case "assetType":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetType",
					},
				)
				return
			}
			theAssetType = &parsed

		case "defaultThumbnail":
			theDefaultThumbnail, err = ResourceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "defaultThumbnail",
					},
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundAssetKind {
		err = newDeserializationError(
			"The required property 'assetKind' is missing",
		)
		return
	}

	result = aastypes.NewAssetInformation(
		theAssetKind,
	)
	result.SetGlobalAssetID(
		theGlobalAssetID,
	)
	result.SetSpecificAssetIDs(
		theSpecificAssetIDs,
	)
	result.SetAssetType(
		theAssetType,
	)
	result.SetDefaultThumbnail(
		theDefaultThumbnail,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IResource],
// or return an error.
func ResourceFromJsonable(
	jsonable interface{},
) (
	result aastypes.IResource,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = resourceFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IResource] from a map,
// or return an error, if any.
func resourceFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IResource,
	err *DeserializationError,
) {
	var thePath string
	var theContentType *string

	foundPath := false

	for k, v := range m {
		switch k {
		case "path":
			thePath, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "path",
					},
				)
				return
			}
			foundPath = true

		case "contentType":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "contentType",
					},
				)
				return
			}
			theContentType = &parsed

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundPath {
		err = newDeserializationError(
			"The required property 'path' is missing",
		)
		return
	}

	result = aastypes.NewResource(
		thePath,
	)
	result.SetContentType(
		theContentType,
	)

	return
}

// Parse `jsonable` as a literal of [aastypes.AssetKind],
// or return an error.
func AssetKindFromJsonable(
	jsonable interface{},
) (result aastypes.AssetKind, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of AssetKind, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AssetKind, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.AssetKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AssetKind, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.ISpecificAssetID],
// or return an error.
func SpecificAssetIDFromJsonable(
	jsonable interface{},
) (
	result aastypes.ISpecificAssetID,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = specificAssetIDFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ISpecificAssetID] from a map,
// or return an error, if any.
func specificAssetIDFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ISpecificAssetID,
	err *DeserializationError,
) {
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theName string
	var theValue string
	var theExternalSubjectID aastypes.IReference

	foundName := false
	foundValue := false

	for k, v := range m {
		switch k {
		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "name":
			theName, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "name",
					},
				)
				return
			}
			foundName = true

		case "value":
			theValue, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			foundValue = true

		case "externalSubjectId":
			theExternalSubjectID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "externalSubjectId",
					},
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundName {
		err = newDeserializationError(
			"The required property 'name' is missing",
		)
		return
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	result = aastypes.NewSpecificAssetID(
		theName,
		theValue,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetExternalSubjectID(
		theExternalSubjectID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodel],
// or return an error.
func SubmodelFromJsonable(
	jsonable interface{},
) (
	result aastypes.ISubmodel,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = submodelFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ISubmodel] from a map,
// or return an error, if any.
func submodelFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ISubmodel,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theAdministration aastypes.IAdministrativeInformation
	var theID string
	var theKind *aastypes.ModellingKind
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theSubmodelElements []aastypes.ISubmodelElement

	foundID := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "administration":
			theAdministration, err = AdministrativeInformationFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "administration",
					},
				)
				return
			}

		case "id":
			theID, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "id",
					},
				)
				return
			}
			foundID = true

		case "kind":
			var parsed aastypes.ModellingKind
			parsed, err = ModellingKindFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "kind",
					},
				)
				return
			}
			theKind = &parsed

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "submodelElements":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "submodelElements",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISubmodelElement,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "submodelElements",
						},
					)

					return
				}

				array[i] = item
			}
			theSubmodelElements = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing",
		)
		return
	}

	result = aastypes.NewSubmodel(
		theID,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetAdministration(
		theAdministration,
	)
	result.SetKind(
		theKind,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetSubmodelElements(
		theSubmodelElements,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodelElement],
// or return an error.
func SubmodelElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.ISubmodelElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = submodelElementFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IRelationshipElement],
// or return an error.
func RelationshipElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.IRelationshipElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = relationshipElementFromMap(m)

	return
}

// Parse [aastypes.IRelationshipElement] from a map,
// or return an error, if any.
//
// This function performs no dispatch! It is used to parse the properties
// as-are, and already assumes the exact model type. Usually, this function
// is called from within a from-jsonable or from-map function, and you never
// call it directly. If you want to de-serialize an instance of
// [aastypes.IRelationshipElement], call
// [RelationshipElementFromJsonable].
func relationshipElementFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IRelationshipElement,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theFirst aastypes.IReference
	var theSecond aastypes.IReference

	foundFirst := false
	foundSecond := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "first":
			theFirst, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "first",
					},
				)
				return
			}
			foundFirst = true

		case "second":
			theSecond, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "second",
					},
				)
				return
			}
			foundSecond = true

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundFirst {
		err = newDeserializationError(
			"The required property 'first' is missing",
		)
		return
	}

	if !foundSecond {
		err = newDeserializationError(
			"The required property 'second' is missing",
		)
		return
	}

	result = aastypes.NewRelationshipElement(
		theFirst,
		theSecond,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)

	return
}

// Parse `jsonable` as a literal of [aastypes.AASSubmodelElements],
// or return an error.
func AASSubmodelElementsFromJsonable(
	jsonable interface{},
) (result aastypes.AASSubmodelElements, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of AASSubmodelElements, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AASSubmodelElements, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.AASSubmodelElementsFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AASSubmodelElements, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodelElementList],
// or return an error.
func SubmodelElementListFromJsonable(
	jsonable interface{},
) (
	result aastypes.ISubmodelElementList,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = submodelElementListFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ISubmodelElementList] from a map,
// or return an error, if any.
func submodelElementListFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ISubmodelElementList,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theOrderRelevant *bool
	var theSemanticIDListElement aastypes.IReference
	var theTypeValueListElement aastypes.AASSubmodelElements
	var theValueTypeListElement *aastypes.DataTypeDefXSD
	var theValue []aastypes.ISubmodelElement

	foundTypeValueListElement := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "orderRelevant":
			var parsed bool
			parsed, err = boolFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "orderRelevant",
					},
				)
				return
			}
			theOrderRelevant = &parsed

		case "semanticIdListElement":
			theSemanticIDListElement, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticIdListElement",
					},
				)
				return
			}

		case "typeValueListElement":
			theTypeValueListElement, err = AASSubmodelElementsFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "typeValueListElement",
					},
				)
				return
			}
			foundTypeValueListElement = true

		case "valueTypeListElement":
			var parsed aastypes.DataTypeDefXSD
			parsed, err = DataTypeDefXSDFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueTypeListElement",
					},
				)
				return
			}
			theValueTypeListElement = &parsed

		case "value":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISubmodelElement,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "value",
						},
					)

					return
				}

				array[i] = item
			}
			theValue = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundTypeValueListElement {
		err = newDeserializationError(
			"The required property 'typeValueListElement' is missing",
		)
		return
	}

	result = aastypes.NewSubmodelElementList(
		theTypeValueListElement,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetOrderRelevant(
		theOrderRelevant,
	)
	result.SetSemanticIDListElement(
		theSemanticIDListElement,
	)
	result.SetValueTypeListElement(
		theValueTypeListElement,
	)
	result.SetValue(
		theValue,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodelElementCollection],
// or return an error.
func SubmodelElementCollectionFromJsonable(
	jsonable interface{},
) (
	result aastypes.ISubmodelElementCollection,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = submodelElementCollectionFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ISubmodelElementCollection] from a map,
// or return an error, if any.
func submodelElementCollectionFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ISubmodelElementCollection,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue []aastypes.ISubmodelElement

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "value":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISubmodelElement,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "value",
						},
					)

					return
				}

				array[i] = item
			}
			theValue = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewSubmodelElementCollection()
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetValue(
		theValue,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IDataElement],
// or return an error.
func DataElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.IDataElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = dataElementFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IProperty],
// or return an error.
func PropertyFromJsonable(
	jsonable interface{},
) (
	result aastypes.IProperty,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = propertyFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IProperty] from a map,
// or return an error, if any.
func propertyFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IProperty,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValueType aastypes.DataTypeDefXSD
	var theValue *string
	var theValueID aastypes.IReference

	foundValueType := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "valueType":
			theValueType, err = DataTypeDefXSDFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType",
					},
				)
				return
			}
			foundValueType = true

		case "value":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			theValue = &parsed

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId",
					},
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing",
		)
		return
	}

	result = aastypes.NewProperty(
		theValueType,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetValue(
		theValue,
	)
	result.SetValueID(
		theValueID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IMultiLanguageProperty],
// or return an error.
func MultiLanguagePropertyFromJsonable(
	jsonable interface{},
) (
	result aastypes.IMultiLanguageProperty,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = multiLanguagePropertyFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IMultiLanguageProperty] from a map,
// or return an error, if any.
func multiLanguagePropertyFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IMultiLanguageProperty,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue []aastypes.ILangStringTextType
	var theValueID aastypes.IReference

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "value":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "value",
						},
					)

					return
				}

				array[i] = item
			}
			theValue = array

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId",
					},
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewMultiLanguageProperty()
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetValue(
		theValue,
	)
	result.SetValueID(
		theValueID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IRange],
// or return an error.
func RangeFromJsonable(
	jsonable interface{},
) (
	result aastypes.IRange,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = rangeFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IRange] from a map,
// or return an error, if any.
func rangeFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IRange,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValueType aastypes.DataTypeDefXSD
	var theMin *string
	var theMax *string

	foundValueType := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "valueType":
			theValueType, err = DataTypeDefXSDFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType",
					},
				)
				return
			}
			foundValueType = true

		case "min":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "min",
					},
				)
				return
			}
			theMin = &parsed

		case "max":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "max",
					},
				)
				return
			}
			theMax = &parsed

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing",
		)
		return
	}

	result = aastypes.NewRange(
		theValueType,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetMin(
		theMin,
	)
	result.SetMax(
		theMax,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IReferenceElement],
// or return an error.
func ReferenceElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.IReferenceElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = referenceElementFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IReferenceElement] from a map,
// or return an error, if any.
func referenceElementFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IReferenceElement,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue aastypes.IReference

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "value":
			theValue, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewReferenceElement()
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetValue(
		theValue,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IBlob],
// or return an error.
func BlobFromJsonable(
	jsonable interface{},
) (
	result aastypes.IBlob,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = blobFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IBlob] from a map,
// or return an error, if any.
func blobFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IBlob,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue []byte
	var theContentType string

	foundContentType := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "value":
			theValue, err = bytesFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}

		case "contentType":
			theContentType, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "contentType",
					},
				)
				return
			}
			foundContentType = true

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundContentType {
		err = newDeserializationError(
			"The required property 'contentType' is missing",
		)
		return
	}

	result = aastypes.NewBlob(
		theContentType,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetValue(
		theValue,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IFile],
// or return an error.
func FileFromJsonable(
	jsonable interface{},
) (
	result aastypes.IFile,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = fileFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IFile] from a map,
// or return an error, if any.
func fileFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IFile,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue *string
	var theContentType string

	foundContentType := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "value":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			theValue = &parsed

		case "contentType":
			theContentType, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "contentType",
					},
				)
				return
			}
			foundContentType = true

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundContentType {
		err = newDeserializationError(
			"The required property 'contentType' is missing",
		)
		return
	}

	result = aastypes.NewFile(
		theContentType,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetValue(
		theValue,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IAnnotatedRelationshipElement],
// or return an error.
func AnnotatedRelationshipElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.IAnnotatedRelationshipElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IAnnotatedRelationshipElement] from a map,
// or return an error, if any.
func annotatedRelationshipElementFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IAnnotatedRelationshipElement,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theFirst aastypes.IReference
	var theSecond aastypes.IReference
	var theAnnotations []aastypes.IDataElement

	foundFirst := false
	foundSecond := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "first":
			theFirst, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "first",
					},
				)
				return
			}
			foundFirst = true

		case "second":
			theSecond, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "second",
					},
				)
				return
			}
			foundSecond = true

		case "annotations":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "annotations",
					},
				)

				return
			}

			array := make(
				[]aastypes.IDataElement,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IDataElement
				item, err = DataElementFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "annotations",
						},
					)

					return
				}

				array[i] = item
			}
			theAnnotations = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundFirst {
		err = newDeserializationError(
			"The required property 'first' is missing",
		)
		return
	}

	if !foundSecond {
		err = newDeserializationError(
			"The required property 'second' is missing",
		)
		return
	}

	result = aastypes.NewAnnotatedRelationshipElement(
		theFirst,
		theSecond,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetAnnotations(
		theAnnotations,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IEntity],
// or return an error.
func EntityFromJsonable(
	jsonable interface{},
) (
	result aastypes.IEntity,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = entityFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IEntity] from a map,
// or return an error, if any.
func entityFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IEntity,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theStatements []aastypes.ISubmodelElement
	var theEntityType aastypes.EntityType
	var theGlobalAssetID *string
	var theSpecificAssetIDs []aastypes.ISpecificAssetID

	foundEntityType := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "statements":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "statements",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISubmodelElement,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "statements",
						},
					)

					return
				}

				array[i] = item
			}
			theStatements = array

		case "entityType":
			theEntityType, err = EntityTypeFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "entityType",
					},
				)
				return
			}
			foundEntityType = true

		case "globalAssetId":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "globalAssetId",
					},
				)
				return
			}
			theGlobalAssetID = &parsed

		case "specificAssetIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "specificAssetIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISpecificAssetID,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISpecificAssetID
				item, err = SpecificAssetIDFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "specificAssetIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSpecificAssetIDs = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundEntityType {
		err = newDeserializationError(
			"The required property 'entityType' is missing",
		)
		return
	}

	result = aastypes.NewEntity(
		theEntityType,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetStatements(
		theStatements,
	)
	result.SetGlobalAssetID(
		theGlobalAssetID,
	)
	result.SetSpecificAssetIDs(
		theSpecificAssetIDs,
	)

	return
}

// Parse `jsonable` as a literal of [aastypes.EntityType],
// or return an error.
func EntityTypeFromJsonable(
	jsonable interface{},
) (result aastypes.EntityType, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of EntityType, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of EntityType, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.EntityTypeFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of EntityType, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as a literal of [aastypes.Direction],
// or return an error.
func DirectionFromJsonable(
	jsonable interface{},
) (result aastypes.Direction, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of Direction, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of Direction, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.DirectionFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of Direction, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as a literal of [aastypes.StateOfEvent],
// or return an error.
func StateOfEventFromJsonable(
	jsonable interface{},
) (result aastypes.StateOfEvent, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of StateOfEvent, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of StateOfEvent, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.StateOfEventFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of StateOfEvent, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IEventPayload],
// or return an error.
func EventPayloadFromJsonable(
	jsonable interface{},
) (
	result aastypes.IEventPayload,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = eventPayloadFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IEventPayload] from a map,
// or return an error, if any.
func eventPayloadFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IEventPayload,
	err *DeserializationError,
) {
	var theSource aastypes.IReference
	var theSourceSemanticID aastypes.IReference
	var theObservableReference aastypes.IReference
	var theObservableSemanticID aastypes.IReference
	var theTopic *string
	var theSubjectID aastypes.IReference
	var theTimeStamp string
	var thePayload []byte

	foundSource := false
	foundObservableReference := false
	foundTimeStamp := false

	for k, v := range m {
		switch k {
		case "source":
			theSource, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "source",
					},
				)
				return
			}
			foundSource = true

		case "sourceSemanticId":
			theSourceSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "sourceSemanticId",
					},
				)
				return
			}

		case "observableReference":
			theObservableReference, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "observableReference",
					},
				)
				return
			}
			foundObservableReference = true

		case "observableSemanticId":
			theObservableSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "observableSemanticId",
					},
				)
				return
			}

		case "topic":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "topic",
					},
				)
				return
			}
			theTopic = &parsed

		case "subjectId":
			theSubjectID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "subjectId",
					},
				)
				return
			}

		case "timeStamp":
			theTimeStamp, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "timeStamp",
					},
				)
				return
			}
			foundTimeStamp = true

		case "payload":
			thePayload, err = bytesFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "payload",
					},
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundSource {
		err = newDeserializationError(
			"The required property 'source' is missing",
		)
		return
	}

	if !foundObservableReference {
		err = newDeserializationError(
			"The required property 'observableReference' is missing",
		)
		return
	}

	if !foundTimeStamp {
		err = newDeserializationError(
			"The required property 'timeStamp' is missing",
		)
		return
	}

	result = aastypes.NewEventPayload(
		theSource,
		theObservableReference,
		theTimeStamp,
	)
	result.SetSourceSemanticID(
		theSourceSemanticID,
	)
	result.SetObservableSemanticID(
		theObservableSemanticID,
	)
	result.SetTopic(
		theTopic,
	)
	result.SetSubjectID(
		theSubjectID,
	)
	result.SetPayload(
		thePayload,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IEventElement],
// or return an error.
func EventElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.IEventElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = eventElementFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IBasicEventElement],
// or return an error.
func BasicEventElementFromJsonable(
	jsonable interface{},
) (
	result aastypes.IBasicEventElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = basicEventElementFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IBasicEventElement] from a map,
// or return an error, if any.
func basicEventElementFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IBasicEventElement,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theObserved aastypes.IReference
	var theDirection aastypes.Direction
	var theState aastypes.StateOfEvent
	var theMessageTopic *string
	var theMessageBroker aastypes.IReference
	var theLastUpdate *string
	var theMinInterval *string
	var theMaxInterval *string

	foundObserved := false
	foundDirection := false
	foundState := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "observed":
			theObserved, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "observed",
					},
				)
				return
			}
			foundObserved = true

		case "direction":
			theDirection, err = DirectionFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "direction",
					},
				)
				return
			}
			foundDirection = true

		case "state":
			theState, err = StateOfEventFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "state",
					},
				)
				return
			}
			foundState = true

		case "messageTopic":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "messageTopic",
					},
				)
				return
			}
			theMessageTopic = &parsed

		case "messageBroker":
			theMessageBroker, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "messageBroker",
					},
				)
				return
			}

		case "lastUpdate":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "lastUpdate",
					},
				)
				return
			}
			theLastUpdate = &parsed

		case "minInterval":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "minInterval",
					},
				)
				return
			}
			theMinInterval = &parsed

		case "maxInterval":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "maxInterval",
					},
				)
				return
			}
			theMaxInterval = &parsed

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundObserved {
		err = newDeserializationError(
			"The required property 'observed' is missing",
		)
		return
	}

	if !foundDirection {
		err = newDeserializationError(
			"The required property 'direction' is missing",
		)
		return
	}

	if !foundState {
		err = newDeserializationError(
			"The required property 'state' is missing",
		)
		return
	}

	result = aastypes.NewBasicEventElement(
		theObserved,
		theDirection,
		theState,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetMessageTopic(
		theMessageTopic,
	)
	result.SetMessageBroker(
		theMessageBroker,
	)
	result.SetLastUpdate(
		theLastUpdate,
	)
	result.SetMinInterval(
		theMinInterval,
	)
	result.SetMaxInterval(
		theMaxInterval,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IOperation],
// or return an error.
func OperationFromJsonable(
	jsonable interface{},
) (
	result aastypes.IOperation,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = operationFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IOperation] from a map,
// or return an error, if any.
func operationFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IOperation,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theInputVariables []aastypes.IOperationVariable
	var theOutputVariables []aastypes.IOperationVariable
	var theInoutputVariables []aastypes.IOperationVariable

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "inputVariables":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "inputVariables",
					},
				)

				return
			}

			array := make(
				[]aastypes.IOperationVariable,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IOperationVariable
				item, err = OperationVariableFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "inputVariables",
						},
					)

					return
				}

				array[i] = item
			}
			theInputVariables = array

		case "outputVariables":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "outputVariables",
					},
				)

				return
			}

			array := make(
				[]aastypes.IOperationVariable,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IOperationVariable
				item, err = OperationVariableFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "outputVariables",
						},
					)

					return
				}

				array[i] = item
			}
			theOutputVariables = array

		case "inoutputVariables":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "inoutputVariables",
					},
				)

				return
			}

			array := make(
				[]aastypes.IOperationVariable,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IOperationVariable
				item, err = OperationVariableFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "inoutputVariables",
						},
					)

					return
				}

				array[i] = item
			}
			theInoutputVariables = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewOperation()
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetInputVariables(
		theInputVariables,
	)
	result.SetOutputVariables(
		theOutputVariables,
	)
	result.SetInoutputVariables(
		theInoutputVariables,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IOperationVariable],
// or return an error.
func OperationVariableFromJsonable(
	jsonable interface{},
) (
	result aastypes.IOperationVariable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = operationVariableFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IOperationVariable] from a map,
// or return an error, if any.
func operationVariableFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IOperationVariable,
	err *DeserializationError,
) {
	var theValue aastypes.ISubmodelElement

	foundValue := false

	for k, v := range m {
		switch k {
		case "value":
			theValue, err = SubmodelElementFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			foundValue = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	result = aastypes.NewOperationVariable(
		theValue,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ICapability],
// or return an error.
func CapabilityFromJsonable(
	jsonable interface{},
) (
	result aastypes.ICapability,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = capabilityFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ICapability] from a map,
// or return an error, if any.
func capabilityFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ICapability,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId",
					},
				)
				return
			}

		case "supplementalSemanticIds":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds",
						},
					)

					return
				}

				array[i] = item
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers",
					},
				)

				return
			}

			array := make(
				[]aastypes.IQualifier,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers",
						},
					)

					return
				}

				array[i] = item
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewCapability()
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetSemanticID(
		theSemanticID,
	)
	result.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	result.SetQualifiers(
		theQualifiers,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IConceptDescription],
// or return an error.
func ConceptDescriptionFromJsonable(
	jsonable interface{},
) (
	result aastypes.IConceptDescription,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = conceptDescriptionFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IConceptDescription] from a map,
// or return an error, if any.
func conceptDescriptionFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IConceptDescription,
	err *DeserializationError,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theAdministration aastypes.IAdministrativeInformation
	var theID string
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theIsCaseOf []aastypes.IReference

	foundID := false

	for k, v := range m {
		switch k {
		case "extensions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IExtension,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions",
						},
					)

					return
				}

				array[i] = item
			}
			theExtensions = array

		case "category":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category",
					},
				)
				return
			}
			theCategory = &parsed

		case "idShort":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort",
					},
				)
				return
			}
			theIDShort = &parsed

		case "displayName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringNameType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName",
						},
					)

					return
				}

				array[i] = item
			}
			theDisplayName = array

		case "description":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringTextType,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description",
						},
					)

					return
				}

				array[i] = item
			}
			theDescription = array

		case "administration":
			theAdministration, err = AdministrativeInformationFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "administration",
					},
				)
				return
			}

		case "id":
			theID, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "id",
					},
				)
				return
			}
			foundID = true

		case "embeddedDataSpecifications":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications",
					},
				)

				return
			}

			array := make(
				[]aastypes.IEmbeddedDataSpecification,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications",
						},
					)

					return
				}

				array[i] = item
			}
			theEmbeddedDataSpecifications = array

		case "isCaseOf":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "isCaseOf",
					},
				)

				return
			}

			array := make(
				[]aastypes.IReference,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IReference
				item, err = ReferenceFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "isCaseOf",
						},
					)

					return
				}

				array[i] = item
			}
			theIsCaseOf = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing",
		)
		return
	}

	result = aastypes.NewConceptDescription(
		theID,
	)
	result.SetExtensions(
		theExtensions,
	)
	result.SetCategory(
		theCategory,
	)
	result.SetIDShort(
		theIDShort,
	)
	result.SetDisplayName(
		theDisplayName,
	)
	result.SetDescription(
		theDescription,
	)
	result.SetAdministration(
		theAdministration,
	)
	result.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	result.SetIsCaseOf(
		theIsCaseOf,
	)

	return
}

// Parse `jsonable` as a literal of [aastypes.ReferenceTypes],
// or return an error.
func ReferenceTypesFromJsonable(
	jsonable interface{},
) (result aastypes.ReferenceTypes, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of ReferenceTypes, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ReferenceTypes, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.ReferenceTypesFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ReferenceTypes, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IReference],
// or return an error.
func ReferenceFromJsonable(
	jsonable interface{},
) (
	result aastypes.IReference,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = referenceFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IReference] from a map,
// or return an error, if any.
func referenceFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IReference,
	err *DeserializationError,
) {
	var theType aastypes.ReferenceTypes
	var theReferredSemanticID aastypes.IReference
	var theKeys []aastypes.IKey

	foundType := false
	foundKeys := false

	for k, v := range m {
		switch k {
		case "type":
			theType, err = ReferenceTypesFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "type",
					},
				)
				return
			}
			foundType = true

		case "referredSemanticId":
			theReferredSemanticID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "referredSemanticId",
					},
				)
				return
			}

		case "keys":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "keys",
					},
				)

				return
			}

			array := make(
				[]aastypes.IKey,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IKey
				item, err = KeyFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "keys",
						},
					)

					return
				}

				array[i] = item
			}
			theKeys = array
			foundKeys = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing",
		)
		return
	}

	if !foundKeys {
		err = newDeserializationError(
			"The required property 'keys' is missing",
		)
		return
	}

	result = aastypes.NewReference(
		theType,
		theKeys,
	)
	result.SetReferredSemanticID(
		theReferredSemanticID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IKey],
// or return an error.
func KeyFromJsonable(
	jsonable interface{},
) (
	result aastypes.IKey,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = keyFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IKey] from a map,
// or return an error, if any.
func keyFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IKey,
	err *DeserializationError,
) {
	var theType aastypes.KeyTypes
	var theValue string

	foundType := false
	foundValue := false

	for k, v := range m {
		switch k {
		case "type":
			theType, err = KeyTypesFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "type",
					},
				)
				return
			}
			foundType = true

		case "value":
			theValue, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			foundValue = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing",
		)
		return
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	result = aastypes.NewKey(
		theType,
		theValue,
	)

	return
}

// Parse `jsonable` as a literal of [aastypes.KeyTypes],
// or return an error.
func KeyTypesFromJsonable(
	jsonable interface{},
) (result aastypes.KeyTypes, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of KeyTypes, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of KeyTypes, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.KeyTypesFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of KeyTypes, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as a literal of [aastypes.DataTypeDefXSD],
// or return an error.
func DataTypeDefXSDFromJsonable(
	jsonable interface{},
) (result aastypes.DataTypeDefXSD, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of DataTypeDefXSD, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeDefXSD, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.DataTypeDefXSDFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeDefXSD, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IAbstractLangString],
// or return an error.
func AbstractLangStringFromJsonable(
	jsonable interface{},
) (
	result aastypes.IAbstractLangString,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = abstractLangStringFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringNameType],
// or return an error.
func LangStringNameTypeFromJsonable(
	jsonable interface{},
) (
	result aastypes.ILangStringNameType,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = langStringNameTypeFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ILangStringNameType] from a map,
// or return an error, if any.
func langStringNameTypeFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ILangStringNameType,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range m {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language",
					},
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text",
					},
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	result = aastypes.NewLangStringNameType(
		theLanguage,
		theText,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringTextType],
// or return an error.
func LangStringTextTypeFromJsonable(
	jsonable interface{},
) (
	result aastypes.ILangStringTextType,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = langStringTextTypeFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ILangStringTextType] from a map,
// or return an error, if any.
func langStringTextTypeFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ILangStringTextType,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range m {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language",
					},
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text",
					},
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	result = aastypes.NewLangStringTextType(
		theLanguage,
		theText,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IEnvironment],
// or return an error.
func EnvironmentFromJsonable(
	jsonable interface{},
) (
	result aastypes.IEnvironment,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = environmentFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IEnvironment] from a map,
// or return an error, if any.
func environmentFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IEnvironment,
	err *DeserializationError,
) {
	var theAssetAdministrationShells []aastypes.IAssetAdministrationShell
	var theSubmodels []aastypes.ISubmodel
	var theConceptDescriptions []aastypes.IConceptDescription

	for k, v := range m {
		switch k {
		case "assetAdministrationShells":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetAdministrationShells",
					},
				)

				return
			}

			array := make(
				[]aastypes.IAssetAdministrationShell,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IAssetAdministrationShell
				item, err = AssetAdministrationShellFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "assetAdministrationShells",
						},
					)

					return
				}

				array[i] = item
			}
			theAssetAdministrationShells = array

		case "submodels":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "submodels",
					},
				)

				return
			}

			array := make(
				[]aastypes.ISubmodel,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ISubmodel
				item, err = SubmodelFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "submodels",
						},
					)

					return
				}

				array[i] = item
			}
			theSubmodels = array

		case "conceptDescriptions":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "conceptDescriptions",
					},
				)

				return
			}

			array := make(
				[]aastypes.IConceptDescription,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IConceptDescription
				item, err = ConceptDescriptionFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "conceptDescriptions",
						},
					)

					return
				}

				array[i] = item
			}
			theConceptDescriptions = array

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	result = aastypes.NewEnvironment()
	result.SetAssetAdministrationShells(
		theAssetAdministrationShells,
	)
	result.SetSubmodels(
		theSubmodels,
	)
	result.SetConceptDescriptions(
		theConceptDescriptions,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IDataSpecificationContent],
// or return an error.
func DataSpecificationContentFromJsonable(
	jsonable interface{},
) (
	result aastypes.IDataSpecificationContent,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = dataSpecificationContentFromMap(m)

	return
}

// Parse `jsonable` as an instance of [aastypes.IEmbeddedDataSpecification],
// or return an error.
func EmbeddedDataSpecificationFromJsonable(
	jsonable interface{},
) (
	result aastypes.IEmbeddedDataSpecification,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = embeddedDataSpecificationFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IEmbeddedDataSpecification] from a map,
// or return an error, if any.
func embeddedDataSpecificationFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IEmbeddedDataSpecification,
	err *DeserializationError,
) {
	var theDataSpecificationContent aastypes.IDataSpecificationContent
	var theDataSpecification aastypes.IReference

	foundDataSpecificationContent := false

	for k, v := range m {
		switch k {
		case "dataSpecificationContent":
			theDataSpecificationContent, err = DataSpecificationContentFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "dataSpecificationContent",
					},
				)
				return
			}
			foundDataSpecificationContent = true

		case "dataSpecification":
			theDataSpecification, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "dataSpecification",
					},
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundDataSpecificationContent {
		err = newDeserializationError(
			"The required property 'dataSpecificationContent' is missing",
		)
		return
	}

	result = aastypes.NewEmbeddedDataSpecification(
		theDataSpecificationContent,
	)
	result.SetDataSpecification(
		theDataSpecification,
	)

	return
}

// Parse `jsonable` as a literal of [aastypes.DataTypeIEC61360],
// or return an error.
func DataTypeIEC61360FromJsonable(
	jsonable interface{},
) (result aastypes.DataTypeIEC61360, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of DataTypeIEC61360, " +
			"but got null",
		)
		return
	}

	text, ok := jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeIEC61360, " +
				"but got %T",
				jsonable,
			),
		)
		return
	}

	result, ok = aasstringification.DataTypeIEC61360FromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeIEC61360, " +
				"but got %v",
				text,
			),
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.ILevelType],
// or return an error.
func LevelTypeFromJsonable(
	jsonable interface{},
) (
	result aastypes.ILevelType,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = levelTypeFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ILevelType] from a map,
// or return an error, if any.
func levelTypeFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ILevelType,
	err *DeserializationError,
) {
	var theMin bool
	var theNom bool
	var theTyp bool
	var theMax bool

	foundMin := false
	foundNom := false
	foundTyp := false
	foundMax := false

	for k, v := range m {
		switch k {
		case "min":
			theMin, err = boolFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "min",
					},
				)
				return
			}
			foundMin = true

		case "nom":
			theNom, err = boolFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "nom",
					},
				)
				return
			}
			foundNom = true

		case "typ":
			theTyp, err = boolFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "typ",
					},
				)
				return
			}
			foundTyp = true

		case "max":
			theMax, err = boolFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "max",
					},
				)
				return
			}
			foundMax = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundMin {
		err = newDeserializationError(
			"The required property 'min' is missing",
		)
		return
	}

	if !foundNom {
		err = newDeserializationError(
			"The required property 'nom' is missing",
		)
		return
	}

	if !foundTyp {
		err = newDeserializationError(
			"The required property 'typ' is missing",
		)
		return
	}

	if !foundMax {
		err = newDeserializationError(
			"The required property 'max' is missing",
		)
		return
	}

	result = aastypes.NewLevelType(
		theMin,
		theNom,
		theTyp,
		theMax,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IValueReferencePair],
// or return an error.
func ValueReferencePairFromJsonable(
	jsonable interface{},
) (
	result aastypes.IValueReferencePair,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = valueReferencePairFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IValueReferencePair] from a map,
// or return an error, if any.
func valueReferencePairFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IValueReferencePair,
	err *DeserializationError,
) {
	var theValue string
	var theValueID aastypes.IReference

	foundValue := false
	foundValueID := false

	for k, v := range m {
		switch k {
		case "value":
			theValue, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			foundValue = true

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId",
					},
				)
				return
			}
			foundValueID = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	if !foundValueID {
		err = newDeserializationError(
			"The required property 'valueId' is missing",
		)
		return
	}

	result = aastypes.NewValueReferencePair(
		theValue,
		theValueID,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IValueList],
// or return an error.
func ValueListFromJsonable(
	jsonable interface{},
) (
	result aastypes.IValueList,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = valueListFromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IValueList] from a map,
// or return an error, if any.
func valueListFromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IValueList,
	err *DeserializationError,
) {
	var theValueReferencePairs []aastypes.IValueReferencePair

	foundValueReferencePairs := false

	for k, v := range m {
		switch k {
		case "valueReferencePairs":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueReferencePairs",
					},
				)

				return
			}

			array := make(
				[]aastypes.IValueReferencePair,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.IValueReferencePair
				item, err = ValueReferencePairFromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "valueReferencePairs",
						},
					)

					return
				}

				array[i] = item
			}
			theValueReferencePairs = array
			foundValueReferencePairs = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundValueReferencePairs {
		err = newDeserializationError(
			"The required property 'valueReferencePairs' is missing",
		)
		return
	}

	result = aastypes.NewValueList(
		theValueReferencePairs,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringPreferredNameTypeIEC61360],
// or return an error.
func LangStringPreferredNameTypeIEC61360FromJsonable(
	jsonable interface{},
) (
	result aastypes.ILangStringPreferredNameTypeIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = langStringPreferredNameTypeIEC61360FromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ILangStringPreferredNameTypeIEC61360] from a map,
// or return an error, if any.
func langStringPreferredNameTypeIEC61360FromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ILangStringPreferredNameTypeIEC61360,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range m {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language",
					},
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text",
					},
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	result = aastypes.NewLangStringPreferredNameTypeIEC61360(
		theLanguage,
		theText,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringShortNameTypeIEC61360],
// or return an error.
func LangStringShortNameTypeIEC61360FromJsonable(
	jsonable interface{},
) (
	result aastypes.ILangStringShortNameTypeIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = langStringShortNameTypeIEC61360FromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ILangStringShortNameTypeIEC61360] from a map,
// or return an error, if any.
func langStringShortNameTypeIEC61360FromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ILangStringShortNameTypeIEC61360,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range m {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language",
					},
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text",
					},
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	result = aastypes.NewLangStringShortNameTypeIEC61360(
		theLanguage,
		theText,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringDefinitionTypeIEC61360],
// or return an error.
func LangStringDefinitionTypeIEC61360FromJsonable(
	jsonable interface{},
) (
	result aastypes.ILangStringDefinitionTypeIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = langStringDefinitionTypeIEC61360FromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.ILangStringDefinitionTypeIEC61360] from a map,
// or return an error, if any.
func langStringDefinitionTypeIEC61360FromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.ILangStringDefinitionTypeIEC61360,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range m {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language",
					},
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text",
					},
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	result = aastypes.NewLangStringDefinitionTypeIEC61360(
		theLanguage,
		theText,
	)

	return
}

// Parse `jsonable` as an instance of [aastypes.IDataSpecificationIEC61360],
// or return an error.
func DataSpecificationIEC61360FromJsonable(
	jsonable interface{},
) (
	result aastypes.IDataSpecificationIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null",
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T",
				jsonable,
			),
		)
		return
	}

	result, err = dataSpecificationIEC61360FromMapWithoutDispatch(m)

	return
}

// Parse [aastypes.IDataSpecificationIEC61360] from a map,
// or return an error, if any.
func dataSpecificationIEC61360FromMapWithoutDispatch(
	m map[string]interface{},
) (
	result aastypes.IDataSpecificationIEC61360,
	err *DeserializationError,
) {
	var thePreferredName []aastypes.ILangStringPreferredNameTypeIEC61360
	var theShortName []aastypes.ILangStringShortNameTypeIEC61360
	var theUnit *string
	var theUnitID aastypes.IReference
	var theSourceOfDefinition *string
	var theSymbol *string
	var theDataType *aastypes.DataTypeIEC61360
	var theDefinition []aastypes.ILangStringDefinitionTypeIEC61360
	var theValueFormat *string
	var theValueList aastypes.IValueList
	var theValue *string
	var theLevelType aastypes.ILevelType

	foundPreferredName := false

	for k, v := range m {
		switch k {
		case "preferredName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "preferredName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringPreferredNameTypeIEC61360,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringPreferredNameTypeIEC61360
				item, err = LangStringPreferredNameTypeIEC61360FromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "preferredName",
						},
					)

					return
				}

				array[i] = item
			}
			thePreferredName = array
			foundPreferredName = true

		case "shortName":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "shortName",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringShortNameTypeIEC61360,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringShortNameTypeIEC61360
				item, err = LangStringShortNameTypeIEC61360FromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "shortName",
						},
					)

					return
				}

				array[i] = item
			}
			theShortName = array

		case "unit":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "unit",
					},
				)
				return
			}
			theUnit = &parsed

		case "unitId":
			theUnitID, err = ReferenceFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "unitId",
					},
				)
				return
			}

		case "sourceOfDefinition":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "sourceOfDefinition",
					},
				)
				return
			}
			theSourceOfDefinition = &parsed

		case "symbol":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "symbol",
					},
				)
				return
			}
			theSymbol = &parsed

		case "dataType":
			var parsed aastypes.DataTypeIEC61360
			parsed, err = DataTypeIEC61360FromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "dataType",
					},
				)
				return
			}
			theDataType = &parsed

		case "definition":
			jsonableArray, ok := v.([]interface{})
			if !ok {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v,
					),
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "definition",
					},
				)

				return
			}

			array := make(
				[]aastypes.ILangStringDefinitionTypeIEC61360,
				len(jsonableArray),
			)
			for i, itemJsonable := range jsonableArray {
				var item aastypes.ILangStringDefinitionTypeIEC61360
				item, err = LangStringDefinitionTypeIEC61360FromJsonable(
					itemJsonable,
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "definition",
						},
					)

					return
				}

				array[i] = item
			}
			theDefinition = array

		case "valueFormat":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueFormat",
					},
				)
				return
			}
			theValueFormat = &parsed

		case "valueList":
			theValueList, err = ValueListFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueList",
					},
				)
				return
			}

		case "value":
			var parsed string
			parsed, err = stringFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value",
					},
				)
				return
			}
			theValue = &parsed

		case "levelType":
			theLevelType, err = LevelTypeFromJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "levelType",
					},
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k,
				),
			)
			return
		}
	}

	if !foundPreferredName {
		err = newDeserializationError(
			"The required property 'preferredName' is missing",
		)
		return
	}

	result = aastypes.NewDataSpecificationIEC61360(
		thePreferredName,
	)
	result.SetShortName(
		theShortName,
	)
	result.SetUnit(
		theUnit,
	)
	result.SetUnitID(
		theUnitID,
	)
	result.SetSourceOfDefinition(
		theSourceOfDefinition,
	)
	result.SetSymbol(
		theSymbol,
	)
	result.SetDataType(
		theDataType,
	)
	result.SetDefinition(
		theDefinition,
	)
	result.SetValueFormat(
		theValueFormat,
	)
	result.SetValueList(
		theValueList,
	)
	result.SetValue(
		theValue,
	)
	result.SetLevelType(
		theLevelType,
	)

	return
}

// De-serialize an instance of [aastypes.IHasSemantics]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func hasSemanticsFromMap(
	m map[string]interface{},
) (
	result aastypes.IHasSemantics,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "Capability":
		result, err = capabilityFromMapWithoutDispatch(m)
	case "Entity":
		result, err = entityFromMapWithoutDispatch(m)
	case "Extension":
		result, err = extensionFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Operation":
		result, err = operationFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Qualifier":
		result, err = qualifierFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	case "SpecificAssetId":
		result, err = specificAssetIDFromMapWithoutDispatch(m)
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	case "SubmodelElementCollection":
		result, err = submodelElementCollectionFromMapWithoutDispatch(m)
	case "SubmodelElementList":
		result, err = submodelElementListFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IHasSemantics: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IHasExtensions]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func hasExtensionsFromMap(
	m map[string]interface{},
) (
	result aastypes.IHasExtensions,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "AssetAdministrationShell":
		result, err = assetAdministrationShellFromMapWithoutDispatch(m)
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "Capability":
		result, err = capabilityFromMapWithoutDispatch(m)
	case "ConceptDescription":
		result, err = conceptDescriptionFromMapWithoutDispatch(m)
	case "Entity":
		result, err = entityFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Operation":
		result, err = operationFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	case "SubmodelElementCollection":
		result, err = submodelElementCollectionFromMapWithoutDispatch(m)
	case "SubmodelElementList":
		result, err = submodelElementListFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IHasExtensions: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IReferable]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func referableFromMap(
	m map[string]interface{},
) (
	result aastypes.IReferable,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "AssetAdministrationShell":
		result, err = assetAdministrationShellFromMapWithoutDispatch(m)
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "Capability":
		result, err = capabilityFromMapWithoutDispatch(m)
	case "ConceptDescription":
		result, err = conceptDescriptionFromMapWithoutDispatch(m)
	case "Entity":
		result, err = entityFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Operation":
		result, err = operationFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	case "SubmodelElementCollection":
		result, err = submodelElementCollectionFromMapWithoutDispatch(m)
	case "SubmodelElementList":
		result, err = submodelElementListFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IReferable: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IIdentifiable]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func identifiableFromMap(
	m map[string]interface{},
) (
	result aastypes.IIdentifiable,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "AssetAdministrationShell":
		result, err = assetAdministrationShellFromMapWithoutDispatch(m)
	case "ConceptDescription":
		result, err = conceptDescriptionFromMapWithoutDispatch(m)
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IIdentifiable: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IHasKind]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func hasKindFromMap(
	m map[string]interface{},
) (
	result aastypes.IHasKind,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IHasKind: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IHasDataSpecification]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func hasDataSpecificationFromMap(
	m map[string]interface{},
) (
	result aastypes.IHasDataSpecification,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "AdministrativeInformation":
		result, err = administrativeInformationFromMapWithoutDispatch(m)
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "AssetAdministrationShell":
		result, err = assetAdministrationShellFromMapWithoutDispatch(m)
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "Capability":
		result, err = capabilityFromMapWithoutDispatch(m)
	case "ConceptDescription":
		result, err = conceptDescriptionFromMapWithoutDispatch(m)
	case "Entity":
		result, err = entityFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Operation":
		result, err = operationFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	case "SubmodelElementCollection":
		result, err = submodelElementCollectionFromMapWithoutDispatch(m)
	case "SubmodelElementList":
		result, err = submodelElementListFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IHasDataSpecification: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IQualifiable]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func qualifiableFromMap(
	m map[string]interface{},
) (
	result aastypes.IQualifiable,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "Capability":
		result, err = capabilityFromMapWithoutDispatch(m)
	case "Entity":
		result, err = entityFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Operation":
		result, err = operationFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	case "Submodel":
		result, err = submodelFromMapWithoutDispatch(m)
	case "SubmodelElementCollection":
		result, err = submodelElementCollectionFromMapWithoutDispatch(m)
	case "SubmodelElementList":
		result, err = submodelElementListFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IQualifiable: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.ISubmodelElement]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func submodelElementFromMap(
	m map[string]interface{},
) (
	result aastypes.ISubmodelElement,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "Capability":
		result, err = capabilityFromMapWithoutDispatch(m)
	case "Entity":
		result, err = entityFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Operation":
		result, err = operationFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	case "SubmodelElementCollection":
		result, err = submodelElementCollectionFromMapWithoutDispatch(m)
	case "SubmodelElementList":
		result, err = submodelElementListFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for ISubmodelElement: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IRelationshipElement]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func relationshipElementFromMap(
	m map[string]interface{},
) (
	result aastypes.IRelationshipElement,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "AnnotatedRelationshipElement":
		result, err = annotatedRelationshipElementFromMapWithoutDispatch(m)
	case "RelationshipElement":
		result, err = relationshipElementFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IRelationshipElement: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IDataElement]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func dataElementFromMap(
	m map[string]interface{},
) (
	result aastypes.IDataElement,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "Blob":
		result, err = blobFromMapWithoutDispatch(m)
	case "File":
		result, err = fileFromMapWithoutDispatch(m)
	case "MultiLanguageProperty":
		result, err = multiLanguagePropertyFromMapWithoutDispatch(m)
	case "Property":
		result, err = propertyFromMapWithoutDispatch(m)
	case "Range":
		result, err = rangeFromMapWithoutDispatch(m)
	case "ReferenceElement":
		result, err = referenceElementFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IDataElement: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IEventElement]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func eventElementFromMap(
	m map[string]interface{},
) (
	result aastypes.IEventElement,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "BasicEventElement":
		result, err = basicEventElementFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IEventElement: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IAbstractLangString]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func abstractLangStringFromMap(
	m map[string]interface{},
) (
	result aastypes.IAbstractLangString,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "LangStringDefinitionTypeIec61360":
		result, err = langStringDefinitionTypeIEC61360FromMapWithoutDispatch(m)
	case "LangStringNameType":
		result, err = langStringNameTypeFromMapWithoutDispatch(m)
	case "LangStringPreferredNameTypeIec61360":
		result, err = langStringPreferredNameTypeIEC61360FromMapWithoutDispatch(m)
	case "LangStringShortNameTypeIec61360":
		result, err = langStringShortNameTypeIEC61360FromMapWithoutDispatch(m)
	case "LangStringTextType":
		result, err = langStringTextTypeFromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IAbstractLangString: %s",
				modelType,
			),
		)
	}

	return
}

// De-serialize an instance of [aastypes.IDataSpecificationContent]
// from a map by dispatching to the concrete `*FromMapWithoutDispatch` function.
func dataSpecificationContentFromMap(
	m map[string]interface{},
) (
	result aastypes.IDataSpecificationContent,
	err *DeserializationError,
) {
	var modelTypeAny interface{}
	var ok bool
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none",
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T",
				modelTypeAny,
			),
		)
		return
	}

	switch modelType {
	case "DataSpecificationIec61360":
		result, err = dataSpecificationIEC61360FromMapWithoutDispatch(m)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected model type " +
				"for IDataSpecificationContent: %s",
				modelType,
			),
		)
	}

	return
}

// endregion

// region Serialization

// Represent an error during the serialization.
//
// Implements `error`.
type SerializationError struct{
	Path *aasreporting.Path
	Message string
}

func newSerializationError(message string) *SerializationError {
	return &SerializationError{
		Path: &aasreporting.Path{},
		Message: message,
	}
}

func (se *SerializationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		se.PathString(),
		se.Message,
	)
}

// Render the path as a string.
func (se *SerializationError) PathString() string {
	return aasreporting.ToGolangPath(se.Path)
}

// Try to cast `that` to a float64, or return an error.
func int64ToJsonable(
	that int64,
) (result float64, err *SerializationError) {
	if that > 9007199254740991 || that < -9007199254740991 {
		err = newSerializationError(
			fmt.Sprintf(
				"64-bit integer can not be represented as 64-bit float in JSON: %v",
				that,
			),
		)
		return
	}

	result = float64(that);
	return
}

// Encode `bytes` to a base64 string.
func bytesToJsonable(
	bytes []byte,
) (result string, err *SerializationError) {
	if bytes == nil {
		err = newSerializationError(
			"Expected an array of bytes, but got nil",
		)
		return
	}

	result = b64.StdEncoding.EncodeToString(
		bytes,
	)
	return
}

// Serialize `that` to a string, or return an error.
func ModellingKindToJsonable(
	that aastypes.ModellingKind,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.ModellingKindToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of ModellingKind: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func QualifierKindToJsonable(
	that aastypes.QualifierKind,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.QualifierKindToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of QualifierKind: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func AssetKindToJsonable(
	that aastypes.AssetKind,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.AssetKindToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of AssetKind: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func AASSubmodelElementsToJsonable(
	that aastypes.AASSubmodelElements,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.AASSubmodelElementsToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of AASSubmodelElements: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func EntityTypeToJsonable(
	that aastypes.EntityType,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.EntityTypeToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of EntityType: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func DirectionToJsonable(
	that aastypes.Direction,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.DirectionToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of Direction: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func StateOfEventToJsonable(
	that aastypes.StateOfEvent,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.StateOfEventToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of StateOfEvent: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func ReferenceTypesToJsonable(
	that aastypes.ReferenceTypes,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.ReferenceTypesToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of ReferenceTypes: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func KeyTypesToJsonable(
	that aastypes.KeyTypes,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.KeyTypesToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of KeyTypes: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func DataTypeDefXSDToJsonable(
	that aastypes.DataTypeDefXSD,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.DataTypeDefXSDToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of DataTypeDefXSD: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize `that` to a string, or return an error.
func DataTypeIEC61360ToJsonable(
	that aastypes.DataTypeIEC61360,
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.DataTypeIEC61360ToString(
		that,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Got an invalid literal of DataTypeIEC61360: %v",
				that,
			),
		)
		return
	}

	return
}

// Serialize [aastypes.IExtension] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IExtension] with proper dispatch, call
// [ToJsonable].
func extensionToMap(
	that aastypes.IExtension,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	result["name"] = that.Name()

	if that.ValueType() != nil {
		var jsonableValueType interface{}
		jsonableValueType, err = DataTypeDefXSDToJsonable(
			*(that.ValueType()),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueType()",
				},
			)

			return
		}
		result["valueType"] = jsonableValueType
	}

	if that.Value() != nil {
		result["value"] = *that.Value()
	}

	if that.RefersTo() != nil {
		jsonableRefersTo := make(
			[]interface{},
			len(that.RefersTo()),
		)
		for i, v := range that.RefersTo() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "RefersTo()",
					},
				)

				return
			}
			jsonableRefersTo[i] = jsonable
		}
		result["refersTo"] = jsonableRefersTo
	}

	return
}

// Serialize [aastypes.IAdministrativeInformation] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAdministrativeInformation] with proper dispatch, call
// [ToJsonable].
func administrativeInformationToMap(
	that aastypes.IAdministrativeInformation,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Version() != nil {
		result["version"] = *that.Version()
	}

	if that.Revision() != nil {
		result["revision"] = *that.Revision()
	}

	if that.Creator() != nil {
		var jsonableCreator interface{}
		jsonableCreator, err = ToJsonable(
			that.Creator(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Creator()",
				},
			)

			return
		}
		result["creator"] = jsonableCreator
	}

	if that.TemplateID() != nil {
		result["templateId"] = *that.TemplateID()
	}

	return
}

// Serialize [aastypes.IQualifier] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IQualifier] with proper dispatch, call
// [ToJsonable].
func qualifierToMap(
	that aastypes.IQualifier,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Kind() != nil {
		var jsonableKind interface{}
		jsonableKind, err = QualifierKindToJsonable(
			*(that.Kind()),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Kind()",
				},
			)

			return
		}
		result["kind"] = jsonableKind
	}

	result["type"] = that.Type()

	var jsonableValueType interface{}
	jsonableValueType, err = DataTypeDefXSDToJsonable(
		that.ValueType(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType()",
			},
		)

		return
	}
	result["valueType"] = jsonableValueType

	if that.Value() != nil {
		result["value"] = *that.Value()
	}

	if that.ValueID() != nil {
		var jsonableValueID interface{}
		jsonableValueID, err = ToJsonable(
			that.ValueID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID()",
				},
			)

			return
		}
		result["valueId"] = jsonableValueID
	}

	return
}

// Serialize [aastypes.IAssetAdministrationShell] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAssetAdministrationShell] with proper dispatch, call
// [ToJsonable].
func assetAdministrationShellToMap(
	that aastypes.IAssetAdministrationShell,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.Administration() != nil {
		var jsonableAdministration interface{}
		jsonableAdministration, err = ToJsonable(
			that.Administration(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Administration()",
				},
			)

			return
		}
		result["administration"] = jsonableAdministration
	}

	result["id"] = that.ID()

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.DerivedFrom() != nil {
		var jsonableDerivedFrom interface{}
		jsonableDerivedFrom, err = ToJsonable(
			that.DerivedFrom(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DerivedFrom()",
				},
			)

			return
		}
		result["derivedFrom"] = jsonableDerivedFrom
	}

	var jsonableAssetInformation interface{}
	jsonableAssetInformation, err = ToJsonable(
		that.AssetInformation(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "AssetInformation()",
			},
		)

		return
	}
	result["assetInformation"] = jsonableAssetInformation

	if that.Submodels() != nil {
		jsonableSubmodels := make(
			[]interface{},
			len(that.Submodels()),
		)
		for i, v := range that.Submodels() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Submodels()",
					},
				)

				return
			}
			jsonableSubmodels[i] = jsonable
		}
		result["submodels"] = jsonableSubmodels
	}

	result["modelType"] = "AssetAdministrationShell"

	return
}

// Serialize [aastypes.IAssetInformation] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAssetInformation] with proper dispatch, call
// [ToJsonable].
func assetInformationToMap(
	that aastypes.IAssetInformation,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	var jsonableAssetKind interface{}
	jsonableAssetKind, err = AssetKindToJsonable(
		that.AssetKind(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "AssetKind()",
			},
		)

		return
	}
	result["assetKind"] = jsonableAssetKind

	if that.GlobalAssetID() != nil {
		result["globalAssetId"] = *that.GlobalAssetID()
	}

	if that.SpecificAssetIDs() != nil {
		jsonableSpecificAssetIDs := make(
			[]interface{},
			len(that.SpecificAssetIDs()),
		)
		for i, v := range that.SpecificAssetIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SpecificAssetIDs()",
					},
				)

				return
			}
			jsonableSpecificAssetIDs[i] = jsonable
		}
		result["specificAssetIds"] = jsonableSpecificAssetIDs
	}

	if that.AssetType() != nil {
		result["assetType"] = *that.AssetType()
	}

	if that.DefaultThumbnail() != nil {
		var jsonableDefaultThumbnail interface{}
		jsonableDefaultThumbnail, err = ToJsonable(
			that.DefaultThumbnail(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DefaultThumbnail()",
				},
			)

			return
		}
		result["defaultThumbnail"] = jsonableDefaultThumbnail
	}

	return
}

// Serialize [aastypes.IResource] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IResource] with proper dispatch, call
// [ToJsonable].
func resourceToMap(
	that aastypes.IResource,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["path"] = that.Path()

	if that.ContentType() != nil {
		result["contentType"] = *that.ContentType()
	}

	return
}

// Serialize [aastypes.ISpecificAssetID] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISpecificAssetID] with proper dispatch, call
// [ToJsonable].
func specificAssetIDToMap(
	that aastypes.ISpecificAssetID,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	result["name"] = that.Name()

	result["value"] = that.Value()

	if that.ExternalSubjectID() != nil {
		var jsonableExternalSubjectID interface{}
		jsonableExternalSubjectID, err = ToJsonable(
			that.ExternalSubjectID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ExternalSubjectID()",
				},
			)

			return
		}
		result["externalSubjectId"] = jsonableExternalSubjectID
	}

	return
}

// Serialize [aastypes.ISubmodel] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISubmodel] with proper dispatch, call
// [ToJsonable].
func submodelToMap(
	that aastypes.ISubmodel,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.Administration() != nil {
		var jsonableAdministration interface{}
		jsonableAdministration, err = ToJsonable(
			that.Administration(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Administration()",
				},
			)

			return
		}
		result["administration"] = jsonableAdministration
	}

	result["id"] = that.ID()

	if that.Kind() != nil {
		var jsonableKind interface{}
		jsonableKind, err = ModellingKindToJsonable(
			*(that.Kind()),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Kind()",
				},
			)

			return
		}
		result["kind"] = jsonableKind
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.SubmodelElements() != nil {
		jsonableSubmodelElements := make(
			[]interface{},
			len(that.SubmodelElements()),
		)
		for i, v := range that.SubmodelElements() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SubmodelElements()",
					},
				)

				return
			}
			jsonableSubmodelElements[i] = jsonable
		}
		result["submodelElements"] = jsonableSubmodelElements
	}

	result["modelType"] = "Submodel"

	return
}

// Serialize [aastypes.IRelationshipElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IRelationshipElement] with proper dispatch, call
// [ToJsonable].
func relationshipElementToMap(
	that aastypes.IRelationshipElement,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	var jsonableFirst interface{}
	jsonableFirst, err = ToJsonable(
		that.First(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "First()",
			},
		)

		return
	}
	result["first"] = jsonableFirst

	var jsonableSecond interface{}
	jsonableSecond, err = ToJsonable(
		that.Second(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Second()",
			},
		)

		return
	}
	result["second"] = jsonableSecond

	result["modelType"] = "RelationshipElement"

	return
}

// Serialize [aastypes.ISubmodelElementList] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISubmodelElementList] with proper dispatch, call
// [ToJsonable].
func submodelElementListToMap(
	that aastypes.ISubmodelElementList,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.OrderRelevant() != nil {
		result["orderRelevant"] = *that.OrderRelevant()
	}

	if that.SemanticIDListElement() != nil {
		var jsonableSemanticIDListElement interface{}
		jsonableSemanticIDListElement, err = ToJsonable(
			that.SemanticIDListElement(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticIDListElement()",
				},
			)

			return
		}
		result["semanticIdListElement"] = jsonableSemanticIDListElement
	}

	var jsonableTypeValueListElement interface{}
	jsonableTypeValueListElement, err = AASSubmodelElementsToJsonable(
		that.TypeValueListElement(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "TypeValueListElement()",
			},
		)

		return
	}
	result["typeValueListElement"] = jsonableTypeValueListElement

	if that.ValueTypeListElement() != nil {
		var jsonableValueTypeListElement interface{}
		jsonableValueTypeListElement, err = DataTypeDefXSDToJsonable(
			*(that.ValueTypeListElement()),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueTypeListElement()",
				},
			)

			return
		}
		result["valueTypeListElement"] = jsonableValueTypeListElement
	}

	if that.Value() != nil {
		jsonableValue := make(
			[]interface{},
			len(that.Value()),
		)
		for i, v := range that.Value() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)

				return
			}
			jsonableValue[i] = jsonable
		}
		result["value"] = jsonableValue
	}

	result["modelType"] = "SubmodelElementList"

	return
}

// Serialize [aastypes.ISubmodelElementCollection] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISubmodelElementCollection] with proper dispatch, call
// [ToJsonable].
func submodelElementCollectionToMap(
	that aastypes.ISubmodelElementCollection,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Value() != nil {
		jsonableValue := make(
			[]interface{},
			len(that.Value()),
		)
		for i, v := range that.Value() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)

				return
			}
			jsonableValue[i] = jsonable
		}
		result["value"] = jsonableValue
	}

	result["modelType"] = "SubmodelElementCollection"

	return
}

// Serialize [aastypes.IProperty] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IProperty] with proper dispatch, call
// [ToJsonable].
func propertyToMap(
	that aastypes.IProperty,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	var jsonableValueType interface{}
	jsonableValueType, err = DataTypeDefXSDToJsonable(
		that.ValueType(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType()",
			},
		)

		return
	}
	result["valueType"] = jsonableValueType

	if that.Value() != nil {
		result["value"] = *that.Value()
	}

	if that.ValueID() != nil {
		var jsonableValueID interface{}
		jsonableValueID, err = ToJsonable(
			that.ValueID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID()",
				},
			)

			return
		}
		result["valueId"] = jsonableValueID
	}

	result["modelType"] = "Property"

	return
}

// Serialize [aastypes.IMultiLanguageProperty] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IMultiLanguageProperty] with proper dispatch, call
// [ToJsonable].
func multiLanguagePropertyToMap(
	that aastypes.IMultiLanguageProperty,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Value() != nil {
		jsonableValue := make(
			[]interface{},
			len(that.Value()),
		)
		for i, v := range that.Value() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)

				return
			}
			jsonableValue[i] = jsonable
		}
		result["value"] = jsonableValue
	}

	if that.ValueID() != nil {
		var jsonableValueID interface{}
		jsonableValueID, err = ToJsonable(
			that.ValueID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID()",
				},
			)

			return
		}
		result["valueId"] = jsonableValueID
	}

	result["modelType"] = "MultiLanguageProperty"

	return
}

// Serialize [aastypes.IRange] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IRange] with proper dispatch, call
// [ToJsonable].
func rangeToMap(
	that aastypes.IRange,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	var jsonableValueType interface{}
	jsonableValueType, err = DataTypeDefXSDToJsonable(
		that.ValueType(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType()",
			},
		)

		return
	}
	result["valueType"] = jsonableValueType

	if that.Min() != nil {
		result["min"] = *that.Min()
	}

	if that.Max() != nil {
		result["max"] = *that.Max()
	}

	result["modelType"] = "Range"

	return
}

// Serialize [aastypes.IReferenceElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IReferenceElement] with proper dispatch, call
// [ToJsonable].
func referenceElementToMap(
	that aastypes.IReferenceElement,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Value() != nil {
		var jsonableValue interface{}
		jsonableValue, err = ToJsonable(
			that.Value(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value()",
				},
			)

			return
		}
		result["value"] = jsonableValue
	}

	result["modelType"] = "ReferenceElement"

	return
}

// Serialize [aastypes.IBlob] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IBlob] with proper dispatch, call
// [ToJsonable].
func blobToMap(
	that aastypes.IBlob,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Value() != nil {
		var jsonableValue interface{}
		jsonableValue, err = bytesToJsonable(
			that.Value(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value()",
				},
			)

			return
		}
		result["value"] = jsonableValue
	}

	result["contentType"] = that.ContentType()

	result["modelType"] = "Blob"

	return
}

// Serialize [aastypes.IFile] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IFile] with proper dispatch, call
// [ToJsonable].
func fileToMap(
	that aastypes.IFile,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Value() != nil {
		result["value"] = *that.Value()
	}

	result["contentType"] = that.ContentType()

	result["modelType"] = "File"

	return
}

// Serialize [aastypes.IAnnotatedRelationshipElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAnnotatedRelationshipElement] with proper dispatch, call
// [ToJsonable].
func annotatedRelationshipElementToMap(
	that aastypes.IAnnotatedRelationshipElement,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	var jsonableFirst interface{}
	jsonableFirst, err = ToJsonable(
		that.First(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "First()",
			},
		)

		return
	}
	result["first"] = jsonableFirst

	var jsonableSecond interface{}
	jsonableSecond, err = ToJsonable(
		that.Second(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Second()",
			},
		)

		return
	}
	result["second"] = jsonableSecond

	if that.Annotations() != nil {
		jsonableAnnotations := make(
			[]interface{},
			len(that.Annotations()),
		)
		for i, v := range that.Annotations() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Annotations()",
					},
				)

				return
			}
			jsonableAnnotations[i] = jsonable
		}
		result["annotations"] = jsonableAnnotations
	}

	result["modelType"] = "AnnotatedRelationshipElement"

	return
}

// Serialize [aastypes.IEntity] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEntity] with proper dispatch, call
// [ToJsonable].
func entityToMap(
	that aastypes.IEntity,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.Statements() != nil {
		jsonableStatements := make(
			[]interface{},
			len(that.Statements()),
		)
		for i, v := range that.Statements() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Statements()",
					},
				)

				return
			}
			jsonableStatements[i] = jsonable
		}
		result["statements"] = jsonableStatements
	}

	var jsonableEntityType interface{}
	jsonableEntityType, err = EntityTypeToJsonable(
		that.EntityType(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "EntityType()",
			},
		)

		return
	}
	result["entityType"] = jsonableEntityType

	if that.GlobalAssetID() != nil {
		result["globalAssetId"] = *that.GlobalAssetID()
	}

	if that.SpecificAssetIDs() != nil {
		jsonableSpecificAssetIDs := make(
			[]interface{},
			len(that.SpecificAssetIDs()),
		)
		for i, v := range that.SpecificAssetIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SpecificAssetIDs()",
					},
				)

				return
			}
			jsonableSpecificAssetIDs[i] = jsonable
		}
		result["specificAssetIds"] = jsonableSpecificAssetIDs
	}

	result["modelType"] = "Entity"

	return
}

// Serialize [aastypes.IEventPayload] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEventPayload] with proper dispatch, call
// [ToJsonable].
func eventPayloadToMap(
	that aastypes.IEventPayload,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	var jsonableSource interface{}
	jsonableSource, err = ToJsonable(
		that.Source(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Source()",
			},
		)

		return
	}
	result["source"] = jsonableSource

	if that.SourceSemanticID() != nil {
		var jsonableSourceSemanticID interface{}
		jsonableSourceSemanticID, err = ToJsonable(
			that.SourceSemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SourceSemanticID()",
				},
			)

			return
		}
		result["sourceSemanticId"] = jsonableSourceSemanticID
	}

	var jsonableObservableReference interface{}
	jsonableObservableReference, err = ToJsonable(
		that.ObservableReference(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ObservableReference()",
			},
		)

		return
	}
	result["observableReference"] = jsonableObservableReference

	if that.ObservableSemanticID() != nil {
		var jsonableObservableSemanticID interface{}
		jsonableObservableSemanticID, err = ToJsonable(
			that.ObservableSemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ObservableSemanticID()",
				},
			)

			return
		}
		result["observableSemanticId"] = jsonableObservableSemanticID
	}

	if that.Topic() != nil {
		result["topic"] = *that.Topic()
	}

	if that.SubjectID() != nil {
		var jsonableSubjectID interface{}
		jsonableSubjectID, err = ToJsonable(
			that.SubjectID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SubjectID()",
				},
			)

			return
		}
		result["subjectId"] = jsonableSubjectID
	}

	result["timeStamp"] = that.TimeStamp()

	if that.Payload() != nil {
		var jsonablePayload interface{}
		jsonablePayload, err = bytesToJsonable(
			that.Payload(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Payload()",
				},
			)

			return
		}
		result["payload"] = jsonablePayload
	}

	return
}

// Serialize [aastypes.IBasicEventElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IBasicEventElement] with proper dispatch, call
// [ToJsonable].
func basicEventElementToMap(
	that aastypes.IBasicEventElement,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	var jsonableObserved interface{}
	jsonableObserved, err = ToJsonable(
		that.Observed(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Observed()",
			},
		)

		return
	}
	result["observed"] = jsonableObserved

	var jsonableDirection interface{}
	jsonableDirection, err = DirectionToJsonable(
		that.Direction(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Direction()",
			},
		)

		return
	}
	result["direction"] = jsonableDirection

	var jsonableState interface{}
	jsonableState, err = StateOfEventToJsonable(
		that.State(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "State()",
			},
		)

		return
	}
	result["state"] = jsonableState

	if that.MessageTopic() != nil {
		result["messageTopic"] = *that.MessageTopic()
	}

	if that.MessageBroker() != nil {
		var jsonableMessageBroker interface{}
		jsonableMessageBroker, err = ToJsonable(
			that.MessageBroker(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "MessageBroker()",
				},
			)

			return
		}
		result["messageBroker"] = jsonableMessageBroker
	}

	if that.LastUpdate() != nil {
		result["lastUpdate"] = *that.LastUpdate()
	}

	if that.MinInterval() != nil {
		result["minInterval"] = *that.MinInterval()
	}

	if that.MaxInterval() != nil {
		result["maxInterval"] = *that.MaxInterval()
	}

	result["modelType"] = "BasicEventElement"

	return
}

// Serialize [aastypes.IOperation] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IOperation] with proper dispatch, call
// [ToJsonable].
func operationToMap(
	that aastypes.IOperation,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.InputVariables() != nil {
		jsonableInputVariables := make(
			[]interface{},
			len(that.InputVariables()),
		)
		for i, v := range that.InputVariables() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "InputVariables()",
					},
				)

				return
			}
			jsonableInputVariables[i] = jsonable
		}
		result["inputVariables"] = jsonableInputVariables
	}

	if that.OutputVariables() != nil {
		jsonableOutputVariables := make(
			[]interface{},
			len(that.OutputVariables()),
		)
		for i, v := range that.OutputVariables() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "OutputVariables()",
					},
				)

				return
			}
			jsonableOutputVariables[i] = jsonable
		}
		result["outputVariables"] = jsonableOutputVariables
	}

	if that.InoutputVariables() != nil {
		jsonableInoutputVariables := make(
			[]interface{},
			len(that.InoutputVariables()),
		)
		for i, v := range that.InoutputVariables() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "InoutputVariables()",
					},
				)

				return
			}
			jsonableInoutputVariables[i] = jsonable
		}
		result["inoutputVariables"] = jsonableInoutputVariables
	}

	result["modelType"] = "Operation"

	return
}

// Serialize [aastypes.IOperationVariable] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IOperationVariable] with proper dispatch, call
// [ToJsonable].
func operationVariableToMap(
	that aastypes.IOperationVariable,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	var jsonableValue interface{}
	jsonableValue, err = ToJsonable(
		that.Value(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Value()",
			},
		)

		return
	}
	result["value"] = jsonableValue

	return
}

// Serialize [aastypes.ICapability] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ICapability] with proper dispatch, call
// [ToJsonable].
func capabilityToMap(
	that aastypes.ICapability,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.SemanticID() != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ToJsonable(
			that.SemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID()",
				},
			)

			return
		}
		result["semanticId"] = jsonableSemanticID
	}

	if that.SupplementalSemanticIDs() != nil {
		jsonableSupplementalSemanticIDs := make(
			[]interface{},
			len(that.SupplementalSemanticIDs()),
		)
		for i, v := range that.SupplementalSemanticIDs() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)

				return
			}
			jsonableSupplementalSemanticIDs[i] = jsonable
		}
		result["supplementalSemanticIds"] = jsonableSupplementalSemanticIDs
	}

	if that.Qualifiers() != nil {
		jsonableQualifiers := make(
			[]interface{},
			len(that.Qualifiers()),
		)
		for i, v := range that.Qualifiers() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)

				return
			}
			jsonableQualifiers[i] = jsonable
		}
		result["qualifiers"] = jsonableQualifiers
	}

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	result["modelType"] = "Capability"

	return
}

// Serialize [aastypes.IConceptDescription] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IConceptDescription] with proper dispatch, call
// [ToJsonable].
func conceptDescriptionToMap(
	that aastypes.IConceptDescription,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.Extensions() != nil {
		jsonableExtensions := make(
			[]interface{},
			len(that.Extensions()),
		)
		for i, v := range that.Extensions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)

				return
			}
			jsonableExtensions[i] = jsonable
		}
		result["extensions"] = jsonableExtensions
	}

	if that.Category() != nil {
		result["category"] = *that.Category()
	}

	if that.IDShort() != nil {
		result["idShort"] = *that.IDShort()
	}

	if that.DisplayName() != nil {
		jsonableDisplayName := make(
			[]interface{},
			len(that.DisplayName()),
		)
		for i, v := range that.DisplayName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)

				return
			}
			jsonableDisplayName[i] = jsonable
		}
		result["displayName"] = jsonableDisplayName
	}

	if that.Description() != nil {
		jsonableDescription := make(
			[]interface{},
			len(that.Description()),
		)
		for i, v := range that.Description() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)

				return
			}
			jsonableDescription[i] = jsonable
		}
		result["description"] = jsonableDescription
	}

	if that.Administration() != nil {
		var jsonableAdministration interface{}
		jsonableAdministration, err = ToJsonable(
			that.Administration(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Administration()",
				},
			)

			return
		}
		result["administration"] = jsonableAdministration
	}

	result["id"] = that.ID()

	if that.EmbeddedDataSpecifications() != nil {
		jsonableEmbeddedDataSpecifications := make(
			[]interface{},
			len(that.EmbeddedDataSpecifications()),
		)
		for i, v := range that.EmbeddedDataSpecifications() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)

				return
			}
			jsonableEmbeddedDataSpecifications[i] = jsonable
		}
		result["embeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	if that.IsCaseOf() != nil {
		jsonableIsCaseOf := make(
			[]interface{},
			len(that.IsCaseOf()),
		)
		for i, v := range that.IsCaseOf() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IsCaseOf()",
					},
				)

				return
			}
			jsonableIsCaseOf[i] = jsonable
		}
		result["isCaseOf"] = jsonableIsCaseOf
	}

	result["modelType"] = "ConceptDescription"

	return
}

// Serialize [aastypes.IReference] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IReference] with proper dispatch, call
// [ToJsonable].
func referenceToMap(
	that aastypes.IReference,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	var jsonableType interface{}
	jsonableType, err = ReferenceTypesToJsonable(
		that.Type(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Type()",
			},
		)

		return
	}
	result["type"] = jsonableType

	if that.ReferredSemanticID() != nil {
		var jsonableReferredSemanticID interface{}
		jsonableReferredSemanticID, err = ToJsonable(
			that.ReferredSemanticID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ReferredSemanticID()",
				},
			)

			return
		}
		result["referredSemanticId"] = jsonableReferredSemanticID
	}

	jsonableKeys := make(
		[]interface{},
		len(that.Keys()),
	)
	for i, v := range that.Keys() {
		var jsonable interface{}
		jsonable, err = ToJsonable(
			v,
		)
		if err != nil {
			err.Path.PrependIndex(
				&aasreporting.IndexSegment{
					Index: i,
				},
			)

			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Keys()",
				},
			)

			return
		}
		jsonableKeys[i] = jsonable
	}
	result["keys"] = jsonableKeys

	return
}

// Serialize [aastypes.IKey] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IKey] with proper dispatch, call
// [ToJsonable].
func keyToMap(
	that aastypes.IKey,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	var jsonableType interface{}
	jsonableType, err = KeyTypesToJsonable(
		that.Type(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Type()",
			},
		)

		return
	}
	result["type"] = jsonableType

	result["value"] = that.Value()

	return
}

// Serialize [aastypes.ILangStringNameType] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringNameType] with proper dispatch, call
// [ToJsonable].
func langStringNameTypeToMap(
	that aastypes.ILangStringNameType,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["language"] = that.Language()

	result["text"] = that.Text()

	return
}

// Serialize [aastypes.ILangStringTextType] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringTextType] with proper dispatch, call
// [ToJsonable].
func langStringTextTypeToMap(
	that aastypes.ILangStringTextType,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["language"] = that.Language()

	result["text"] = that.Text()

	return
}

// Serialize [aastypes.IEnvironment] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEnvironment] with proper dispatch, call
// [ToJsonable].
func environmentToMap(
	that aastypes.IEnvironment,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	if that.AssetAdministrationShells() != nil {
		jsonableAssetAdministrationShells := make(
			[]interface{},
			len(that.AssetAdministrationShells()),
		)
		for i, v := range that.AssetAdministrationShells() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetAdministrationShells()",
					},
				)

				return
			}
			jsonableAssetAdministrationShells[i] = jsonable
		}
		result["assetAdministrationShells"] = jsonableAssetAdministrationShells
	}

	if that.Submodels() != nil {
		jsonableSubmodels := make(
			[]interface{},
			len(that.Submodels()),
		)
		for i, v := range that.Submodels() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Submodels()",
					},
				)

				return
			}
			jsonableSubmodels[i] = jsonable
		}
		result["submodels"] = jsonableSubmodels
	}

	if that.ConceptDescriptions() != nil {
		jsonableConceptDescriptions := make(
			[]interface{},
			len(that.ConceptDescriptions()),
		)
		for i, v := range that.ConceptDescriptions() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ConceptDescriptions()",
					},
				)

				return
			}
			jsonableConceptDescriptions[i] = jsonable
		}
		result["conceptDescriptions"] = jsonableConceptDescriptions
	}

	return
}

// Serialize [aastypes.IEmbeddedDataSpecification] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEmbeddedDataSpecification] with proper dispatch, call
// [ToJsonable].
func embeddedDataSpecificationToMap(
	that aastypes.IEmbeddedDataSpecification,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	var jsonableDataSpecificationContent interface{}
	jsonableDataSpecificationContent, err = ToJsonable(
		that.DataSpecificationContent(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "DataSpecificationContent()",
			},
		)

		return
	}
	result["dataSpecificationContent"] = jsonableDataSpecificationContent

	if that.DataSpecification() != nil {
		var jsonableDataSpecification interface{}
		jsonableDataSpecification, err = ToJsonable(
			that.DataSpecification(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DataSpecification()",
				},
			)

			return
		}
		result["dataSpecification"] = jsonableDataSpecification
	}

	return
}

// Serialize [aastypes.ILevelType] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILevelType] with proper dispatch, call
// [ToJsonable].
func levelTypeToMap(
	that aastypes.ILevelType,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["min"] = that.Min()

	result["nom"] = that.Nom()

	result["typ"] = that.Typ()

	result["max"] = that.Max()

	return
}

// Serialize [aastypes.IValueReferencePair] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IValueReferencePair] with proper dispatch, call
// [ToJsonable].
func valueReferencePairToMap(
	that aastypes.IValueReferencePair,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["value"] = that.Value()

	var jsonableValueID interface{}
	jsonableValueID, err = ToJsonable(
		that.ValueID(),
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueID()",
			},
		)

		return
	}
	result["valueId"] = jsonableValueID

	return
}

// Serialize [aastypes.IValueList] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IValueList] with proper dispatch, call
// [ToJsonable].
func valueListToMap(
	that aastypes.IValueList,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	jsonableValueReferencePairs := make(
		[]interface{},
		len(that.ValueReferencePairs()),
	)
	for i, v := range that.ValueReferencePairs() {
		var jsonable interface{}
		jsonable, err = ToJsonable(
			v,
		)
		if err != nil {
			err.Path.PrependIndex(
				&aasreporting.IndexSegment{
					Index: i,
				},
			)

			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueReferencePairs()",
				},
			)

			return
		}
		jsonableValueReferencePairs[i] = jsonable
	}
	result["valueReferencePairs"] = jsonableValueReferencePairs

	return
}

// Serialize [aastypes.ILangStringPreferredNameTypeIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringPreferredNameTypeIEC61360] with proper dispatch, call
// [ToJsonable].
func langStringPreferredNameTypeIEC61360ToMap(
	that aastypes.ILangStringPreferredNameTypeIEC61360,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["language"] = that.Language()

	result["text"] = that.Text()

	return
}

// Serialize [aastypes.ILangStringShortNameTypeIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringShortNameTypeIEC61360] with proper dispatch, call
// [ToJsonable].
func langStringShortNameTypeIEC61360ToMap(
	that aastypes.ILangStringShortNameTypeIEC61360,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["language"] = that.Language()

	result["text"] = that.Text()

	return
}

// Serialize [aastypes.ILangStringDefinitionTypeIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringDefinitionTypeIEC61360] with proper dispatch, call
// [ToJsonable].
func langStringDefinitionTypeIEC61360ToMap(
	that aastypes.ILangStringDefinitionTypeIEC61360,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	result["language"] = that.Language()

	result["text"] = that.Text()

	return
}

// Serialize [aastypes.IDataSpecificationIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IDataSpecificationIEC61360] with proper dispatch, call
// [ToJsonable].
func dataSpecificationIEC61360ToMap(
	that aastypes.IDataSpecificationIEC61360,
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	jsonablePreferredName := make(
		[]interface{},
		len(that.PreferredName()),
	)
	for i, v := range that.PreferredName() {
		var jsonable interface{}
		jsonable, err = ToJsonable(
			v,
		)
		if err != nil {
			err.Path.PrependIndex(
				&aasreporting.IndexSegment{
					Index: i,
				},
			)

			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "PreferredName()",
				},
			)

			return
		}
		jsonablePreferredName[i] = jsonable
	}
	result["preferredName"] = jsonablePreferredName

	if that.ShortName() != nil {
		jsonableShortName := make(
			[]interface{},
			len(that.ShortName()),
		)
		for i, v := range that.ShortName() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ShortName()",
					},
				)

				return
			}
			jsonableShortName[i] = jsonable
		}
		result["shortName"] = jsonableShortName
	}

	if that.Unit() != nil {
		result["unit"] = *that.Unit()
	}

	if that.UnitID() != nil {
		var jsonableUnitID interface{}
		jsonableUnitID, err = ToJsonable(
			that.UnitID(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "UnitID()",
				},
			)

			return
		}
		result["unitId"] = jsonableUnitID
	}

	if that.SourceOfDefinition() != nil {
		result["sourceOfDefinition"] = *that.SourceOfDefinition()
	}

	if that.Symbol() != nil {
		result["symbol"] = *that.Symbol()
	}

	if that.DataType() != nil {
		var jsonableDataType interface{}
		jsonableDataType, err = DataTypeIEC61360ToJsonable(
			*(that.DataType()),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DataType()",
				},
			)

			return
		}
		result["dataType"] = jsonableDataType
	}

	if that.Definition() != nil {
		jsonableDefinition := make(
			[]interface{},
			len(that.Definition()),
		)
		for i, v := range that.Definition() {
			var jsonable interface{}
			jsonable, err = ToJsonable(
				v,
			)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Definition()",
					},
				)

				return
			}
			jsonableDefinition[i] = jsonable
		}
		result["definition"] = jsonableDefinition
	}

	if that.ValueFormat() != nil {
		result["valueFormat"] = *that.ValueFormat()
	}

	if that.ValueList() != nil {
		var jsonableValueList interface{}
		jsonableValueList, err = ToJsonable(
			that.ValueList(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueList()",
				},
			)

			return
		}
		result["valueList"] = jsonableValueList
	}

	if that.Value() != nil {
		result["value"] = *that.Value()
	}

	if that.LevelType() != nil {
		var jsonableLevelType interface{}
		jsonableLevelType, err = ToJsonable(
			that.LevelType(),
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "LevelType()",
				},
			)

			return
		}
		result["levelType"] = jsonableLevelType
	}

	result["modelType"] = "DataSpecificationIec61360"

	return
}

// Serialize ``that`` instance to a JSON-able representation.
//
// Return a structure which can be readily converted to JSON,
// or an error if some value could not be converted.
func ToJsonable(
	that aastypes.IClass,
) (result map[string]interface{}, err *SerializationError) {
	switch that.ModelType() {
	case aastypes.ModelTypeExtension:
		result, err = extensionToMap(
			that.(aastypes.IExtension),
		)
	case aastypes.ModelTypeAdministrativeInformation:
		result, err = administrativeInformationToMap(
			that.(aastypes.IAdministrativeInformation),
		)
	case aastypes.ModelTypeQualifier:
		result, err = qualifierToMap(
			that.(aastypes.IQualifier),
		)
	case aastypes.ModelTypeAssetAdministrationShell:
		result, err = assetAdministrationShellToMap(
			that.(aastypes.IAssetAdministrationShell),
		)
	case aastypes.ModelTypeAssetInformation:
		result, err = assetInformationToMap(
			that.(aastypes.IAssetInformation),
		)
	case aastypes.ModelTypeResource:
		result, err = resourceToMap(
			that.(aastypes.IResource),
		)
	case aastypes.ModelTypeSpecificAssetID:
		result, err = specificAssetIDToMap(
			that.(aastypes.ISpecificAssetID),
		)
	case aastypes.ModelTypeSubmodel:
		result, err = submodelToMap(
			that.(aastypes.ISubmodel),
		)
	case aastypes.ModelTypeRelationshipElement:
		result, err = relationshipElementToMap(
			that.(aastypes.IRelationshipElement),
		)
	case aastypes.ModelTypeSubmodelElementList:
		result, err = submodelElementListToMap(
			that.(aastypes.ISubmodelElementList),
		)
	case aastypes.ModelTypeSubmodelElementCollection:
		result, err = submodelElementCollectionToMap(
			that.(aastypes.ISubmodelElementCollection),
		)
	case aastypes.ModelTypeProperty:
		result, err = propertyToMap(
			that.(aastypes.IProperty),
		)
	case aastypes.ModelTypeMultiLanguageProperty:
		result, err = multiLanguagePropertyToMap(
			that.(aastypes.IMultiLanguageProperty),
		)
	case aastypes.ModelTypeRange:
		result, err = rangeToMap(
			that.(aastypes.IRange),
		)
	case aastypes.ModelTypeReferenceElement:
		result, err = referenceElementToMap(
			that.(aastypes.IReferenceElement),
		)
	case aastypes.ModelTypeBlob:
		result, err = blobToMap(
			that.(aastypes.IBlob),
		)
	case aastypes.ModelTypeFile:
		result, err = fileToMap(
			that.(aastypes.IFile),
		)
	case aastypes.ModelTypeAnnotatedRelationshipElement:
		result, err = annotatedRelationshipElementToMap(
			that.(aastypes.IAnnotatedRelationshipElement),
		)
	case aastypes.ModelTypeEntity:
		result, err = entityToMap(
			that.(aastypes.IEntity),
		)
	case aastypes.ModelTypeEventPayload:
		result, err = eventPayloadToMap(
			that.(aastypes.IEventPayload),
		)
	case aastypes.ModelTypeBasicEventElement:
		result, err = basicEventElementToMap(
			that.(aastypes.IBasicEventElement),
		)
	case aastypes.ModelTypeOperation:
		result, err = operationToMap(
			that.(aastypes.IOperation),
		)
	case aastypes.ModelTypeOperationVariable:
		result, err = operationVariableToMap(
			that.(aastypes.IOperationVariable),
		)
	case aastypes.ModelTypeCapability:
		result, err = capabilityToMap(
			that.(aastypes.ICapability),
		)
	case aastypes.ModelTypeConceptDescription:
		result, err = conceptDescriptionToMap(
			that.(aastypes.IConceptDescription),
		)
	case aastypes.ModelTypeReference:
		result, err = referenceToMap(
			that.(aastypes.IReference),
		)
	case aastypes.ModelTypeKey:
		result, err = keyToMap(
			that.(aastypes.IKey),
		)
	case aastypes.ModelTypeLangStringNameType:
		result, err = langStringNameTypeToMap(
			that.(aastypes.ILangStringNameType),
		)
	case aastypes.ModelTypeLangStringTextType:
		result, err = langStringTextTypeToMap(
			that.(aastypes.ILangStringTextType),
		)
	case aastypes.ModelTypeEnvironment:
		result, err = environmentToMap(
			that.(aastypes.IEnvironment),
		)
	case aastypes.ModelTypeEmbeddedDataSpecification:
		result, err = embeddedDataSpecificationToMap(
			that.(aastypes.IEmbeddedDataSpecification),
		)
	case aastypes.ModelTypeLevelType:
		result, err = levelTypeToMap(
			that.(aastypes.ILevelType),
		)
	case aastypes.ModelTypeValueReferencePair:
		result, err = valueReferencePairToMap(
			that.(aastypes.IValueReferencePair),
		)
	case aastypes.ModelTypeValueList:
		result, err = valueListToMap(
			that.(aastypes.IValueList),
		)
	case aastypes.ModelTypeLangStringPreferredNameTypeIEC61360:
		result, err = langStringPreferredNameTypeIEC61360ToMap(
			that.(aastypes.ILangStringPreferredNameTypeIEC61360),
		)
	case aastypes.ModelTypeLangStringShortNameTypeIEC61360:
		result, err = langStringShortNameTypeIEC61360ToMap(
			that.(aastypes.ILangStringShortNameTypeIEC61360),
		)
	case aastypes.ModelTypeLangStringDefinitionTypeIEC61360:
		result, err = langStringDefinitionTypeIEC61360ToMap(
			that.(aastypes.ILangStringDefinitionTypeIEC61360),
		)
	case aastypes.ModelTypeDataSpecificationIEC61360:
		result, err = dataSpecificationIEC61360ToMap(
			that.(aastypes.IDataSpecificationIEC61360),
		)
	default:
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected model type literal: %v",
				that.ModelType(),
			),
		)
	}
	return
}

// endregion

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
