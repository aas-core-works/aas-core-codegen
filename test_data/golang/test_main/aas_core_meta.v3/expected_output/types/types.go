// Package types provides the data structures corresponding to the meta-model.
//
// Provide an implementation of the Asset Administration Shell (AAS) V3.0.
//
// The presented version of the Metamodel is related to the work of
// aas-core-works, which can be found here: https://github.com/aas-core-works.
//
// The presented content is neither related to the IDTA nor
// Plattform Industrie 4.0 and does not represent an official publication.
//
// We diverge from the book in the following points.
//
// We did not implement the following constraints as they are too general and can not
// be formalized as part of the core library, but affects external components such as
// AAS registry or AAS server:
//
//   • Constraint AASd-022
//
// We did not implement the following constraints since they depend on registry and
// de-referencing of [IReference] objects:
//
//   • Constraint AASd-006
//   • Constraint AASd-007
//   • Constraint AASc-3a-003
//
// Some constraints are not enforceable as they depend on the wider context
// such as language understanding, so we could not formalize them:
//
//   • Constraint AASd-012: This constraint requires that the texts inside
//     `Multi_language_property` shall have the same meanings in the separate languages.
//     This cannot be tested.
//   • Constraint AASd-116: In the book, Constraint AASd-116 imposes a
//     case-insensitive equality against `globalAssetId`. This is culturally-dependent,
//     and depends on the system settings. For example, the case-folding
//     for the letters "i" and "I" is different in Turkish from English.
//
//     We implement the constraint as case-sensitive instead to allow for interoperability
//     across different culture settings.
//
// Furthermore, we diverge from the book in the following points regarding
// the enumerations. We have to implement subsets of enumerations as sets as common
// programming languages do not support inheritance of enumerations. The relationship
// between the properties and the sets is defined through invariants. This causes
// the following divergences:
//
//   • We decided therefore to remove the enumeration `DataTypeDefRDF`
//     and keep only [DataTypeDefXSD] as enumeration. Otherwise, we would have
//     to write redundant invariants all over the meta-model because `DataTypeDefRDF`
//     is actually never used in any type definition.
//   • The enumeration [AASSubmodelElements] is used in two different contexts.
//     One context is the definition of key types in a reference. Another context is
//     the definition of element types in a [ISubmodelElementList].
//
//     To avoid confusion, we introduce two separate enumerations for the separate contexts.
//     Firstly, a set of [KeyTypes], [aasconstants.AASSubmodelElementsAsKeys] to
//     represent the first context (key type in a reference).
//     Secondly, the enumeration [AASSubmodelElements] is kept as designator
//     for [ISubmodelElementList.TypeValueListElement].
//   • The specification introduces several types of `Lang_string_set`.
//     These types differ between the allowed length of their text inside the singular
//     `Lang_string` objects. Since the native representation of `Lang_string_set` as
//     `List` of `Lang_string` is required by specification, it is impossible to
//     introduce separate `Lang_string_set` types. Therefore, the distinction is drawn here
//     between the `Lang_string` types.
//
//     `DefinitionTypeIEC61360` is represented as a
//     `List` of [ILangStringDefinitionTypeIEC61360]
//
//     `MultiLanguageNameType` is represented as a
//     `List` of [ILangStringNameType]
//
//     `PreferredNameTypeIEC61360` is represented as a
//     `List` of [ILangStringPreferredNameTypeIEC61360]
//
//     `ShortNameTypeIEC61360` is represented as a
//     `List` of [ILangStringShortNameTypeIEC61360]
//
//     `MultiLanguageTextType` is represented as a
//     `List` of [ILangStringTextType]
//
//     Furthermore, since `Lang_string` is not used anywhere, we rename it to
//     [IAbstractLangString].
//
// Concerning the data specifications, we embed them within
// [IHasDataSpecification] instead of referencing them via an external reference.
// The working group decided to change the rules for serialization after the book was
// published. The data specifications are critical in applications, but there is no
// possibility to access them through a data channel as they are not part of
// an environment.
package types

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

// Enumerate the model types for faster type switches.
//
// For example, you can use an array of function pointers to
// implement such a switch.
type ModelType int
const (
	ModelTypeExtension ModelType = iota
	ModelTypeAdministrativeInformation
	ModelTypeQualifier
	ModelTypeAssetAdministrationShell
	ModelTypeAssetInformation
	ModelTypeResource
	ModelTypeSpecificAssetID
	ModelTypeSubmodel
	ModelTypeRelationshipElement
	ModelTypeSubmodelElementList
	ModelTypeSubmodelElementCollection
	ModelTypeProperty
	ModelTypeMultiLanguageProperty
	ModelTypeRange
	ModelTypeReferenceElement
	ModelTypeBlob
	ModelTypeFile
	ModelTypeAnnotatedRelationshipElement
	ModelTypeEntity
	ModelTypeEventPayload
	ModelTypeBasicEventElement
	ModelTypeOperation
	ModelTypeOperationVariable
	ModelTypeCapability
	ModelTypeConceptDescription
	ModelTypeReference
	ModelTypeKey
	ModelTypeLangStringNameType
	ModelTypeLangStringTextType
	ModelTypeEnvironment
	ModelTypeEmbeddedDataSpecification
	ModelTypeLevelType
	ModelTypeValueReferencePair
	ModelTypeValueList
	ModelTypeLangStringPreferredNameTypeIEC61360
	ModelTypeLangStringShortNameTypeIEC61360
	ModelTypeLangStringDefinitionTypeIEC61360
	ModelTypeDataSpecificationIEC61360
)

// Represent the most general interface of an AAS model.
type IClass interface {
	// Return the concrete model type at run-time.
	//
	// Use the model type if you want to switch on the concrete model type
	// in efficient manner, as the compiler will most probably implement
	// the switch in form of a jump table.
	ModelType() ModelType

	// Apply the action on the instances referenced from this instance.
	//
	// If any of the actions returns abort `true`, the descent is immediately
	// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
	//
	// We do not recurse into the referenced instances.
	//
	// The action is not applied on this instance.
	DescendOnce(action func(IClass) bool) (abort bool)

	// Apply the action recursively on the instances referenced from this instance.
	//
	// If any of the actions returns abort `true`, the descent is immediately
	// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
	//
	// The action is not applied on this instance.
	Descend(action func(IClass) bool) (abort bool)
}

// Element that can have a semantic definition plus some supplemental semantic
// definitions.
//
// Constraint AASd-118:
// If there are ID [IHasSemantics.SupplementalSemanticIDs] defined
// then there shall be also a main semantic ID [IHasSemantics.SemanticID].
type IHasSemantics interface {
	IClass

	// Identifier of the semantic definition of the element. It is called semantic ID
	// of the element or also main semantic ID of the element.
	//
	// NOTE: It is recommended to use a global reference.
	SemanticID() IReference;

	SetSemanticID(
		value IReference,
	);

	// Identifier of a supplemental semantic definition of the element.
	// It is called supplemental semantic ID of the element.
	//
	// NOTE: It is recommended to use a global reference.
	SupplementalSemanticIDs() []IReference;

	SetSupplementalSemanticIDs(
		value []IReference,
	);
}

// Check whether the instance corresponds to [aastypes.IHasSemantics]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsHasSemantics(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeExtension:
		ok = true
	case ModelTypeQualifier:
		ok = true
	case ModelTypeSpecificAssetID:
		ok = true
	case ModelTypeSubmodel:
		ok = true
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeSubmodelElementList:
		ok = true
	case ModelTypeSubmodelElementCollection:
		ok = true
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	case ModelTypeEntity:
		ok = true
	case ModelTypeBasicEventElement:
		ok = true
	case ModelTypeOperation:
		ok = true
	case ModelTypeCapability:
		ok = true
	}
	return
}

// Single extension of an element.
type IExtension interface {
	IHasSemantics

	// Name of the extension.
	//
	// Constraint AASd-077:
	// The name of an extension (Extension/name) within [IHasExtensions] needs
	// to be unique.
	Name() string;

	SetName(
		value string,
	);

	// Type of the value of the extension.
	//
	// Default: [DataTypeDefXSDString]
	ValueType() *DataTypeDefXSD;

	SetValueType(
		value *DataTypeDefXSD,
	);

	// Value of the extension
	Value() *string;

	SetValue(
		value *string,
	);

	// Reference to an element the extension refers to.
	RefersTo() []IReference;

	SetRefersTo(
		value []IReference,
	);

	ValueTypeOrDefault() DataTypeDefXSD;
}

// Check whether the instance corresponds to [aastypes.IExtension]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsExtension(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeExtension
	return
}

// Implements IExtension.
type Extension struct {
	semanticID IReference
	supplementalSemanticIDs []IReference
	name string
	valueType *DataTypeDefXSD
	value *string
	refersTo []IReference
}

func (e *Extension) SemanticID(
) IReference {
	return e.semanticID
}

func (e *Extension) SetSemanticID(
	value IReference,
) {
	e.semanticID = value
}

func (e *Extension) SupplementalSemanticIDs(
) []IReference {
	return e.supplementalSemanticIDs
}

func (e *Extension) SetSupplementalSemanticIDs(
	value []IReference,
) {
	e.supplementalSemanticIDs = value
}

func (e *Extension) Name(
) string {
	return e.name
}

func (e *Extension) SetName(
	value string,
) {
	e.name = value
}

func (e *Extension) ValueType(
) *DataTypeDefXSD {
	return e.valueType
}

func (e *Extension) SetValueType(
	value *DataTypeDefXSD,
) {
	e.valueType = value
}

func (e *Extension) Value(
) *string {
	return e.value
}

func (e *Extension) SetValue(
	value *string,
) {
	e.value = value
}

func (e *Extension) RefersTo(
) []IReference {
	return e.refersTo
}

func (e *Extension) SetRefersTo(
	value []IReference,
) {
	e.refersTo = value
}

func (e *Extension) ModelType(
) ModelType {
	return ModelTypeExtension
}

// Return [IExtension.ValueType] or the default value
// if it has not been set.
func (e *Extension) ValueTypeOrDefault() DataTypeDefXSD {
	v := e.ValueType()
	if v == nil {
		return DataTypeDefXSDString
	}

	return *v
}

// Apply the action on the instances referenced from e.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on e.
func (e *Extension) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if e.semanticID != nil {
		abort = action(
			e.semanticID,
		)
		if abort {
			return
		}
	}

	if e.supplementalSemanticIDs != nil {
		for _, v := range e.supplementalSemanticIDs {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if e.refersTo != nil {
		for _, v1 := range e.refersTo {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from e.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on e.
func (e *Extension) Descend(
	action func(IClass) bool,
) (abort bool) {
	if e.semanticID != nil {
		abort = action(
			e.semanticID,
		)
		if abort {
			return
		}
		abort = e.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if e.supplementalSemanticIDs != nil {
		for _, v := range e.supplementalSemanticIDs {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.refersTo != nil {
		for _, v1 := range e.refersTo {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Extension with
// the given properties.
func NewExtension(
	name string,
) *Extension {
	return &Extension{
		name: name,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		valueType: nil,
		value: nil,
		refersTo: nil,
	}
}

// Element that can be extended by proprietary extensions.
//
// NOTE: Extensions are proprietary, i.e. they do not support global interoperability.
type IHasExtensions interface {
	IClass

	// An extension of the element.
	Extensions() []IExtension;

	SetExtensions(
		value []IExtension,
	);
}

// Check whether the instance corresponds to [aastypes.IHasExtensions]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsHasExtensions(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeAssetAdministrationShell:
		ok = true
	case ModelTypeSubmodel:
		ok = true
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeSubmodelElementList:
		ok = true
	case ModelTypeSubmodelElementCollection:
		ok = true
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	case ModelTypeEntity:
		ok = true
	case ModelTypeBasicEventElement:
		ok = true
	case ModelTypeOperation:
		ok = true
	case ModelTypeCapability:
		ok = true
	case ModelTypeConceptDescription:
		ok = true
	}
	return
}

// An element that is referable by its [IReferable.IDShort].
//
// This ID is not globally unique.
// This ID is unique within the name space of the element.
//
// Constraint AASd-022:
// [IReferable.IDShort] of non-identifiable referables
// within the same name space shall be unique (case-sensitive).
type IReferable interface {
	IHasExtensions

	// The category is a value that gives further meta information
	// w.r.t. to the class of the element.
	// It affects the expected existence of attributes and the applicability of
	// constraints.
	//
	// NOTE: The category is not identical to the semantic definition
	// ([IHasSemantics]) of an element. The category e.g. could denote that
	// the element is a measurement value whereas the semantic definition of
	// the element would denote that it is the measured temperature.
	Category() *string;

	SetCategory(
		value *string,
	);

	// In case of identifiables this attribute is a short name of the element.
	// In case of referable this ID is an identifying string of the element within
	// its name space.
	//
	// NOTE: In case the element is a property and the property has a semantic definition
	// ([IHasSemantics.SemanticID]) conformant to IEC61360
	// the [IReferable.IDShort] is typically identical to the short name in English.
	IDShort() *string;

	SetIDShort(
		value *string,
	);

	// Display name. Can be provided in several languages.
	DisplayName() []ILangStringNameType;

	SetDisplayName(
		value []ILangStringNameType,
	);

	// Description or comments on the element.
	//
	// The description can be provided in several languages.
	//
	// If no description is defined, then the definition of the concept
	// description that defines the semantics of the element is used.
	//
	// Additional information can be provided, e.g., if the element is
	// qualified and which qualifier types can be expected in which
	// context or which additional data specification templates are
	// provided.
	Description() []ILangStringTextType;

	SetDescription(
		value []ILangStringTextType,
	);
}

// Check whether the instance corresponds to [aastypes.IReferable]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsReferable(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeAssetAdministrationShell:
		ok = true
	case ModelTypeSubmodel:
		ok = true
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeSubmodelElementList:
		ok = true
	case ModelTypeSubmodelElementCollection:
		ok = true
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	case ModelTypeEntity:
		ok = true
	case ModelTypeBasicEventElement:
		ok = true
	case ModelTypeOperation:
		ok = true
	case ModelTypeCapability:
		ok = true
	case ModelTypeConceptDescription:
		ok = true
	}
	return
}

// An element that has a globally unique identifier.
type IIdentifiable interface {
	IReferable

	// Administrative information of an identifiable element.
	//
	// NOTE: Some of the administrative information like the version number might need to
	// be part of the identification.
	Administration() IAdministrativeInformation;

	SetAdministration(
		value IAdministrativeInformation,
	);

	// The globally unique identification of the element.
	ID() string;

	SetID(
		value string,
	);
}

// Check whether the instance corresponds to [aastypes.IIdentifiable]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsIdentifiable(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeAssetAdministrationShell:
		ok = true
	case ModelTypeSubmodel:
		ok = true
	case ModelTypeConceptDescription:
		ok = true
	}
	return
}

// Enumeration for denoting whether an element is a template or an instance.
type ModellingKind int;const (
	// Specification of the common features of a structured element in sufficient detail
	// that such a instance can be instantiated using it
	ModellingKindTemplate ModellingKind = iota
	// Concrete, clearly identifiable element instance. Its creation and validation
	// may be guided by a corresponding element template.
	ModellingKindInstance
)

// List the literals of [ModellingKind].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfModellingKind = [...]ModellingKind {
	ModellingKindTemplate,
	ModellingKindInstance,
}

// An element with a kind is an element that can either represent a template or an
// instance.
//
// Default for an element is that it is representing an instance.
type IHasKind interface {
	IClass

	// Kind of the element: either type or instance.
	//
	// Default: [ModellingKindInstance]
	Kind() *ModellingKind;

	SetKind(
		value *ModellingKind,
	);

	KindOrDefault() ModellingKind;
}

// Check whether the instance corresponds to [aastypes.IHasKind]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsHasKind(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeSubmodel:
		ok = true
	}
	return
}

// Element that can be extended by using data specification templates.
//
// A data specification template defines a named set of additional attributes an
// element may or shall have. The data specifications used are explicitly specified
// with their global ID.
type IHasDataSpecification interface {
	IClass

	// Embedded data specification.
	EmbeddedDataSpecifications() []IEmbeddedDataSpecification;

	SetEmbeddedDataSpecifications(
		value []IEmbeddedDataSpecification,
	);
}

// Check whether the instance corresponds to [aastypes.IHasDataSpecification]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsHasDataSpecification(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeAdministrativeInformation:
		ok = true
	case ModelTypeAssetAdministrationShell:
		ok = true
	case ModelTypeSubmodel:
		ok = true
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeSubmodelElementList:
		ok = true
	case ModelTypeSubmodelElementCollection:
		ok = true
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	case ModelTypeEntity:
		ok = true
	case ModelTypeBasicEventElement:
		ok = true
	case ModelTypeOperation:
		ok = true
	case ModelTypeCapability:
		ok = true
	case ModelTypeConceptDescription:
		ok = true
	}
	return
}

// Administrative meta-information for an element like version
// information.
//
// Constraint AASd-005:
// If [IAdministrativeInformation.Version] is not specified then also [IAdministrativeInformation.Revision] shall be
// unspecified. This means, a revision requires a version. If there is no version
// there is no revision neither. Revision is optional.
type IAdministrativeInformation interface {
	IHasDataSpecification

	// Version of the element.
	Version() *string;

	SetVersion(
		value *string,
	);

	// Revision of the element.
	Revision() *string;

	SetRevision(
		value *string,
	);

	// The subject ID of the subject responsible for making the element.
	Creator() IReference;

	SetCreator(
		value IReference,
	);

	// Identifier of the template that guided the creation of the element.
	//
	// NOTE: In case of a submodel the [IAdministrativeInformation.TemplateID] is the identifier
	// of the submodel template ID that guided the creation of the submodel
	//
	// NOTE: The [IAdministrativeInformation.TemplateID] is not relevant for validation in Submodels.
	// For validation the [ISubmodel.SemanticID] shall be used.
	//
	// NOTE: Usage of [IAdministrativeInformation.TemplateID] is not restricted to submodel instances. So also
	// the creation of submodel templates can be guided by another submodel template.
	TemplateID() *string;

	SetTemplateID(
		value *string,
	);
}

// Check whether the instance corresponds to [aastypes.IAdministrativeInformation]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsAdministrativeInformation(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeAdministrativeInformation
	return
}

// Implements IAdministrativeInformation.
type AdministrativeInformation struct {
	embeddedDataSpecifications []IEmbeddedDataSpecification
	version *string
	revision *string
	creator IReference
	templateID *string
}

func (ai *AdministrativeInformation) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return ai.embeddedDataSpecifications
}

func (ai *AdministrativeInformation) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	ai.embeddedDataSpecifications = value
}

func (ai *AdministrativeInformation) Version(
) *string {
	return ai.version
}

func (ai *AdministrativeInformation) SetVersion(
	value *string,
) {
	ai.version = value
}

func (ai *AdministrativeInformation) Revision(
) *string {
	return ai.revision
}

func (ai *AdministrativeInformation) SetRevision(
	value *string,
) {
	ai.revision = value
}

func (ai *AdministrativeInformation) Creator(
) IReference {
	return ai.creator
}

func (ai *AdministrativeInformation) SetCreator(
	value IReference,
) {
	ai.creator = value
}

func (ai *AdministrativeInformation) TemplateID(
) *string {
	return ai.templateID
}

func (ai *AdministrativeInformation) SetTemplateID(
	value *string,
) {
	ai.templateID = value
}

func (ai *AdministrativeInformation) ModelType(
) ModelType {
	return ModelTypeAdministrativeInformation
}

// Apply the action on the instances referenced from ai.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on ai.
func (ai *AdministrativeInformation) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if ai.embeddedDataSpecifications != nil {
		for _, v := range ai.embeddedDataSpecifications {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if ai.creator != nil {
		abort = action(
			ai.creator,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from ai.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on ai.
func (ai *AdministrativeInformation) Descend(
	action func(IClass) bool,
) (abort bool) {
	if ai.embeddedDataSpecifications != nil {
		for _, v := range ai.embeddedDataSpecifications {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if ai.creator != nil {
		abort = action(
			ai.creator,
		)
		if abort {
			return
		}
		abort = ai.creator.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of AdministrativeInformation with
// the given properties.
func NewAdministrativeInformation() *AdministrativeInformation {
	return &AdministrativeInformation{
		embeddedDataSpecifications: nil,
		version: nil,
		revision: nil,
		creator: nil,
		templateID: nil,
	}
}

// The value of a qualifiable element may be further qualified by one or more
// qualifiers.
//
// Constraint AASd-119:
// If any [IQualifier.Kind] value of [IQualifiable.Qualifiers] is
// equal to [QualifierKindTemplateQualifier] and the qualified element
// inherits from [IHasKind] then the qualified element shall be of
// kind Template ([IHasKind.Kind] = [ModellingKindTemplate]).
//
// NOTE: This constraint is checked at [ISubmodel].
type IQualifiable interface {
	IClass

	// Additional qualification of a qualifiable element.
	//
	// Constraint AASd-021:
	// Every qualifiable can only have one qualifier with the same
	// [IQualifier.Type].
	Qualifiers() []IQualifier;

	SetQualifiers(
		value []IQualifier,
	);
}

// Check whether the instance corresponds to [aastypes.IQualifiable]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsQualifiable(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeSubmodel:
		ok = true
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeSubmodelElementList:
		ok = true
	case ModelTypeSubmodelElementCollection:
		ok = true
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	case ModelTypeEntity:
		ok = true
	case ModelTypeBasicEventElement:
		ok = true
	case ModelTypeOperation:
		ok = true
	case ModelTypeCapability:
		ok = true
	}
	return
}

// Enumeration for kinds of qualifiers.
//
// NOTE: This element is experimental and therefore may be subject to change or may be
// removed completely in future versions of the meta-model.
type QualifierKind int;const (
	// qualifies the value of the element and can change during run-time.
	//
	// Value qualifiers are only applicable to elements with kind
	// [ModellingKindInstance].
	QualifierKindValueQualifier QualifierKind = iota
	// qualifies the semantic definition the element is referring to
	// ([IHasSemantics.SemanticID])
	QualifierKindConceptQualifier
	// qualifies the elements within a specific submodel on concept level.
	//
	// Template qualifiers are only applicable to elements with kind
	// [ModellingKindTemplate].
	QualifierKindTemplateQualifier
)

// List the literals of [QualifierKind].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfQualifierKind = [...]QualifierKind {
	QualifierKindValueQualifier,
	QualifierKindConceptQualifier,
	QualifierKindTemplateQualifier,
}

// A qualifier is a type-value-pair that makes additional statements w.r.t. the value
// of the element.
//
// Constraint AASd-006:
// If both the [IQualifier.Value] and the [IQualifier.ValueID] of
// a [IQualifier] are present then the [IQualifier.Value] needs
// to be identical to the value of the referenced coded value
// in [IQualifier.ValueID].
//
// Constraint AASd-020:
// The value of [IQualifier.Value] shall be consistent to the data type as
// defined in [IQualifier.ValueType].
type IQualifier interface {
	IHasSemantics

	// The qualifier kind describes the kind of the qualifier that is applied to the
	// element.
	//
	// Default: [QualifierKindConceptQualifier]
	Kind() *QualifierKind;

	SetKind(
		value *QualifierKind,
	);

	// The qualifier type describes the type of the qualifier that is applied to
	// the element.
	Type() string;

	SetType(
		value string,
	);

	// Data type of the qualifier value.
	ValueType() DataTypeDefXSD;

	SetValueType(
		value DataTypeDefXSD,
	);

	// The qualifier value is the value of the qualifier.
	Value() *string;

	SetValue(
		value *string,
	);

	// Reference to the global unique ID of a coded value.
	//
	// NOTE: It is recommended to use a global reference.
	ValueID() IReference;

	SetValueID(
		value IReference,
	);

	KindOrDefault() QualifierKind;
}

// Check whether the instance corresponds to [aastypes.IQualifier]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsQualifier(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeQualifier
	return
}

// Implements IQualifier.
type Qualifier struct {
	semanticID IReference
	supplementalSemanticIDs []IReference
	kind *QualifierKind
	typE string
	valueType DataTypeDefXSD
	value *string
	valueID IReference
}

func (q *Qualifier) SemanticID(
) IReference {
	return q.semanticID
}

func (q *Qualifier) SetSemanticID(
	value IReference,
) {
	q.semanticID = value
}

func (q *Qualifier) SupplementalSemanticIDs(
) []IReference {
	return q.supplementalSemanticIDs
}

func (q *Qualifier) SetSupplementalSemanticIDs(
	value []IReference,
) {
	q.supplementalSemanticIDs = value
}

func (q *Qualifier) Kind(
) *QualifierKind {
	return q.kind
}

func (q *Qualifier) SetKind(
	value *QualifierKind,
) {
	q.kind = value
}

func (q *Qualifier) Type(
) string {
	return q.typE
}

func (q *Qualifier) SetType(
	value string,
) {
	q.typE = value
}

func (q *Qualifier) ValueType(
) DataTypeDefXSD {
	return q.valueType
}

func (q *Qualifier) SetValueType(
	value DataTypeDefXSD,
) {
	q.valueType = value
}

func (q *Qualifier) Value(
) *string {
	return q.value
}

func (q *Qualifier) SetValue(
	value *string,
) {
	q.value = value
}

func (q *Qualifier) ValueID(
) IReference {
	return q.valueID
}

func (q *Qualifier) SetValueID(
	value IReference,
) {
	q.valueID = value
}

func (q *Qualifier) ModelType(
) ModelType {
	return ModelTypeQualifier
}

// Return [IQualifier.Kind] or the default value
// if it has not been set.
func (q *Qualifier) KindOrDefault() QualifierKind {
	v := q.Kind()
	if v == nil {
		return QualifierKindConceptQualifier
	}

	return *v
}

// Apply the action on the instances referenced from q.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on q.
func (q *Qualifier) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if q.semanticID != nil {
		abort = action(
			q.semanticID,
		)
		if abort {
			return
		}
	}

	if q.supplementalSemanticIDs != nil {
		for _, v := range q.supplementalSemanticIDs {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if q.valueID != nil {
		abort = action(
			q.valueID,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from q.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on q.
func (q *Qualifier) Descend(
	action func(IClass) bool,
) (abort bool) {
	if q.semanticID != nil {
		abort = action(
			q.semanticID,
		)
		if abort {
			return
		}
		abort = q.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if q.supplementalSemanticIDs != nil {
		for _, v := range q.supplementalSemanticIDs {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if q.valueID != nil {
		abort = action(
			q.valueID,
		)
		if abort {
			return
		}
		abort = q.valueID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of Qualifier with
// the given properties.
func NewQualifier(
	typE string,
	valueType DataTypeDefXSD,
) *Qualifier {
	return &Qualifier{
		typE: typE,
		valueType: valueType,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		kind: nil,
		value: nil,
		valueID: nil,
	}
}

// An asset administration shell.
type IAssetAdministrationShell interface {
	IIdentifiable

	IHasDataSpecification

	// The reference to the AAS the AAS was derived from.
	DerivedFrom() IReference;

	SetDerivedFrom(
		value IReference,
	);

	// Meta-information about the asset the AAS is representing.
	AssetInformation() IAssetInformation;

	SetAssetInformation(
		value IAssetInformation,
	);

	// References to submodels of the AAS.
	//
	// A submodel is a description of an aspect of the asset the AAS is representing.
	//
	// The asset of an AAS is typically described by one or more submodels.
	//
	// Temporarily no submodel might be assigned to the AAS.
	Submodels() []IReference;

	SetSubmodels(
		value []IReference,
	);
}

// Check whether the instance corresponds to [aastypes.IAssetAdministrationShell]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsAssetAdministrationShell(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeAssetAdministrationShell
	return
}

// Implements IAssetAdministrationShell.
type AssetAdministrationShell struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	administration IAdministrativeInformation
	id string
	embeddedDataSpecifications []IEmbeddedDataSpecification
	derivedFrom IReference
	assetInformation IAssetInformation
	submodels []IReference
}

func (aas *AssetAdministrationShell) Extensions(
) []IExtension {
	return aas.extensions
}

func (aas *AssetAdministrationShell) SetExtensions(
	value []IExtension,
) {
	aas.extensions = value
}

func (aas *AssetAdministrationShell) Category(
) *string {
	return aas.category
}

func (aas *AssetAdministrationShell) SetCategory(
	value *string,
) {
	aas.category = value
}

func (aas *AssetAdministrationShell) IDShort(
) *string {
	return aas.idShort
}

func (aas *AssetAdministrationShell) SetIDShort(
	value *string,
) {
	aas.idShort = value
}

func (aas *AssetAdministrationShell) DisplayName(
) []ILangStringNameType {
	return aas.displayName
}

func (aas *AssetAdministrationShell) SetDisplayName(
	value []ILangStringNameType,
) {
	aas.displayName = value
}

func (aas *AssetAdministrationShell) Description(
) []ILangStringTextType {
	return aas.description
}

func (aas *AssetAdministrationShell) SetDescription(
	value []ILangStringTextType,
) {
	aas.description = value
}

func (aas *AssetAdministrationShell) Administration(
) IAdministrativeInformation {
	return aas.administration
}

func (aas *AssetAdministrationShell) SetAdministration(
	value IAdministrativeInformation,
) {
	aas.administration = value
}

func (aas *AssetAdministrationShell) ID(
) string {
	return aas.id
}

func (aas *AssetAdministrationShell) SetID(
	value string,
) {
	aas.id = value
}

func (aas *AssetAdministrationShell) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return aas.embeddedDataSpecifications
}

func (aas *AssetAdministrationShell) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	aas.embeddedDataSpecifications = value
}

func (aas *AssetAdministrationShell) DerivedFrom(
) IReference {
	return aas.derivedFrom
}

func (aas *AssetAdministrationShell) SetDerivedFrom(
	value IReference,
) {
	aas.derivedFrom = value
}

func (aas *AssetAdministrationShell) AssetInformation(
) IAssetInformation {
	return aas.assetInformation
}

func (aas *AssetAdministrationShell) SetAssetInformation(
	value IAssetInformation,
) {
	aas.assetInformation = value
}

func (aas *AssetAdministrationShell) Submodels(
) []IReference {
	return aas.submodels
}

func (aas *AssetAdministrationShell) SetSubmodels(
	value []IReference,
) {
	aas.submodels = value
}

func (aas *AssetAdministrationShell) ModelType(
) ModelType {
	return ModelTypeAssetAdministrationShell
}

// Apply the action on the instances referenced from aas.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on aas.
func (aas *AssetAdministrationShell) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if aas.extensions != nil {
		for _, v := range aas.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if aas.displayName != nil {
		for _, v1 := range aas.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if aas.description != nil {
		for _, v2 := range aas.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if aas.administration != nil {
		abort = action(
			aas.administration,
		)
		if abort {
			return
		}
	}

	if aas.embeddedDataSpecifications != nil {
		for _, v3 := range aas.embeddedDataSpecifications {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if aas.derivedFrom != nil {
		abort = action(
			aas.derivedFrom,
		)
		if abort {
			return
		}
	}

	abort = action(
		aas.assetInformation,
	)
	if abort {
		return
	}

	if aas.submodels != nil {
		for _, v4 := range aas.submodels {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from aas.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on aas.
func (aas *AssetAdministrationShell) Descend(
	action func(IClass) bool,
) (abort bool) {
	if aas.extensions != nil {
		for _, v := range aas.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if aas.displayName != nil {
		for _, v1 := range aas.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if aas.description != nil {
		for _, v2 := range aas.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if aas.administration != nil {
		abort = action(
			aas.administration,
		)
		if abort {
			return
		}
		abort = aas.administration.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if aas.embeddedDataSpecifications != nil {
		for _, v3 := range aas.embeddedDataSpecifications {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if aas.derivedFrom != nil {
		abort = action(
			aas.derivedFrom,
		)
		if abort {
			return
		}
		abort = aas.derivedFrom.Descend(
			action,
		)
		if abort {
			return
		}
	}

	abort = action(
		aas.assetInformation,
	)
	if abort {
		return
	}
	abort = aas.assetInformation.Descend(
		action,
	)
	if abort {
		return
	}

	if aas.submodels != nil {
		for _, v4 := range aas.submodels {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of AssetAdministrationShell with
// the given properties.
func NewAssetAdministrationShell(
	id string,
	assetInformation IAssetInformation,
) *AssetAdministrationShell {
	return &AssetAdministrationShell{
		id: id,
		assetInformation: assetInformation,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		administration: nil,
		embeddedDataSpecifications: nil,
		derivedFrom: nil,
		submodels: nil,
	}
}

// In [IAssetInformation] identifying meta data of the asset that is
// represented by an AAS is defined.
//
// The asset may either represent an asset type or an asset instance.
//
// The asset has a globally unique identifier plus – if needed – additional domain
// specific (proprietary) identifiers. However, to support the corner case of very
// first phase of lifecycle where a stabilised/constant_set global asset identifier
// does not already exist, the corresponding attribute [IAssetInformation.GlobalAssetID] is
// optional.
//
// Constraint AASd-116:
// `globalAssetId` is a reserved key. If used as value for
// [ISpecificAssetID.Name] then [ISpecificAssetID.Value] shall be
// identical to [IAssetInformation.GlobalAssetID].
//
// NOTE: Constraint AASd-116 is important to enable a generic search across
// global and specific asset IDs.
//
// NOTE: In the book, Constraint AASd-116 imposes a
// case-insensitive equality against `globalAssetId`. This is
// culturally-dependent, and depends on the system settings.
// For example, the case-folding for the letters "i" and "I" is
// different in Turkish from English.
//
// We implement the constraint as case-sensitive instead to allow
// for interoperability across different culture settings.
//
// Constraint AASd-131:
// For [IAssetInformation] either the [IAssetInformation.GlobalAssetID] shall be
// defined or at least one item in [IAssetInformation.SpecificAssetIDs].
type IAssetInformation interface {
	IClass

	// Denotes whether the Asset is of kind [AssetKindType] or
	// [AssetKindInstance].
	AssetKind() AssetKind;

	SetAssetKind(
		value AssetKind,
	);

	// Global identifier of the asset the AAS is representing.
	//
	// This attribute is required as soon as the AAS is exchanged via partners in the life
	// cycle of the asset. In a first phase of the life cycle the asset might not yet have
	// a global ID but already an internal identifier. The internal identifier would be
	// modelled via [IAssetInformation.SpecificAssetIDs].
	//
	// NOTE: This is a global reference.
	GlobalAssetID() *string;

	SetGlobalAssetID(
		value *string,
	);

	// Additional domain-specific, typically proprietary identifier for the asset like
	// e.g., serial number etc.
	SpecificAssetIDs() []ISpecificAssetID;

	SetSpecificAssetIDs(
		value []ISpecificAssetID,
	);

	// In case [IAssetInformation.AssetKind] is applicable the [IAssetInformation.AssetType] is the asset ID
	// of the type asset of the asset under consideration
	// as identified by [IAssetInformation.GlobalAssetID].
	//
	// NOTE: In case [IAssetInformation.AssetKind] is "Instance" than the [IAssetInformation.AssetType] denotes
	// which "Type" the asset is of. But it is also possible
	// to have an [IAssetInformation.AssetType] of an asset of kind "Type".
	AssetType() *string;

	SetAssetType(
		value *string,
	);

	// Thumbnail of the asset represented by the Asset Administration Shell.
	//
	// Used as default.
	DefaultThumbnail() IResource;

	SetDefaultThumbnail(
		value IResource,
	);
}

// Check whether the instance corresponds to [aastypes.IAssetInformation]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsAssetInformation(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeAssetInformation
	return
}

// Implements IAssetInformation.
type AssetInformation struct {
	assetKind AssetKind
	globalAssetID *string
	specificAssetIDs []ISpecificAssetID
	assetType *string
	defaultThumbnail IResource
}

func (ai *AssetInformation) AssetKind(
) AssetKind {
	return ai.assetKind
}

func (ai *AssetInformation) SetAssetKind(
	value AssetKind,
) {
	ai.assetKind = value
}

func (ai *AssetInformation) GlobalAssetID(
) *string {
	return ai.globalAssetID
}

func (ai *AssetInformation) SetGlobalAssetID(
	value *string,
) {
	ai.globalAssetID = value
}

func (ai *AssetInformation) SpecificAssetIDs(
) []ISpecificAssetID {
	return ai.specificAssetIDs
}

func (ai *AssetInformation) SetSpecificAssetIDs(
	value []ISpecificAssetID,
) {
	ai.specificAssetIDs = value
}

func (ai *AssetInformation) AssetType(
) *string {
	return ai.assetType
}

func (ai *AssetInformation) SetAssetType(
	value *string,
) {
	ai.assetType = value
}

func (ai *AssetInformation) DefaultThumbnail(
) IResource {
	return ai.defaultThumbnail
}

func (ai *AssetInformation) SetDefaultThumbnail(
	value IResource,
) {
	ai.defaultThumbnail = value
}

func (ai *AssetInformation) ModelType(
) ModelType {
	return ModelTypeAssetInformation
}

// Apply the action on the instances referenced from ai.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on ai.
func (ai *AssetInformation) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if ai.specificAssetIDs != nil {
		for _, v := range ai.specificAssetIDs {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if ai.defaultThumbnail != nil {
		abort = action(
			ai.defaultThumbnail,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from ai.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on ai.
func (ai *AssetInformation) Descend(
	action func(IClass) bool,
) (abort bool) {
	if ai.specificAssetIDs != nil {
		for _, v := range ai.specificAssetIDs {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if ai.defaultThumbnail != nil {
		abort = action(
			ai.defaultThumbnail,
		)
		if abort {
			return
		}
		abort = ai.defaultThumbnail.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of AssetInformation with
// the given properties.
func NewAssetInformation(
	assetKind AssetKind,
) *AssetInformation {
	return &AssetInformation{
		assetKind: assetKind,
		globalAssetID: nil,
		specificAssetIDs: nil,
		assetType: nil,
		defaultThumbnail: nil,
	}
}

// Resource represents an address to a file (a locator). The value is an URI that
// can represent an absolute or relative path
type IResource interface {
	IClass

	// Path and name of the resource (with file extension).
	//
	// The path can be absolute or relative.
	Path() string;

	SetPath(
		value string,
	);

	// Content type of the content of the file.
	//
	// The content type states which file extensions the file can have.
	ContentType() *string;

	SetContentType(
		value *string,
	);
}

// Check whether the instance corresponds to [aastypes.IResource]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsResource(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeResource
	return
}

// Implements IResource.
type Resource struct {
	path string
	contentType *string
}

func (r *Resource) Path(
) string {
	return r.path
}

func (r *Resource) SetPath(
	value string,
) {
	r.path = value
}

func (r *Resource) ContentType(
) *string {
	return r.contentType
}

func (r *Resource) SetContentType(
	value *string,
) {
	r.contentType = value
}

func (r *Resource) ModelType(
) ModelType {
	return ModelTypeResource
}

// Apply the action on the instances referenced from r.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on r.
func (r *Resource) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from r.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on r.
func (r *Resource) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of Resource with
// the given properties.
func NewResource(
	path string,
) *Resource {
	return &Resource{
		path: path,
		contentType: nil,
	}
}

// Enumeration for denoting whether an asset is a type asset or an instance asset.
type AssetKind int;const (
	// Type asset
	AssetKindType AssetKind = iota
	// Instance asset
	AssetKindInstance
	// Neither a type asset nor an instance asset
	AssetKindNotApplicable
)

// List the literals of [AssetKind].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfAssetKind = [...]AssetKind {
	AssetKindType,
	AssetKindInstance,
	AssetKindNotApplicable,
}

// A specific asset ID describes a generic supplementary identifying attribute of the
// asset.
//
// The specific asset ID is not necessarily globally unique.
//
// Constraint AASd-133:
// [ISpecificAssetID.ExternalSubjectID] shall be an external reference,
// i.e. [IReference.Type] = [ReferenceTypesExternalReference].
type ISpecificAssetID interface {
	IHasSemantics

	// Name of the identifier
	Name() string;

	SetName(
		value string,
	);

	// The value of the specific asset identifier with the corresponding name.
	Value() string;

	SetValue(
		value string,
	);

	// The (external) subject the key belongs to or has meaning to.
	//
	// NOTE: This is a global reference.
	ExternalSubjectID() IReference;

	SetExternalSubjectID(
		value IReference,
	);
}

// Check whether the instance corresponds to [aastypes.ISpecificAssetID]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsSpecificAssetID(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeSpecificAssetID
	return
}

// Implements ISpecificAssetID.
type SpecificAssetID struct {
	semanticID IReference
	supplementalSemanticIDs []IReference
	name string
	value string
	externalSubjectID IReference
}

func (sai *SpecificAssetID) SemanticID(
) IReference {
	return sai.semanticID
}

func (sai *SpecificAssetID) SetSemanticID(
	value IReference,
) {
	sai.semanticID = value
}

func (sai *SpecificAssetID) SupplementalSemanticIDs(
) []IReference {
	return sai.supplementalSemanticIDs
}

func (sai *SpecificAssetID) SetSupplementalSemanticIDs(
	value []IReference,
) {
	sai.supplementalSemanticIDs = value
}

func (sai *SpecificAssetID) Name(
) string {
	return sai.name
}

func (sai *SpecificAssetID) SetName(
	value string,
) {
	sai.name = value
}

func (sai *SpecificAssetID) Value(
) string {
	return sai.value
}

func (sai *SpecificAssetID) SetValue(
	value string,
) {
	sai.value = value
}

func (sai *SpecificAssetID) ExternalSubjectID(
) IReference {
	return sai.externalSubjectID
}

func (sai *SpecificAssetID) SetExternalSubjectID(
	value IReference,
) {
	sai.externalSubjectID = value
}

func (sai *SpecificAssetID) ModelType(
) ModelType {
	return ModelTypeSpecificAssetID
}

// Apply the action on the instances referenced from sai.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on sai.
func (sai *SpecificAssetID) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if sai.semanticID != nil {
		abort = action(
			sai.semanticID,
		)
		if abort {
			return
		}
	}

	if sai.supplementalSemanticIDs != nil {
		for _, v := range sai.supplementalSemanticIDs {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if sai.externalSubjectID != nil {
		abort = action(
			sai.externalSubjectID,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from sai.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on sai.
func (sai *SpecificAssetID) Descend(
	action func(IClass) bool,
) (abort bool) {
	if sai.semanticID != nil {
		abort = action(
			sai.semanticID,
		)
		if abort {
			return
		}
		abort = sai.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if sai.supplementalSemanticIDs != nil {
		for _, v := range sai.supplementalSemanticIDs {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sai.externalSubjectID != nil {
		abort = action(
			sai.externalSubjectID,
		)
		if abort {
			return
		}
		abort = sai.externalSubjectID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of SpecificAssetID with
// the given properties.
func NewSpecificAssetID(
	name string,
	value string,
) *SpecificAssetID {
	return &SpecificAssetID{
		name: name,
		value: value,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		externalSubjectID: nil,
	}
}

// A submodel defines a specific aspect of the asset represented by the AAS.
//
// A submodel is used to structure the digital representation and technical
// functionality of an Administration Shell into distinguishable parts. Each submodel
// refers to a well-defined domain or subject matter. Submodels can become
// standardized and, thus, become submodels templates.
type ISubmodel interface {
	IIdentifiable

	IHasKind

	IHasSemantics

	IQualifiable

	IHasDataSpecification

	// A submodel consists of zero or more submodel elements.
	SubmodelElements() []ISubmodelElement;

	SetSubmodelElements(
		value []ISubmodelElement,
	);

	KindOrDefault() ModellingKind;
}

// Check whether the instance corresponds to [aastypes.ISubmodel]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsSubmodel(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeSubmodel
	return
}

// Implements ISubmodel.
type Submodel struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	administration IAdministrativeInformation
	id string
	kind *ModellingKind
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	submodelElements []ISubmodelElement
}

func (s *Submodel) Extensions(
) []IExtension {
	return s.extensions
}

func (s *Submodel) SetExtensions(
	value []IExtension,
) {
	s.extensions = value
}

func (s *Submodel) Category(
) *string {
	return s.category
}

func (s *Submodel) SetCategory(
	value *string,
) {
	s.category = value
}

func (s *Submodel) IDShort(
) *string {
	return s.idShort
}

func (s *Submodel) SetIDShort(
	value *string,
) {
	s.idShort = value
}

func (s *Submodel) DisplayName(
) []ILangStringNameType {
	return s.displayName
}

func (s *Submodel) SetDisplayName(
	value []ILangStringNameType,
) {
	s.displayName = value
}

func (s *Submodel) Description(
) []ILangStringTextType {
	return s.description
}

func (s *Submodel) SetDescription(
	value []ILangStringTextType,
) {
	s.description = value
}

func (s *Submodel) Administration(
) IAdministrativeInformation {
	return s.administration
}

func (s *Submodel) SetAdministration(
	value IAdministrativeInformation,
) {
	s.administration = value
}

func (s *Submodel) ID(
) string {
	return s.id
}

func (s *Submodel) SetID(
	value string,
) {
	s.id = value
}

func (s *Submodel) Kind(
) *ModellingKind {
	return s.kind
}

func (s *Submodel) SetKind(
	value *ModellingKind,
) {
	s.kind = value
}

func (s *Submodel) SemanticID(
) IReference {
	return s.semanticID
}

func (s *Submodel) SetSemanticID(
	value IReference,
) {
	s.semanticID = value
}

func (s *Submodel) SupplementalSemanticIDs(
) []IReference {
	return s.supplementalSemanticIDs
}

func (s *Submodel) SetSupplementalSemanticIDs(
	value []IReference,
) {
	s.supplementalSemanticIDs = value
}

func (s *Submodel) Qualifiers(
) []IQualifier {
	return s.qualifiers
}

func (s *Submodel) SetQualifiers(
	value []IQualifier,
) {
	s.qualifiers = value
}

func (s *Submodel) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return s.embeddedDataSpecifications
}

func (s *Submodel) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	s.embeddedDataSpecifications = value
}

func (s *Submodel) SubmodelElements(
) []ISubmodelElement {
	return s.submodelElements
}

func (s *Submodel) SetSubmodelElements(
	value []ISubmodelElement,
) {
	s.submodelElements = value
}

func (s *Submodel) ModelType(
) ModelType {
	return ModelTypeSubmodel
}

// Return [IHasKind.Kind] or the default value
// if it has not been set.
func (s *Submodel) KindOrDefault() ModellingKind {
	v := s.Kind()
	if v == nil {
		return ModellingKindInstance
	}

	return *v
}

// Apply the action on the instances referenced from s.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on s.
func (s *Submodel) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if s.extensions != nil {
		for _, v := range s.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if s.displayName != nil {
		for _, v1 := range s.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if s.description != nil {
		for _, v2 := range s.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if s.administration != nil {
		abort = action(
			s.administration,
		)
		if abort {
			return
		}
	}

	if s.semanticID != nil {
		abort = action(
			s.semanticID,
		)
		if abort {
			return
		}
	}

	if s.supplementalSemanticIDs != nil {
		for _, v3 := range s.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if s.qualifiers != nil {
		for _, v4 := range s.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if s.embeddedDataSpecifications != nil {
		for _, v5 := range s.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if s.submodelElements != nil {
		for _, v6 := range s.submodelElements {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from s.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on s.
func (s *Submodel) Descend(
	action func(IClass) bool,
) (abort bool) {
	if s.extensions != nil {
		for _, v := range s.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if s.displayName != nil {
		for _, v1 := range s.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if s.description != nil {
		for _, v2 := range s.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if s.administration != nil {
		abort = action(
			s.administration,
		)
		if abort {
			return
		}
		abort = s.administration.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if s.semanticID != nil {
		abort = action(
			s.semanticID,
		)
		if abort {
			return
		}
		abort = s.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if s.supplementalSemanticIDs != nil {
		for _, v3 := range s.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if s.qualifiers != nil {
		for _, v4 := range s.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if s.embeddedDataSpecifications != nil {
		for _, v5 := range s.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if s.submodelElements != nil {
		for _, v6 := range s.submodelElements {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Submodel with
// the given properties.
func NewSubmodel(
	id string,
) *Submodel {
	return &Submodel{
		id: id,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		administration: nil,
		kind: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		submodelElements: nil,
	}
}

// A submodel element is an element suitable for the description and differentiation of
// assets.
//
// It is recommended to add a [IHasSemantics.SemanticID] to a submodel element.
//
// Constraint AASd-129:
// If any [IQualifier.Kind] value of [ISubmodelElement.Qualifiers] (attribute qualifier
// inherited via Qualifiable) is equal to [QualifierKindTemplateQualifier]
// then the submodel element shall be part of a submodel template, i.e.
// a Submodel with [ISubmodel.Kind] (attribute kind inherited via
// [IHasKind]) value is equal to [ModellingKindTemplate].
type ISubmodelElement interface {
	IReferable

	IHasSemantics

	IQualifiable

	IHasDataSpecification
}

// Check whether the instance corresponds to [aastypes.ISubmodelElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsSubmodelElement(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeSubmodelElementList:
		ok = true
	case ModelTypeSubmodelElementCollection:
		ok = true
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	case ModelTypeEntity:
		ok = true
	case ModelTypeBasicEventElement:
		ok = true
	case ModelTypeOperation:
		ok = true
	case ModelTypeCapability:
		ok = true
	}
	return
}

// A relationship element is used to define a relationship between two elements
// being either referable (model reference) or external (global reference).
type IRelationshipElement interface {
	ISubmodelElement

	// Reference to the first element in the relationship taking the role of the subject.
	First() IReference;

	SetFirst(
		value IReference,
	);

	// Reference to the second element in the relationship taking the role of the object.
	Second() IReference;

	SetSecond(
		value IReference,
	);
}

// Check whether the instance corresponds to [aastypes.IRelationshipElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsRelationshipElement(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeRelationshipElement:
		ok = true
	case ModelTypeAnnotatedRelationshipElement:
		ok = true
	}
	return
}

// Implements IRelationshipElement.
type RelationshipElement struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	first IReference
	second IReference
}

func (re *RelationshipElement) Extensions(
) []IExtension {
	return re.extensions
}

func (re *RelationshipElement) SetExtensions(
	value []IExtension,
) {
	re.extensions = value
}

func (re *RelationshipElement) Category(
) *string {
	return re.category
}

func (re *RelationshipElement) SetCategory(
	value *string,
) {
	re.category = value
}

func (re *RelationshipElement) IDShort(
) *string {
	return re.idShort
}

func (re *RelationshipElement) SetIDShort(
	value *string,
) {
	re.idShort = value
}

func (re *RelationshipElement) DisplayName(
) []ILangStringNameType {
	return re.displayName
}

func (re *RelationshipElement) SetDisplayName(
	value []ILangStringNameType,
) {
	re.displayName = value
}

func (re *RelationshipElement) Description(
) []ILangStringTextType {
	return re.description
}

func (re *RelationshipElement) SetDescription(
	value []ILangStringTextType,
) {
	re.description = value
}

func (re *RelationshipElement) SemanticID(
) IReference {
	return re.semanticID
}

func (re *RelationshipElement) SetSemanticID(
	value IReference,
) {
	re.semanticID = value
}

func (re *RelationshipElement) SupplementalSemanticIDs(
) []IReference {
	return re.supplementalSemanticIDs
}

func (re *RelationshipElement) SetSupplementalSemanticIDs(
	value []IReference,
) {
	re.supplementalSemanticIDs = value
}

func (re *RelationshipElement) Qualifiers(
) []IQualifier {
	return re.qualifiers
}

func (re *RelationshipElement) SetQualifiers(
	value []IQualifier,
) {
	re.qualifiers = value
}

func (re *RelationshipElement) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return re.embeddedDataSpecifications
}

func (re *RelationshipElement) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	re.embeddedDataSpecifications = value
}

func (re *RelationshipElement) First(
) IReference {
	return re.first
}

func (re *RelationshipElement) SetFirst(
	value IReference,
) {
	re.first = value
}

func (re *RelationshipElement) Second(
) IReference {
	return re.second
}

func (re *RelationshipElement) SetSecond(
	value IReference,
) {
	re.second = value
}

func (re *RelationshipElement) ModelType(
) ModelType {
	return ModelTypeRelationshipElement
}

// Apply the action on the instances referenced from re.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on re.
func (re *RelationshipElement) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if re.extensions != nil {
		for _, v := range re.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if re.displayName != nil {
		for _, v1 := range re.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if re.description != nil {
		for _, v2 := range re.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if re.semanticID != nil {
		abort = action(
			re.semanticID,
		)
		if abort {
			return
		}
	}

	if re.supplementalSemanticIDs != nil {
		for _, v3 := range re.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if re.qualifiers != nil {
		for _, v4 := range re.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if re.embeddedDataSpecifications != nil {
		for _, v5 := range re.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	abort = action(
		re.first,
	)
	if abort {
		return
	}

	abort = action(
		re.second,
	)
	if abort {
		return
	}

	return
}

// Apply the action recursively on the instances referenced from re.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on re.
func (re *RelationshipElement) Descend(
	action func(IClass) bool,
) (abort bool) {
	if re.extensions != nil {
		for _, v := range re.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.displayName != nil {
		for _, v1 := range re.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.description != nil {
		for _, v2 := range re.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.semanticID != nil {
		abort = action(
			re.semanticID,
		)
		if abort {
			return
		}
		abort = re.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if re.supplementalSemanticIDs != nil {
		for _, v3 := range re.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.qualifiers != nil {
		for _, v4 := range re.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.embeddedDataSpecifications != nil {
		for _, v5 := range re.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	abort = action(
		re.first,
	)
	if abort {
		return
	}
	abort = re.first.Descend(
		action,
	)
	if abort {
		return
	}

	abort = action(
		re.second,
	)
	if abort {
		return
	}
	abort = re.second.Descend(
		action,
	)
	if abort {
		return
	}

	return
}

// Create a new instance of RelationshipElement with
// the given properties.
func NewRelationshipElement(
	first IReference,
	second IReference,
) *RelationshipElement {
	return &RelationshipElement{
		first: first,
		second: second,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
	}
}

// Enumeration of all possible elements of a [ISubmodelElementList].
type AASSubmodelElements int;const (
	AASSubmodelElementsAnnotatedRelationshipElement AASSubmodelElements = iota
	AASSubmodelElementsBasicEventElement
	AASSubmodelElementsBlob
	AASSubmodelElementsCapability
	AASSubmodelElementsDataElement
	AASSubmodelElementsEntity
	AASSubmodelElementsEventElement
	AASSubmodelElementsFile
	AASSubmodelElementsMultiLanguageProperty
	AASSubmodelElementsOperation
	AASSubmodelElementsProperty
	AASSubmodelElementsRange
	AASSubmodelElementsReferenceElement
	AASSubmodelElementsRelationshipElement
	AASSubmodelElementsSubmodelElement
	AASSubmodelElementsSubmodelElementList
	AASSubmodelElementsSubmodelElementCollection
)

// List the literals of [AASSubmodelElements].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfAASSubmodelElements = [...]AASSubmodelElements {
	AASSubmodelElementsAnnotatedRelationshipElement,
	AASSubmodelElementsBasicEventElement,
	AASSubmodelElementsBlob,
	AASSubmodelElementsCapability,
	AASSubmodelElementsDataElement,
	AASSubmodelElementsEntity,
	AASSubmodelElementsEventElement,
	AASSubmodelElementsFile,
	AASSubmodelElementsMultiLanguageProperty,
	AASSubmodelElementsOperation,
	AASSubmodelElementsProperty,
	AASSubmodelElementsRange,
	AASSubmodelElementsReferenceElement,
	AASSubmodelElementsRelationshipElement,
	AASSubmodelElementsSubmodelElement,
	AASSubmodelElementsSubmodelElementList,
	AASSubmodelElementsSubmodelElementCollection,
}

// A submodel element list is an ordered list of submodel elements.
//
// The numbering starts with zero (0).
//
// Constraint AASd-107:
// If a first level child element in a [ISubmodelElementList] has
// a [IHasSemantics.SemanticID] it
// shall be identical to [ISubmodelElementList.SemanticIDListElement].
//
// Constraint AASd-114:
// If two first level child elements in a [ISubmodelElementList] have
// a [IHasSemantics.SemanticID] then they shall be identical.
//
// Constraint AASd-115:
// If a first level child element in a [ISubmodelElementList] does not
// specify a [IHasSemantics.SemanticID] then the value is assumed to be
// identical to [ISubmodelElementList.SemanticIDListElement].
//
// Constraint AASd-120:
// The [ISubmodelElementList.IDShort] of a [ISubmodelElement] being a direct child of a
// [ISubmodelElementList] shall not be specified.
//
// Constraint AASd-108:
// All first level child elements in a [ISubmodelElementList] shall have
// the same submodel element type as specified in [ISubmodelElementList.TypeValueListElement].
//
// Constraint AASd-109:
// If [ISubmodelElementList.TypeValueListElement] is equal to
// [AASSubmodelElementsProperty] or
// [AASSubmodelElementsRange]
// [ISubmodelElementList.ValueTypeListElement] shall be set and all first
// level child elements in the [ISubmodelElementList] shall have
// the value type as specified in [ISubmodelElementList.ValueTypeListElement].
type ISubmodelElementList interface {
	ISubmodelElement

	// Defines whether order in list is relevant. If [ISubmodelElementList.OrderRelevant] = `False`
	// then the list is representing a set or a bag.
	//
	// Default: `True`
	OrderRelevant() *bool;

	SetOrderRelevant(
		value *bool,
	);

	// Semantic ID the submodel elements contained in the list match to.
	//
	// NOTE: It is recommended to use a global reference.
	SemanticIDListElement() IReference;

	SetSemanticIDListElement(
		value IReference,
	);

	// The submodel element type of the submodel elements contained in the list.
	TypeValueListElement() AASSubmodelElements;

	SetTypeValueListElement(
		value AASSubmodelElements,
	);

	// The value type of the submodel element contained in the list.
	ValueTypeListElement() *DataTypeDefXSD;

	SetValueTypeListElement(
		value *DataTypeDefXSD,
	);

	// Submodel element contained in the list.
	//
	// The list is ordered.
	Value() []ISubmodelElement;

	SetValue(
		value []ISubmodelElement,
	);

	OrderRelevantOrDefault() bool;
}

// Check whether the instance corresponds to [aastypes.ISubmodelElementList]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsSubmodelElementList(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeSubmodelElementList
	return
}

// Implements ISubmodelElementList.
type SubmodelElementList struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	orderRelevant *bool
	semanticIDListElement IReference
	typeValueListElement AASSubmodelElements
	valueTypeListElement *DataTypeDefXSD
	value []ISubmodelElement
}

func (sel *SubmodelElementList) Extensions(
) []IExtension {
	return sel.extensions
}

func (sel *SubmodelElementList) SetExtensions(
	value []IExtension,
) {
	sel.extensions = value
}

func (sel *SubmodelElementList) Category(
) *string {
	return sel.category
}

func (sel *SubmodelElementList) SetCategory(
	value *string,
) {
	sel.category = value
}

func (sel *SubmodelElementList) IDShort(
) *string {
	return sel.idShort
}

func (sel *SubmodelElementList) SetIDShort(
	value *string,
) {
	sel.idShort = value
}

func (sel *SubmodelElementList) DisplayName(
) []ILangStringNameType {
	return sel.displayName
}

func (sel *SubmodelElementList) SetDisplayName(
	value []ILangStringNameType,
) {
	sel.displayName = value
}

func (sel *SubmodelElementList) Description(
) []ILangStringTextType {
	return sel.description
}

func (sel *SubmodelElementList) SetDescription(
	value []ILangStringTextType,
) {
	sel.description = value
}

func (sel *SubmodelElementList) SemanticID(
) IReference {
	return sel.semanticID
}

func (sel *SubmodelElementList) SetSemanticID(
	value IReference,
) {
	sel.semanticID = value
}

func (sel *SubmodelElementList) SupplementalSemanticIDs(
) []IReference {
	return sel.supplementalSemanticIDs
}

func (sel *SubmodelElementList) SetSupplementalSemanticIDs(
	value []IReference,
) {
	sel.supplementalSemanticIDs = value
}

func (sel *SubmodelElementList) Qualifiers(
) []IQualifier {
	return sel.qualifiers
}

func (sel *SubmodelElementList) SetQualifiers(
	value []IQualifier,
) {
	sel.qualifiers = value
}

func (sel *SubmodelElementList) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return sel.embeddedDataSpecifications
}

func (sel *SubmodelElementList) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	sel.embeddedDataSpecifications = value
}

func (sel *SubmodelElementList) OrderRelevant(
) *bool {
	return sel.orderRelevant
}

func (sel *SubmodelElementList) SetOrderRelevant(
	value *bool,
) {
	sel.orderRelevant = value
}

func (sel *SubmodelElementList) SemanticIDListElement(
) IReference {
	return sel.semanticIDListElement
}

func (sel *SubmodelElementList) SetSemanticIDListElement(
	value IReference,
) {
	sel.semanticIDListElement = value
}

func (sel *SubmodelElementList) TypeValueListElement(
) AASSubmodelElements {
	return sel.typeValueListElement
}

func (sel *SubmodelElementList) SetTypeValueListElement(
	value AASSubmodelElements,
) {
	sel.typeValueListElement = value
}

func (sel *SubmodelElementList) ValueTypeListElement(
) *DataTypeDefXSD {
	return sel.valueTypeListElement
}

func (sel *SubmodelElementList) SetValueTypeListElement(
	value *DataTypeDefXSD,
) {
	sel.valueTypeListElement = value
}

func (sel *SubmodelElementList) Value(
) []ISubmodelElement {
	return sel.value
}

func (sel *SubmodelElementList) SetValue(
	value []ISubmodelElement,
) {
	sel.value = value
}

func (sel *SubmodelElementList) ModelType(
) ModelType {
	return ModelTypeSubmodelElementList
}

// Return [ISubmodelElementKind.OrderRelevant] or the default value
// if it has not been set.
func (sel *SubmodelElementList) OrderRelevantOrDefault() bool {
	v := sel.OrderRelevant()
	if v == nil {
		return true
	}

	return *v
}

// Apply the action on the instances referenced from sel.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on sel.
func (sel *SubmodelElementList) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if sel.extensions != nil {
		for _, v := range sel.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if sel.displayName != nil {
		for _, v1 := range sel.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if sel.description != nil {
		for _, v2 := range sel.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if sel.semanticID != nil {
		abort = action(
			sel.semanticID,
		)
		if abort {
			return
		}
	}

	if sel.supplementalSemanticIDs != nil {
		for _, v3 := range sel.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if sel.qualifiers != nil {
		for _, v4 := range sel.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if sel.embeddedDataSpecifications != nil {
		for _, v5 := range sel.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if sel.semanticIDListElement != nil {
		abort = action(
			sel.semanticIDListElement,
		)
		if abort {
			return
		}
	}

	if sel.value != nil {
		for _, v6 := range sel.value {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from sel.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on sel.
func (sel *SubmodelElementList) Descend(
	action func(IClass) bool,
) (abort bool) {
	if sel.extensions != nil {
		for _, v := range sel.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sel.displayName != nil {
		for _, v1 := range sel.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sel.description != nil {
		for _, v2 := range sel.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sel.semanticID != nil {
		abort = action(
			sel.semanticID,
		)
		if abort {
			return
		}
		abort = sel.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if sel.supplementalSemanticIDs != nil {
		for _, v3 := range sel.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sel.qualifiers != nil {
		for _, v4 := range sel.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sel.embeddedDataSpecifications != nil {
		for _, v5 := range sel.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sel.semanticIDListElement != nil {
		abort = action(
			sel.semanticIDListElement,
		)
		if abort {
			return
		}
		abort = sel.semanticIDListElement.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if sel.value != nil {
		for _, v6 := range sel.value {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of SubmodelElementList with
// the given properties.
func NewSubmodelElementList(
	typeValueListElement AASSubmodelElements,
) *SubmodelElementList {
	return &SubmodelElementList{
		typeValueListElement: typeValueListElement,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		orderRelevant: nil,
		semanticIDListElement: nil,
		valueTypeListElement: nil,
		value: nil,
	}
}

// A submodel element collection is a kind of struct, i.e. a a logical encapsulation
// of multiple named values. It has a fixed number of submodel elements.
type ISubmodelElementCollection interface {
	ISubmodelElement

	// Submodel element contained in the collection.
	Value() []ISubmodelElement;

	SetValue(
		value []ISubmodelElement,
	);
}

// Check whether the instance corresponds to [aastypes.ISubmodelElementCollection]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsSubmodelElementCollection(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeSubmodelElementCollection
	return
}

// Implements ISubmodelElementCollection.
type SubmodelElementCollection struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	value []ISubmodelElement
}

func (sec *SubmodelElementCollection) Extensions(
) []IExtension {
	return sec.extensions
}

func (sec *SubmodelElementCollection) SetExtensions(
	value []IExtension,
) {
	sec.extensions = value
}

func (sec *SubmodelElementCollection) Category(
) *string {
	return sec.category
}

func (sec *SubmodelElementCollection) SetCategory(
	value *string,
) {
	sec.category = value
}

func (sec *SubmodelElementCollection) IDShort(
) *string {
	return sec.idShort
}

func (sec *SubmodelElementCollection) SetIDShort(
	value *string,
) {
	sec.idShort = value
}

func (sec *SubmodelElementCollection) DisplayName(
) []ILangStringNameType {
	return sec.displayName
}

func (sec *SubmodelElementCollection) SetDisplayName(
	value []ILangStringNameType,
) {
	sec.displayName = value
}

func (sec *SubmodelElementCollection) Description(
) []ILangStringTextType {
	return sec.description
}

func (sec *SubmodelElementCollection) SetDescription(
	value []ILangStringTextType,
) {
	sec.description = value
}

func (sec *SubmodelElementCollection) SemanticID(
) IReference {
	return sec.semanticID
}

func (sec *SubmodelElementCollection) SetSemanticID(
	value IReference,
) {
	sec.semanticID = value
}

func (sec *SubmodelElementCollection) SupplementalSemanticIDs(
) []IReference {
	return sec.supplementalSemanticIDs
}

func (sec *SubmodelElementCollection) SetSupplementalSemanticIDs(
	value []IReference,
) {
	sec.supplementalSemanticIDs = value
}

func (sec *SubmodelElementCollection) Qualifiers(
) []IQualifier {
	return sec.qualifiers
}

func (sec *SubmodelElementCollection) SetQualifiers(
	value []IQualifier,
) {
	sec.qualifiers = value
}

func (sec *SubmodelElementCollection) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return sec.embeddedDataSpecifications
}

func (sec *SubmodelElementCollection) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	sec.embeddedDataSpecifications = value
}

func (sec *SubmodelElementCollection) Value(
) []ISubmodelElement {
	return sec.value
}

func (sec *SubmodelElementCollection) SetValue(
	value []ISubmodelElement,
) {
	sec.value = value
}

func (sec *SubmodelElementCollection) ModelType(
) ModelType {
	return ModelTypeSubmodelElementCollection
}

// Apply the action on the instances referenced from sec.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on sec.
func (sec *SubmodelElementCollection) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if sec.extensions != nil {
		for _, v := range sec.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if sec.displayName != nil {
		for _, v1 := range sec.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if sec.description != nil {
		for _, v2 := range sec.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if sec.semanticID != nil {
		abort = action(
			sec.semanticID,
		)
		if abort {
			return
		}
	}

	if sec.supplementalSemanticIDs != nil {
		for _, v3 := range sec.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if sec.qualifiers != nil {
		for _, v4 := range sec.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if sec.embeddedDataSpecifications != nil {
		for _, v5 := range sec.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if sec.value != nil {
		for _, v6 := range sec.value {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from sec.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on sec.
func (sec *SubmodelElementCollection) Descend(
	action func(IClass) bool,
) (abort bool) {
	if sec.extensions != nil {
		for _, v := range sec.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sec.displayName != nil {
		for _, v1 := range sec.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sec.description != nil {
		for _, v2 := range sec.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sec.semanticID != nil {
		abort = action(
			sec.semanticID,
		)
		if abort {
			return
		}
		abort = sec.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if sec.supplementalSemanticIDs != nil {
		for _, v3 := range sec.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sec.qualifiers != nil {
		for _, v4 := range sec.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sec.embeddedDataSpecifications != nil {
		for _, v5 := range sec.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if sec.value != nil {
		for _, v6 := range sec.value {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of SubmodelElementCollection with
// the given properties.
func NewSubmodelElementCollection() *SubmodelElementCollection {
	return &SubmodelElementCollection{
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		value: nil,
	}
}

// A data element is a submodel element that is not further composed out of
// other submodel elements.
//
// A data element is a submodel element that has a value. The type of value differs
// for different subtypes of data elements.
//
// Constraint AASd-090:
// For data elements [IDataElement.Category] shall be one of the following
// values: `CONSTANT`, `PARAMETER` or `VARIABLE`.
//
// Default: `VARIABLE`
type IDataElement interface {
	ISubmodelElement

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IDataElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsDataElement(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeProperty:
		ok = true
	case ModelTypeMultiLanguageProperty:
		ok = true
	case ModelTypeRange:
		ok = true
	case ModelTypeReferenceElement:
		ok = true
	case ModelTypeBlob:
		ok = true
	case ModelTypeFile:
		ok = true
	}
	return
}

// A property is a data element that has a single value.
//
// Constraint AASd-007:
// If both, the [IProperty.Value] and the [IProperty.ValueID] are
// present then the value of [IProperty.Value] needs to be identical to
// the value of the referenced coded value in [IProperty.ValueID].
type IProperty interface {
	IDataElement

	// Data type of the value
	ValueType() DataTypeDefXSD;

	SetValueType(
		value DataTypeDefXSD,
	);

	// The value of the property instance.
	Value() *string;

	SetValue(
		value *string,
	);

	// Reference to the global unique ID of a coded value.
	//
	// NOTE: It is recommended to use a global reference.
	ValueID() IReference;

	SetValueID(
		value IReference,
	);

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IProperty]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsProperty(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeProperty
	return
}

// Implements IProperty.
type Property struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	valueType DataTypeDefXSD
	value *string
	valueID IReference
}

func (p *Property) Extensions(
) []IExtension {
	return p.extensions
}

func (p *Property) SetExtensions(
	value []IExtension,
) {
	p.extensions = value
}

func (p *Property) Category(
) *string {
	return p.category
}

func (p *Property) SetCategory(
	value *string,
) {
	p.category = value
}

func (p *Property) IDShort(
) *string {
	return p.idShort
}

func (p *Property) SetIDShort(
	value *string,
) {
	p.idShort = value
}

func (p *Property) DisplayName(
) []ILangStringNameType {
	return p.displayName
}

func (p *Property) SetDisplayName(
	value []ILangStringNameType,
) {
	p.displayName = value
}

func (p *Property) Description(
) []ILangStringTextType {
	return p.description
}

func (p *Property) SetDescription(
	value []ILangStringTextType,
) {
	p.description = value
}

func (p *Property) SemanticID(
) IReference {
	return p.semanticID
}

func (p *Property) SetSemanticID(
	value IReference,
) {
	p.semanticID = value
}

func (p *Property) SupplementalSemanticIDs(
) []IReference {
	return p.supplementalSemanticIDs
}

func (p *Property) SetSupplementalSemanticIDs(
	value []IReference,
) {
	p.supplementalSemanticIDs = value
}

func (p *Property) Qualifiers(
) []IQualifier {
	return p.qualifiers
}

func (p *Property) SetQualifiers(
	value []IQualifier,
) {
	p.qualifiers = value
}

func (p *Property) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return p.embeddedDataSpecifications
}

func (p *Property) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	p.embeddedDataSpecifications = value
}

func (p *Property) ValueType(
) DataTypeDefXSD {
	return p.valueType
}

func (p *Property) SetValueType(
	value DataTypeDefXSD,
) {
	p.valueType = value
}

func (p *Property) Value(
) *string {
	return p.value
}

func (p *Property) SetValue(
	value *string,
) {
	p.value = value
}

func (p *Property) ValueID(
) IReference {
	return p.valueID
}

func (p *Property) SetValueID(
	value IReference,
) {
	p.valueID = value
}

func (p *Property) ModelType(
) ModelType {
	return ModelTypeProperty
}

// Return [IReferable.Category] or the default value
// if it has not been set.
func (p *Property) CategoryOrDefault() string {
	v := p.Category()
	if v == nil {
		return "VARIABLE"
	}

	return *v
}

// Apply the action on the instances referenced from p.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on p.
func (p *Property) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if p.extensions != nil {
		for _, v := range p.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if p.displayName != nil {
		for _, v1 := range p.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if p.description != nil {
		for _, v2 := range p.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if p.semanticID != nil {
		abort = action(
			p.semanticID,
		)
		if abort {
			return
		}
	}

	if p.supplementalSemanticIDs != nil {
		for _, v3 := range p.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if p.qualifiers != nil {
		for _, v4 := range p.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if p.embeddedDataSpecifications != nil {
		for _, v5 := range p.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if p.valueID != nil {
		abort = action(
			p.valueID,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from p.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on p.
func (p *Property) Descend(
	action func(IClass) bool,
) (abort bool) {
	if p.extensions != nil {
		for _, v := range p.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if p.displayName != nil {
		for _, v1 := range p.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if p.description != nil {
		for _, v2 := range p.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if p.semanticID != nil {
		abort = action(
			p.semanticID,
		)
		if abort {
			return
		}
		abort = p.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if p.supplementalSemanticIDs != nil {
		for _, v3 := range p.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if p.qualifiers != nil {
		for _, v4 := range p.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if p.embeddedDataSpecifications != nil {
		for _, v5 := range p.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if p.valueID != nil {
		abort = action(
			p.valueID,
		)
		if abort {
			return
		}
		abort = p.valueID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of Property with
// the given properties.
func NewProperty(
	valueType DataTypeDefXSD,
) *Property {
	return &Property{
		valueType: valueType,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		value: nil,
		valueID: nil,
	}
}

// A property is a data element that has a multi-language value.
//
// Constraint AASd-012:
// If both the [IMultiLanguageProperty.Value] and the [IMultiLanguageProperty.ValueID] are present then for each
// string in a specific language the meaning must be the same as specified in
// [IMultiLanguageProperty.ValueID].
type IMultiLanguageProperty interface {
	IDataElement

	// The value of the property instance.
	Value() []ILangStringTextType;

	SetValue(
		value []ILangStringTextType,
	);

	// Reference to the global unique ID of a coded value.
	//
	// NOTE: It is recommended to use a global reference.
	ValueID() IReference;

	SetValueID(
		value IReference,
	);

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IMultiLanguageProperty]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsMultiLanguageProperty(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeMultiLanguageProperty
	return
}

// Implements IMultiLanguageProperty.
type MultiLanguageProperty struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	value []ILangStringTextType
	valueID IReference
}

func (mlp *MultiLanguageProperty) Extensions(
) []IExtension {
	return mlp.extensions
}

func (mlp *MultiLanguageProperty) SetExtensions(
	value []IExtension,
) {
	mlp.extensions = value
}

func (mlp *MultiLanguageProperty) Category(
) *string {
	return mlp.category
}

func (mlp *MultiLanguageProperty) SetCategory(
	value *string,
) {
	mlp.category = value
}

func (mlp *MultiLanguageProperty) IDShort(
) *string {
	return mlp.idShort
}

func (mlp *MultiLanguageProperty) SetIDShort(
	value *string,
) {
	mlp.idShort = value
}

func (mlp *MultiLanguageProperty) DisplayName(
) []ILangStringNameType {
	return mlp.displayName
}

func (mlp *MultiLanguageProperty) SetDisplayName(
	value []ILangStringNameType,
) {
	mlp.displayName = value
}

func (mlp *MultiLanguageProperty) Description(
) []ILangStringTextType {
	return mlp.description
}

func (mlp *MultiLanguageProperty) SetDescription(
	value []ILangStringTextType,
) {
	mlp.description = value
}

func (mlp *MultiLanguageProperty) SemanticID(
) IReference {
	return mlp.semanticID
}

func (mlp *MultiLanguageProperty) SetSemanticID(
	value IReference,
) {
	mlp.semanticID = value
}

func (mlp *MultiLanguageProperty) SupplementalSemanticIDs(
) []IReference {
	return mlp.supplementalSemanticIDs
}

func (mlp *MultiLanguageProperty) SetSupplementalSemanticIDs(
	value []IReference,
) {
	mlp.supplementalSemanticIDs = value
}

func (mlp *MultiLanguageProperty) Qualifiers(
) []IQualifier {
	return mlp.qualifiers
}

func (mlp *MultiLanguageProperty) SetQualifiers(
	value []IQualifier,
) {
	mlp.qualifiers = value
}

func (mlp *MultiLanguageProperty) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return mlp.embeddedDataSpecifications
}

func (mlp *MultiLanguageProperty) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	mlp.embeddedDataSpecifications = value
}

func (mlp *MultiLanguageProperty) Value(
) []ILangStringTextType {
	return mlp.value
}

func (mlp *MultiLanguageProperty) SetValue(
	value []ILangStringTextType,
) {
	mlp.value = value
}

func (mlp *MultiLanguageProperty) ValueID(
) IReference {
	return mlp.valueID
}

func (mlp *MultiLanguageProperty) SetValueID(
	value IReference,
) {
	mlp.valueID = value
}

func (mlp *MultiLanguageProperty) ModelType(
) ModelType {
	return ModelTypeMultiLanguageProperty
}

// Return [IReferable.Category] or the default value
// if it has not been set.
func (mlp *MultiLanguageProperty) CategoryOrDefault() string {
	v := mlp.Category()
	if v == nil {
		return "VARIABLE"
	}

	return *v
}

// Apply the action on the instances referenced from mlp.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on mlp.
func (mlp *MultiLanguageProperty) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if mlp.extensions != nil {
		for _, v := range mlp.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if mlp.displayName != nil {
		for _, v1 := range mlp.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if mlp.description != nil {
		for _, v2 := range mlp.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if mlp.semanticID != nil {
		abort = action(
			mlp.semanticID,
		)
		if abort {
			return
		}
	}

	if mlp.supplementalSemanticIDs != nil {
		for _, v3 := range mlp.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if mlp.qualifiers != nil {
		for _, v4 := range mlp.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if mlp.embeddedDataSpecifications != nil {
		for _, v5 := range mlp.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if mlp.value != nil {
		for _, v6 := range mlp.value {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	if mlp.valueID != nil {
		abort = action(
			mlp.valueID,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from mlp.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on mlp.
func (mlp *MultiLanguageProperty) Descend(
	action func(IClass) bool,
) (abort bool) {
	if mlp.extensions != nil {
		for _, v := range mlp.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.displayName != nil {
		for _, v1 := range mlp.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.description != nil {
		for _, v2 := range mlp.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.semanticID != nil {
		abort = action(
			mlp.semanticID,
		)
		if abort {
			return
		}
		abort = mlp.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if mlp.supplementalSemanticIDs != nil {
		for _, v3 := range mlp.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.qualifiers != nil {
		for _, v4 := range mlp.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.embeddedDataSpecifications != nil {
		for _, v5 := range mlp.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.value != nil {
		for _, v6 := range mlp.value {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if mlp.valueID != nil {
		abort = action(
			mlp.valueID,
		)
		if abort {
			return
		}
		abort = mlp.valueID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of MultiLanguageProperty with
// the given properties.
func NewMultiLanguageProperty() *MultiLanguageProperty {
	return &MultiLanguageProperty{
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		value: nil,
		valueID: nil,
	}
}

// A range data element is a data element that defines a range with min and max.
type IRange interface {
	IDataElement

	// Data type of the min und max
	ValueType() DataTypeDefXSD;

	SetValueType(
		value DataTypeDefXSD,
	);

	// The minimum value of the range.
	//
	// If the min value is missing, then the value is assumed to be negative infinite.
	Min() *string;

	SetMin(
		value *string,
	);

	// The maximum value of the range.
	//
	// If the max value is missing, then the value is assumed to be positive infinite.
	Max() *string;

	SetMax(
		value *string,
	);

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IRange]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsRange(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeRange
	return
}

// Implements IRange.
type Range struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	valueType DataTypeDefXSD
	min *string
	max *string
}

func (r *Range) Extensions(
) []IExtension {
	return r.extensions
}

func (r *Range) SetExtensions(
	value []IExtension,
) {
	r.extensions = value
}

func (r *Range) Category(
) *string {
	return r.category
}

func (r *Range) SetCategory(
	value *string,
) {
	r.category = value
}

func (r *Range) IDShort(
) *string {
	return r.idShort
}

func (r *Range) SetIDShort(
	value *string,
) {
	r.idShort = value
}

func (r *Range) DisplayName(
) []ILangStringNameType {
	return r.displayName
}

func (r *Range) SetDisplayName(
	value []ILangStringNameType,
) {
	r.displayName = value
}

func (r *Range) Description(
) []ILangStringTextType {
	return r.description
}

func (r *Range) SetDescription(
	value []ILangStringTextType,
) {
	r.description = value
}

func (r *Range) SemanticID(
) IReference {
	return r.semanticID
}

func (r *Range) SetSemanticID(
	value IReference,
) {
	r.semanticID = value
}

func (r *Range) SupplementalSemanticIDs(
) []IReference {
	return r.supplementalSemanticIDs
}

func (r *Range) SetSupplementalSemanticIDs(
	value []IReference,
) {
	r.supplementalSemanticIDs = value
}

func (r *Range) Qualifiers(
) []IQualifier {
	return r.qualifiers
}

func (r *Range) SetQualifiers(
	value []IQualifier,
) {
	r.qualifiers = value
}

func (r *Range) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return r.embeddedDataSpecifications
}

func (r *Range) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	r.embeddedDataSpecifications = value
}

func (r *Range) ValueType(
) DataTypeDefXSD {
	return r.valueType
}

func (r *Range) SetValueType(
	value DataTypeDefXSD,
) {
	r.valueType = value
}

func (r *Range) Min(
) *string {
	return r.min
}

func (r *Range) SetMin(
	value *string,
) {
	r.min = value
}

func (r *Range) Max(
) *string {
	return r.max
}

func (r *Range) SetMax(
	value *string,
) {
	r.max = value
}

func (r *Range) ModelType(
) ModelType {
	return ModelTypeRange
}

// Return [IReferable.Category] or the default value
// if it has not been set.
func (r *Range) CategoryOrDefault() string {
	v := r.Category()
	if v == nil {
		return "VARIABLE"
	}

	return *v
}

// Apply the action on the instances referenced from r.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on r.
func (r *Range) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if r.extensions != nil {
		for _, v := range r.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if r.displayName != nil {
		for _, v1 := range r.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if r.description != nil {
		for _, v2 := range r.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if r.semanticID != nil {
		abort = action(
			r.semanticID,
		)
		if abort {
			return
		}
	}

	if r.supplementalSemanticIDs != nil {
		for _, v3 := range r.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if r.qualifiers != nil {
		for _, v4 := range r.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if r.embeddedDataSpecifications != nil {
		for _, v5 := range r.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from r.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on r.
func (r *Range) Descend(
	action func(IClass) bool,
) (abort bool) {
	if r.extensions != nil {
		for _, v := range r.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if r.displayName != nil {
		for _, v1 := range r.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if r.description != nil {
		for _, v2 := range r.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if r.semanticID != nil {
		abort = action(
			r.semanticID,
		)
		if abort {
			return
		}
		abort = r.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if r.supplementalSemanticIDs != nil {
		for _, v3 := range r.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if r.qualifiers != nil {
		for _, v4 := range r.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if r.embeddedDataSpecifications != nil {
		for _, v5 := range r.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Range with
// the given properties.
func NewRange(
	valueType DataTypeDefXSD,
) *Range {
	return &Range{
		valueType: valueType,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		min: nil,
		max: nil,
	}
}

// A reference element is a data element that defines a logical reference to another
// element within the same or another AAS or a reference to an external object or
// entity.
type IReferenceElement interface {
	IDataElement

	// Global reference to an external object or entity or a logical reference to
	// another element within the same or another AAS (i.e. a model reference to
	// a Referable).
	Value() IReference;

	SetValue(
		value IReference,
	);

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IReferenceElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsReferenceElement(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeReferenceElement
	return
}

// Implements IReferenceElement.
type ReferenceElement struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	value IReference
}

func (re *ReferenceElement) Extensions(
) []IExtension {
	return re.extensions
}

func (re *ReferenceElement) SetExtensions(
	value []IExtension,
) {
	re.extensions = value
}

func (re *ReferenceElement) Category(
) *string {
	return re.category
}

func (re *ReferenceElement) SetCategory(
	value *string,
) {
	re.category = value
}

func (re *ReferenceElement) IDShort(
) *string {
	return re.idShort
}

func (re *ReferenceElement) SetIDShort(
	value *string,
) {
	re.idShort = value
}

func (re *ReferenceElement) DisplayName(
) []ILangStringNameType {
	return re.displayName
}

func (re *ReferenceElement) SetDisplayName(
	value []ILangStringNameType,
) {
	re.displayName = value
}

func (re *ReferenceElement) Description(
) []ILangStringTextType {
	return re.description
}

func (re *ReferenceElement) SetDescription(
	value []ILangStringTextType,
) {
	re.description = value
}

func (re *ReferenceElement) SemanticID(
) IReference {
	return re.semanticID
}

func (re *ReferenceElement) SetSemanticID(
	value IReference,
) {
	re.semanticID = value
}

func (re *ReferenceElement) SupplementalSemanticIDs(
) []IReference {
	return re.supplementalSemanticIDs
}

func (re *ReferenceElement) SetSupplementalSemanticIDs(
	value []IReference,
) {
	re.supplementalSemanticIDs = value
}

func (re *ReferenceElement) Qualifiers(
) []IQualifier {
	return re.qualifiers
}

func (re *ReferenceElement) SetQualifiers(
	value []IQualifier,
) {
	re.qualifiers = value
}

func (re *ReferenceElement) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return re.embeddedDataSpecifications
}

func (re *ReferenceElement) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	re.embeddedDataSpecifications = value
}

func (re *ReferenceElement) Value(
) IReference {
	return re.value
}

func (re *ReferenceElement) SetValue(
	value IReference,
) {
	re.value = value
}

func (re *ReferenceElement) ModelType(
) ModelType {
	return ModelTypeReferenceElement
}

// Return [IReferable.Category] or the default value
// if it has not been set.
func (re *ReferenceElement) CategoryOrDefault() string {
	v := re.Category()
	if v == nil {
		return "VARIABLE"
	}

	return *v
}

// Apply the action on the instances referenced from re.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on re.
func (re *ReferenceElement) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if re.extensions != nil {
		for _, v := range re.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if re.displayName != nil {
		for _, v1 := range re.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if re.description != nil {
		for _, v2 := range re.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if re.semanticID != nil {
		abort = action(
			re.semanticID,
		)
		if abort {
			return
		}
	}

	if re.supplementalSemanticIDs != nil {
		for _, v3 := range re.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if re.qualifiers != nil {
		for _, v4 := range re.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if re.embeddedDataSpecifications != nil {
		for _, v5 := range re.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if re.value != nil {
		abort = action(
			re.value,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from re.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on re.
func (re *ReferenceElement) Descend(
	action func(IClass) bool,
) (abort bool) {
	if re.extensions != nil {
		for _, v := range re.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.displayName != nil {
		for _, v1 := range re.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.description != nil {
		for _, v2 := range re.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.semanticID != nil {
		abort = action(
			re.semanticID,
		)
		if abort {
			return
		}
		abort = re.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if re.supplementalSemanticIDs != nil {
		for _, v3 := range re.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.qualifiers != nil {
		for _, v4 := range re.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.embeddedDataSpecifications != nil {
		for _, v5 := range re.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if re.value != nil {
		abort = action(
			re.value,
		)
		if abort {
			return
		}
		abort = re.value.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of ReferenceElement with
// the given properties.
func NewReferenceElement() *ReferenceElement {
	return &ReferenceElement{
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		value: nil,
	}
}

// A [IBlob] is a data element that represents a file that is contained with its
// source code in the value attribute.
type IBlob interface {
	IDataElement

	// The value of the [IBlob] instance of a blob data element.
	//
	// NOTE: In contrast to the file property the file content is stored directly as value
	// in the [IBlob] data element.
	Value() []byte;

	SetValue(
		value []byte,
	);

	// Content type of the content of the [IBlob].
	//
	// The content type (MIME type) states which file extensions the file can have.
	//
	// Valid values are content types like e.g. `application/json`, `application/xls`,
	// `image/jpg`.
	//
	// The allowed values are defined as in RFC2046.
	ContentType() string;

	SetContentType(
		value string,
	);

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IBlob]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsBlob(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeBlob
	return
}

// Implements IBlob.
type Blob struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	value []byte
	contentType string
}

func (b *Blob) Extensions(
) []IExtension {
	return b.extensions
}

func (b *Blob) SetExtensions(
	value []IExtension,
) {
	b.extensions = value
}

func (b *Blob) Category(
) *string {
	return b.category
}

func (b *Blob) SetCategory(
	value *string,
) {
	b.category = value
}

func (b *Blob) IDShort(
) *string {
	return b.idShort
}

func (b *Blob) SetIDShort(
	value *string,
) {
	b.idShort = value
}

func (b *Blob) DisplayName(
) []ILangStringNameType {
	return b.displayName
}

func (b *Blob) SetDisplayName(
	value []ILangStringNameType,
) {
	b.displayName = value
}

func (b *Blob) Description(
) []ILangStringTextType {
	return b.description
}

func (b *Blob) SetDescription(
	value []ILangStringTextType,
) {
	b.description = value
}

func (b *Blob) SemanticID(
) IReference {
	return b.semanticID
}

func (b *Blob) SetSemanticID(
	value IReference,
) {
	b.semanticID = value
}

func (b *Blob) SupplementalSemanticIDs(
) []IReference {
	return b.supplementalSemanticIDs
}

func (b *Blob) SetSupplementalSemanticIDs(
	value []IReference,
) {
	b.supplementalSemanticIDs = value
}

func (b *Blob) Qualifiers(
) []IQualifier {
	return b.qualifiers
}

func (b *Blob) SetQualifiers(
	value []IQualifier,
) {
	b.qualifiers = value
}

func (b *Blob) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return b.embeddedDataSpecifications
}

func (b *Blob) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	b.embeddedDataSpecifications = value
}

func (b *Blob) Value(
) []byte {
	return b.value
}

func (b *Blob) SetValue(
	value []byte,
) {
	b.value = value
}

func (b *Blob) ContentType(
) string {
	return b.contentType
}

func (b *Blob) SetContentType(
	value string,
) {
	b.contentType = value
}

func (b *Blob) ModelType(
) ModelType {
	return ModelTypeBlob
}

// Return [IReferable.Category] or the default value
// if it has not been set.
func (b *Blob) CategoryOrDefault() string {
	v := b.Category()
	if v == nil {
		return "VARIABLE"
	}

	return *v
}

// Apply the action on the instances referenced from b.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on b.
func (b *Blob) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if b.extensions != nil {
		for _, v := range b.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if b.displayName != nil {
		for _, v1 := range b.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if b.description != nil {
		for _, v2 := range b.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if b.semanticID != nil {
		abort = action(
			b.semanticID,
		)
		if abort {
			return
		}
	}

	if b.supplementalSemanticIDs != nil {
		for _, v3 := range b.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if b.qualifiers != nil {
		for _, v4 := range b.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if b.embeddedDataSpecifications != nil {
		for _, v5 := range b.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from b.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on b.
func (b *Blob) Descend(
	action func(IClass) bool,
) (abort bool) {
	if b.extensions != nil {
		for _, v := range b.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if b.displayName != nil {
		for _, v1 := range b.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if b.description != nil {
		for _, v2 := range b.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if b.semanticID != nil {
		abort = action(
			b.semanticID,
		)
		if abort {
			return
		}
		abort = b.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if b.supplementalSemanticIDs != nil {
		for _, v3 := range b.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if b.qualifiers != nil {
		for _, v4 := range b.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if b.embeddedDataSpecifications != nil {
		for _, v5 := range b.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Blob with
// the given properties.
func NewBlob(
	contentType string,
) *Blob {
	return &Blob{
		contentType: contentType,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		value: nil,
	}
}

// A File is a data element that represents an address to a file (a locator).
//
// The value is an URI that can represent an absolute or relative path.
type IFile interface {
	IDataElement

	// Path and name of the referenced file (with file extension).
	//
	// The path can be absolute or relative.
	Value() *string;

	SetValue(
		value *string,
	);

	// Content type of the content of the file.
	//
	// The content type states which file extensions the file can have.
	ContentType() string;

	SetContentType(
		value string,
	);

	CategoryOrDefault() string;
}

// Check whether the instance corresponds to [aastypes.IFile]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsFile(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeFile
	return
}

// Implements IFile.
type File struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	value *string
	contentType string
}

func (f *File) Extensions(
) []IExtension {
	return f.extensions
}

func (f *File) SetExtensions(
	value []IExtension,
) {
	f.extensions = value
}

func (f *File) Category(
) *string {
	return f.category
}

func (f *File) SetCategory(
	value *string,
) {
	f.category = value
}

func (f *File) IDShort(
) *string {
	return f.idShort
}

func (f *File) SetIDShort(
	value *string,
) {
	f.idShort = value
}

func (f *File) DisplayName(
) []ILangStringNameType {
	return f.displayName
}

func (f *File) SetDisplayName(
	value []ILangStringNameType,
) {
	f.displayName = value
}

func (f *File) Description(
) []ILangStringTextType {
	return f.description
}

func (f *File) SetDescription(
	value []ILangStringTextType,
) {
	f.description = value
}

func (f *File) SemanticID(
) IReference {
	return f.semanticID
}

func (f *File) SetSemanticID(
	value IReference,
) {
	f.semanticID = value
}

func (f *File) SupplementalSemanticIDs(
) []IReference {
	return f.supplementalSemanticIDs
}

func (f *File) SetSupplementalSemanticIDs(
	value []IReference,
) {
	f.supplementalSemanticIDs = value
}

func (f *File) Qualifiers(
) []IQualifier {
	return f.qualifiers
}

func (f *File) SetQualifiers(
	value []IQualifier,
) {
	f.qualifiers = value
}

func (f *File) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return f.embeddedDataSpecifications
}

func (f *File) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	f.embeddedDataSpecifications = value
}

func (f *File) Value(
) *string {
	return f.value
}

func (f *File) SetValue(
	value *string,
) {
	f.value = value
}

func (f *File) ContentType(
) string {
	return f.contentType
}

func (f *File) SetContentType(
	value string,
) {
	f.contentType = value
}

func (f *File) ModelType(
) ModelType {
	return ModelTypeFile
}

// Return [IReferable.Category] or the default value
// if it has not been set.
func (f *File) CategoryOrDefault() string {
	v := f.Category()
	if v == nil {
		return "VARIABLE"
	}

	return *v
}

// Apply the action on the instances referenced from f.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on f.
func (f *File) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if f.extensions != nil {
		for _, v := range f.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if f.displayName != nil {
		for _, v1 := range f.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if f.description != nil {
		for _, v2 := range f.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if f.semanticID != nil {
		abort = action(
			f.semanticID,
		)
		if abort {
			return
		}
	}

	if f.supplementalSemanticIDs != nil {
		for _, v3 := range f.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if f.qualifiers != nil {
		for _, v4 := range f.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if f.embeddedDataSpecifications != nil {
		for _, v5 := range f.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from f.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on f.
func (f *File) Descend(
	action func(IClass) bool,
) (abort bool) {
	if f.extensions != nil {
		for _, v := range f.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if f.displayName != nil {
		for _, v1 := range f.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if f.description != nil {
		for _, v2 := range f.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if f.semanticID != nil {
		abort = action(
			f.semanticID,
		)
		if abort {
			return
		}
		abort = f.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if f.supplementalSemanticIDs != nil {
		for _, v3 := range f.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if f.qualifiers != nil {
		for _, v4 := range f.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if f.embeddedDataSpecifications != nil {
		for _, v5 := range f.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of File with
// the given properties.
func NewFile(
	contentType string,
) *File {
	return &File{
		contentType: contentType,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		value: nil,
	}
}

// An annotated relationship element is a relationship element that can be annotated
// with additional data elements.
type IAnnotatedRelationshipElement interface {
	IRelationshipElement

	// A data element that represents an annotation that holds for the relationship
	// between the two elements
	Annotations() []IDataElement;

	SetAnnotations(
		value []IDataElement,
	);
}

// Check whether the instance corresponds to [aastypes.IAnnotatedRelationshipElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsAnnotatedRelationshipElement(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeAnnotatedRelationshipElement
	return
}

// Implements IAnnotatedRelationshipElement.
type AnnotatedRelationshipElement struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	first IReference
	second IReference
	annotations []IDataElement
}

func (are *AnnotatedRelationshipElement) Extensions(
) []IExtension {
	return are.extensions
}

func (are *AnnotatedRelationshipElement) SetExtensions(
	value []IExtension,
) {
	are.extensions = value
}

func (are *AnnotatedRelationshipElement) Category(
) *string {
	return are.category
}

func (are *AnnotatedRelationshipElement) SetCategory(
	value *string,
) {
	are.category = value
}

func (are *AnnotatedRelationshipElement) IDShort(
) *string {
	return are.idShort
}

func (are *AnnotatedRelationshipElement) SetIDShort(
	value *string,
) {
	are.idShort = value
}

func (are *AnnotatedRelationshipElement) DisplayName(
) []ILangStringNameType {
	return are.displayName
}

func (are *AnnotatedRelationshipElement) SetDisplayName(
	value []ILangStringNameType,
) {
	are.displayName = value
}

func (are *AnnotatedRelationshipElement) Description(
) []ILangStringTextType {
	return are.description
}

func (are *AnnotatedRelationshipElement) SetDescription(
	value []ILangStringTextType,
) {
	are.description = value
}

func (are *AnnotatedRelationshipElement) SemanticID(
) IReference {
	return are.semanticID
}

func (are *AnnotatedRelationshipElement) SetSemanticID(
	value IReference,
) {
	are.semanticID = value
}

func (are *AnnotatedRelationshipElement) SupplementalSemanticIDs(
) []IReference {
	return are.supplementalSemanticIDs
}

func (are *AnnotatedRelationshipElement) SetSupplementalSemanticIDs(
	value []IReference,
) {
	are.supplementalSemanticIDs = value
}

func (are *AnnotatedRelationshipElement) Qualifiers(
) []IQualifier {
	return are.qualifiers
}

func (are *AnnotatedRelationshipElement) SetQualifiers(
	value []IQualifier,
) {
	are.qualifiers = value
}

func (are *AnnotatedRelationshipElement) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return are.embeddedDataSpecifications
}

func (are *AnnotatedRelationshipElement) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	are.embeddedDataSpecifications = value
}

func (are *AnnotatedRelationshipElement) First(
) IReference {
	return are.first
}

func (are *AnnotatedRelationshipElement) SetFirst(
	value IReference,
) {
	are.first = value
}

func (are *AnnotatedRelationshipElement) Second(
) IReference {
	return are.second
}

func (are *AnnotatedRelationshipElement) SetSecond(
	value IReference,
) {
	are.second = value
}

func (are *AnnotatedRelationshipElement) Annotations(
) []IDataElement {
	return are.annotations
}

func (are *AnnotatedRelationshipElement) SetAnnotations(
	value []IDataElement,
) {
	are.annotations = value
}

func (are *AnnotatedRelationshipElement) ModelType(
) ModelType {
	return ModelTypeAnnotatedRelationshipElement
}

// Apply the action on the instances referenced from are.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on are.
func (are *AnnotatedRelationshipElement) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if are.extensions != nil {
		for _, v := range are.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if are.displayName != nil {
		for _, v1 := range are.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if are.description != nil {
		for _, v2 := range are.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if are.semanticID != nil {
		abort = action(
			are.semanticID,
		)
		if abort {
			return
		}
	}

	if are.supplementalSemanticIDs != nil {
		for _, v3 := range are.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if are.qualifiers != nil {
		for _, v4 := range are.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if are.embeddedDataSpecifications != nil {
		for _, v5 := range are.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	abort = action(
		are.first,
	)
	if abort {
		return
	}

	abort = action(
		are.second,
	)
	if abort {
		return
	}

	if are.annotations != nil {
		for _, v6 := range are.annotations {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from are.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on are.
func (are *AnnotatedRelationshipElement) Descend(
	action func(IClass) bool,
) (abort bool) {
	if are.extensions != nil {
		for _, v := range are.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if are.displayName != nil {
		for _, v1 := range are.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if are.description != nil {
		for _, v2 := range are.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if are.semanticID != nil {
		abort = action(
			are.semanticID,
		)
		if abort {
			return
		}
		abort = are.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if are.supplementalSemanticIDs != nil {
		for _, v3 := range are.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if are.qualifiers != nil {
		for _, v4 := range are.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if are.embeddedDataSpecifications != nil {
		for _, v5 := range are.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	abort = action(
		are.first,
	)
	if abort {
		return
	}
	abort = are.first.Descend(
		action,
	)
	if abort {
		return
	}

	abort = action(
		are.second,
	)
	if abort {
		return
	}
	abort = are.second.Descend(
		action,
	)
	if abort {
		return
	}

	if are.annotations != nil {
		for _, v6 := range are.annotations {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of AnnotatedRelationshipElement with
// the given properties.
func NewAnnotatedRelationshipElement(
	first IReference,
	second IReference,
) *AnnotatedRelationshipElement {
	return &AnnotatedRelationshipElement{
		first: first,
		second: second,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		annotations: nil,
	}
}

// An entity is a submodel element that is used to model entities.
//
// Constraint AASd-014:
// Either the attribute [IEntity.GlobalAssetID] or [IEntity.SpecificAssetIDs]
// of an [IEntity] must be set if [IEntity.EntityType] is set to
// [EntityTypeSelfManagedEntity]. They are not existing otherwise.
type IEntity interface {
	ISubmodelElement

	// Describes statements applicable to the entity by a set of submodel elements,
	// typically with a qualified value.
	Statements() []ISubmodelElement;

	SetStatements(
		value []ISubmodelElement,
	);

	// Describes whether the entity is a co-managed entity or a self-managed entity.
	EntityType() EntityType;

	SetEntityType(
		value EntityType,
	);

	// Global identifier of the asset the entity is representing.
	//
	// NOTE: This is a global reference.
	GlobalAssetID() *string;

	SetGlobalAssetID(
		value *string,
	);

	// Reference to a specific asset ID representing a supplementary identifier
	// of the asset represented by the Asset Administration Shell.
	SpecificAssetIDs() []ISpecificAssetID;

	SetSpecificAssetIDs(
		value []ISpecificAssetID,
	);
}

// Check whether the instance corresponds to [aastypes.IEntity]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsEntity(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeEntity
	return
}

// Implements IEntity.
type Entity struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	statements []ISubmodelElement
	entityType EntityType
	globalAssetID *string
	specificAssetIDs []ISpecificAssetID
}

func (e *Entity) Extensions(
) []IExtension {
	return e.extensions
}

func (e *Entity) SetExtensions(
	value []IExtension,
) {
	e.extensions = value
}

func (e *Entity) Category(
) *string {
	return e.category
}

func (e *Entity) SetCategory(
	value *string,
) {
	e.category = value
}

func (e *Entity) IDShort(
) *string {
	return e.idShort
}

func (e *Entity) SetIDShort(
	value *string,
) {
	e.idShort = value
}

func (e *Entity) DisplayName(
) []ILangStringNameType {
	return e.displayName
}

func (e *Entity) SetDisplayName(
	value []ILangStringNameType,
) {
	e.displayName = value
}

func (e *Entity) Description(
) []ILangStringTextType {
	return e.description
}

func (e *Entity) SetDescription(
	value []ILangStringTextType,
) {
	e.description = value
}

func (e *Entity) SemanticID(
) IReference {
	return e.semanticID
}

func (e *Entity) SetSemanticID(
	value IReference,
) {
	e.semanticID = value
}

func (e *Entity) SupplementalSemanticIDs(
) []IReference {
	return e.supplementalSemanticIDs
}

func (e *Entity) SetSupplementalSemanticIDs(
	value []IReference,
) {
	e.supplementalSemanticIDs = value
}

func (e *Entity) Qualifiers(
) []IQualifier {
	return e.qualifiers
}

func (e *Entity) SetQualifiers(
	value []IQualifier,
) {
	e.qualifiers = value
}

func (e *Entity) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return e.embeddedDataSpecifications
}

func (e *Entity) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	e.embeddedDataSpecifications = value
}

func (e *Entity) Statements(
) []ISubmodelElement {
	return e.statements
}

func (e *Entity) SetStatements(
	value []ISubmodelElement,
) {
	e.statements = value
}

func (e *Entity) EntityType(
) EntityType {
	return e.entityType
}

func (e *Entity) SetEntityType(
	value EntityType,
) {
	e.entityType = value
}

func (e *Entity) GlobalAssetID(
) *string {
	return e.globalAssetID
}

func (e *Entity) SetGlobalAssetID(
	value *string,
) {
	e.globalAssetID = value
}

func (e *Entity) SpecificAssetIDs(
) []ISpecificAssetID {
	return e.specificAssetIDs
}

func (e *Entity) SetSpecificAssetIDs(
	value []ISpecificAssetID,
) {
	e.specificAssetIDs = value
}

func (e *Entity) ModelType(
) ModelType {
	return ModelTypeEntity
}

// Apply the action on the instances referenced from e.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on e.
func (e *Entity) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if e.extensions != nil {
		for _, v := range e.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if e.displayName != nil {
		for _, v1 := range e.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if e.description != nil {
		for _, v2 := range e.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if e.semanticID != nil {
		abort = action(
			e.semanticID,
		)
		if abort {
			return
		}
	}

	if e.supplementalSemanticIDs != nil {
		for _, v3 := range e.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if e.qualifiers != nil {
		for _, v4 := range e.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if e.embeddedDataSpecifications != nil {
		for _, v5 := range e.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if e.statements != nil {
		for _, v6 := range e.statements {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	if e.specificAssetIDs != nil {
		for _, v7 := range e.specificAssetIDs {
			abort = action(v7);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from e.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on e.
func (e *Entity) Descend(
	action func(IClass) bool,
) (abort bool) {
	if e.extensions != nil {
		for _, v := range e.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.displayName != nil {
		for _, v1 := range e.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.description != nil {
		for _, v2 := range e.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.semanticID != nil {
		abort = action(
			e.semanticID,
		)
		if abort {
			return
		}
		abort = e.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if e.supplementalSemanticIDs != nil {
		for _, v3 := range e.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.qualifiers != nil {
		for _, v4 := range e.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.embeddedDataSpecifications != nil {
		for _, v5 := range e.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.statements != nil {
		for _, v6 := range e.statements {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.specificAssetIDs != nil {
		for _, v7 := range e.specificAssetIDs {
			abort = action(v7);
			if abort {
				return
			}

			abort = v7.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Entity with
// the given properties.
func NewEntity(
	entityType EntityType,
) *Entity {
	return &Entity{
		entityType: entityType,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		statements: nil,
		globalAssetID: nil,
		specificAssetIDs: nil,
	}
}

// Enumeration for denoting whether an entity is a self-managed entity or a co-managed
// entity.
type EntityType int;const (
	// For co-managed entities there is no separate AAS. Co-managed entities need to be
	// part of a self-managed entity.
	EntityTypeCoManagedEntity EntityType = iota
	// Self-Managed Entities have their own AAS but can be part of the bill of material of
	// a composite self-managed entity.
	//
	// The asset of an I4.0 Component is a self-managed entity per definition.
	EntityTypeSelfManagedEntity
)

// List the literals of [EntityType].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfEntityType = [...]EntityType {
	EntityTypeCoManagedEntity,
	EntityTypeSelfManagedEntity,
}

// Direction
//
// NOTE: This element is experimental and therefore may be subject to change or may be
// removed completely in future versions of the meta-model.
type Direction int;const (
	// Input direction.
	DirectionInput Direction = iota
	// Output direction
	DirectionOutput
)

// List the literals of [Direction].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfDirection = [...]Direction {
	DirectionInput,
	DirectionOutput,
}

// State of an event
//
// NOTE: This element is experimental and therefore may be subject to change or may be
// removed completely in future versions of the meta-model.
type StateOfEvent int;const (
	// Event is on
	StateOfEventOn StateOfEvent = iota
	// Event is off.
	StateOfEventOff
)

// List the literals of [StateOfEvent].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfStateOfEvent = [...]StateOfEvent {
	StateOfEventOn,
	StateOfEventOff,
}

// Defines the necessary information of an event instance sent out or received.
//
// NOTE: This element is experimental and therefore may be subject to change or may be
// removed completely in future versions of the meta-model.
type IEventPayload interface {
	IClass

	// Reference to the source event element, including identification of
	// [IAssetAdministrationShell], [ISubmodel],
	// [ISubmodelElement]'s.
	Source() IReference;

	SetSource(
		value IReference,
	);

	// [IHasSemantics.SemanticID] of the source event element, if available
	//
	// NOTE: It is recommended to use a global reference.
	SourceSemanticID() IReference;

	SetSourceSemanticID(
		value IReference,
	);

	// Reference to the referable, which defines the scope of the event.
	//
	// Can be [IAssetAdministrationShell], [ISubmodel] or
	// [ISubmodelElement].
	ObservableReference() IReference;

	SetObservableReference(
		value IReference,
	);

	// [IHasSemantics.SemanticID] of the referable which defines the scope of
	// the event, if available.
	//
	// NOTE: It is recommended to use a global reference.
	ObservableSemanticID() IReference;

	SetObservableSemanticID(
		value IReference,
	);

	// Information for the outer message infrastructure for scheduling the event to
	// the respective communication channel.
	Topic() *string;

	SetTopic(
		value *string,
	);

	// Subject, who/which initiated the creation.
	//
	// NOTE: This is an external reference.
	SubjectID() IReference;

	SetSubjectID(
		value IReference,
	);

	// Timestamp in UTC, when this event was triggered.
	TimeStamp() string;

	SetTimeStamp(
		value string,
	);

	// Event specific payload.
	Payload() []byte;

	SetPayload(
		value []byte,
	);
}

// Check whether the instance corresponds to [aastypes.IEventPayload]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsEventPayload(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeEventPayload
	return
}

// Implements IEventPayload.
type EventPayload struct {
	source IReference
	sourceSemanticID IReference
	observableReference IReference
	observableSemanticID IReference
	topic *string
	subjectID IReference
	timeStamp string
	payload []byte
}

func (ep *EventPayload) Source(
) IReference {
	return ep.source
}

func (ep *EventPayload) SetSource(
	value IReference,
) {
	ep.source = value
}

func (ep *EventPayload) SourceSemanticID(
) IReference {
	return ep.sourceSemanticID
}

func (ep *EventPayload) SetSourceSemanticID(
	value IReference,
) {
	ep.sourceSemanticID = value
}

func (ep *EventPayload) ObservableReference(
) IReference {
	return ep.observableReference
}

func (ep *EventPayload) SetObservableReference(
	value IReference,
) {
	ep.observableReference = value
}

func (ep *EventPayload) ObservableSemanticID(
) IReference {
	return ep.observableSemanticID
}

func (ep *EventPayload) SetObservableSemanticID(
	value IReference,
) {
	ep.observableSemanticID = value
}

func (ep *EventPayload) Topic(
) *string {
	return ep.topic
}

func (ep *EventPayload) SetTopic(
	value *string,
) {
	ep.topic = value
}

func (ep *EventPayload) SubjectID(
) IReference {
	return ep.subjectID
}

func (ep *EventPayload) SetSubjectID(
	value IReference,
) {
	ep.subjectID = value
}

func (ep *EventPayload) TimeStamp(
) string {
	return ep.timeStamp
}

func (ep *EventPayload) SetTimeStamp(
	value string,
) {
	ep.timeStamp = value
}

func (ep *EventPayload) Payload(
) []byte {
	return ep.payload
}

func (ep *EventPayload) SetPayload(
	value []byte,
) {
	ep.payload = value
}

func (ep *EventPayload) ModelType(
) ModelType {
	return ModelTypeEventPayload
}

// Apply the action on the instances referenced from ep.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on ep.
func (ep *EventPayload) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		ep.source,
	)
	if abort {
		return
	}

	if ep.sourceSemanticID != nil {
		abort = action(
			ep.sourceSemanticID,
		)
		if abort {
			return
		}
	}

	abort = action(
		ep.observableReference,
	)
	if abort {
		return
	}

	if ep.observableSemanticID != nil {
		abort = action(
			ep.observableSemanticID,
		)
		if abort {
			return
		}
	}

	if ep.subjectID != nil {
		abort = action(
			ep.subjectID,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from ep.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on ep.
func (ep *EventPayload) Descend(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		ep.source,
	)
	if abort {
		return
	}
	abort = ep.source.Descend(
		action,
	)
	if abort {
		return
	}

	if ep.sourceSemanticID != nil {
		abort = action(
			ep.sourceSemanticID,
		)
		if abort {
			return
		}
		abort = ep.sourceSemanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	abort = action(
		ep.observableReference,
	)
	if abort {
		return
	}
	abort = ep.observableReference.Descend(
		action,
	)
	if abort {
		return
	}

	if ep.observableSemanticID != nil {
		abort = action(
			ep.observableSemanticID,
		)
		if abort {
			return
		}
		abort = ep.observableSemanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if ep.subjectID != nil {
		abort = action(
			ep.subjectID,
		)
		if abort {
			return
		}
		abort = ep.subjectID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of EventPayload with
// the given properties.
func NewEventPayload(
	source IReference,
	observableReference IReference,
	timeStamp string,
) *EventPayload {
	return &EventPayload{
		source: source,
		observableReference: observableReference,
		timeStamp: timeStamp,
		sourceSemanticID: nil,
		observableSemanticID: nil,
		topic: nil,
		subjectID: nil,
		payload: nil,
	}
}

// An event element.
//
// NOTE: This element is experimental and therefore may be subject to change or may be
// removed completely in future versions of the meta-model.
type IEventElement interface {
	ISubmodelElement
}

// Check whether the instance corresponds to [aastypes.IEventElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsEventElement(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeBasicEventElement:
		ok = true
	}
	return
}

// A basic event element.
//
// NOTE: This element is experimental and therefore may be subject to change or may be
// removed completely in future versions of the meta-model.
type IBasicEventElement interface {
	IEventElement

	// Reference to the [IReferable], which defines the scope of the event.
	// Can be [IAssetAdministrationShell], [ISubmodel], or
	// [ISubmodelElement].
	//
	// Reference to a referable, e.g., a data element or
	// a submodel, that is being observed.
	Observed() IReference;

	SetObserved(
		value IReference,
	);

	// Direction of event.
	//
	// Can be `{ Input, Output }`.
	Direction() Direction;

	SetDirection(
		value Direction,
	);

	// State of event.
	//
	// Can be `{ On, Off }`.
	State() StateOfEvent;

	SetState(
		value StateOfEvent,
	);

	// Information for the outer message infrastructure for scheduling the event to the
	// respective communication channel.
	MessageTopic() *string;

	SetMessageTopic(
		value *string,
	);

	// Information, which outer message infrastructure shall handle messages for
	// the [IEventElement]. Refers to a [ISubmodel],
	// [ISubmodelElementList], [ISubmodelElementCollection] or
	// [IEntity], which contains [IDataElement]'s describing
	// the proprietary specification for the message broker.
	//
	// NOTE: For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
	// proprietary specification could be standardized by having respective Submodels.
	MessageBroker() IReference;

	SetMessageBroker(
		value IReference,
	);

	// Timestamp in UTC, when the last event was received (input direction) or sent
	// (output direction).
	LastUpdate() *string;

	SetLastUpdate(
		value *string,
	);

	// For input direction, reports on the maximum frequency, the software entity behind
	// the respective Referable can handle input events.
	//
	// For output events, specifies the maximum frequency of outputting this event to
	// an outer infrastructure.
	//
	// Might be not specified, that is, there is no minimum interval.
	MinInterval() *string;

	SetMinInterval(
		value *string,
	);

	// For input direction: not applicable.
	//
	// For output direction: maximum interval in time, the respective Referable shall send
	// an update of the status of the event, even if no other trigger condition for
	// the event was not met.
	//
	// Might be not specified, that is, there is no maximum interval
	MaxInterval() *string;

	SetMaxInterval(
		value *string,
	);
}

// Check whether the instance corresponds to [aastypes.IBasicEventElement]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsBasicEventElement(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeBasicEventElement
	return
}

// Implements IBasicEventElement.
type BasicEventElement struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	observed IReference
	direction Direction
	state StateOfEvent
	messageTopic *string
	messageBroker IReference
	lastUpdate *string
	minInterval *string
	maxInterval *string
}

func (bee *BasicEventElement) Extensions(
) []IExtension {
	return bee.extensions
}

func (bee *BasicEventElement) SetExtensions(
	value []IExtension,
) {
	bee.extensions = value
}

func (bee *BasicEventElement) Category(
) *string {
	return bee.category
}

func (bee *BasicEventElement) SetCategory(
	value *string,
) {
	bee.category = value
}

func (bee *BasicEventElement) IDShort(
) *string {
	return bee.idShort
}

func (bee *BasicEventElement) SetIDShort(
	value *string,
) {
	bee.idShort = value
}

func (bee *BasicEventElement) DisplayName(
) []ILangStringNameType {
	return bee.displayName
}

func (bee *BasicEventElement) SetDisplayName(
	value []ILangStringNameType,
) {
	bee.displayName = value
}

func (bee *BasicEventElement) Description(
) []ILangStringTextType {
	return bee.description
}

func (bee *BasicEventElement) SetDescription(
	value []ILangStringTextType,
) {
	bee.description = value
}

func (bee *BasicEventElement) SemanticID(
) IReference {
	return bee.semanticID
}

func (bee *BasicEventElement) SetSemanticID(
	value IReference,
) {
	bee.semanticID = value
}

func (bee *BasicEventElement) SupplementalSemanticIDs(
) []IReference {
	return bee.supplementalSemanticIDs
}

func (bee *BasicEventElement) SetSupplementalSemanticIDs(
	value []IReference,
) {
	bee.supplementalSemanticIDs = value
}

func (bee *BasicEventElement) Qualifiers(
) []IQualifier {
	return bee.qualifiers
}

func (bee *BasicEventElement) SetQualifiers(
	value []IQualifier,
) {
	bee.qualifiers = value
}

func (bee *BasicEventElement) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return bee.embeddedDataSpecifications
}

func (bee *BasicEventElement) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	bee.embeddedDataSpecifications = value
}

func (bee *BasicEventElement) Observed(
) IReference {
	return bee.observed
}

func (bee *BasicEventElement) SetObserved(
	value IReference,
) {
	bee.observed = value
}

func (bee *BasicEventElement) Direction(
) Direction {
	return bee.direction
}

func (bee *BasicEventElement) SetDirection(
	value Direction,
) {
	bee.direction = value
}

func (bee *BasicEventElement) State(
) StateOfEvent {
	return bee.state
}

func (bee *BasicEventElement) SetState(
	value StateOfEvent,
) {
	bee.state = value
}

func (bee *BasicEventElement) MessageTopic(
) *string {
	return bee.messageTopic
}

func (bee *BasicEventElement) SetMessageTopic(
	value *string,
) {
	bee.messageTopic = value
}

func (bee *BasicEventElement) MessageBroker(
) IReference {
	return bee.messageBroker
}

func (bee *BasicEventElement) SetMessageBroker(
	value IReference,
) {
	bee.messageBroker = value
}

func (bee *BasicEventElement) LastUpdate(
) *string {
	return bee.lastUpdate
}

func (bee *BasicEventElement) SetLastUpdate(
	value *string,
) {
	bee.lastUpdate = value
}

func (bee *BasicEventElement) MinInterval(
) *string {
	return bee.minInterval
}

func (bee *BasicEventElement) SetMinInterval(
	value *string,
) {
	bee.minInterval = value
}

func (bee *BasicEventElement) MaxInterval(
) *string {
	return bee.maxInterval
}

func (bee *BasicEventElement) SetMaxInterval(
	value *string,
) {
	bee.maxInterval = value
}

func (bee *BasicEventElement) ModelType(
) ModelType {
	return ModelTypeBasicEventElement
}

// Apply the action on the instances referenced from bee.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on bee.
func (bee *BasicEventElement) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if bee.extensions != nil {
		for _, v := range bee.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if bee.displayName != nil {
		for _, v1 := range bee.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if bee.description != nil {
		for _, v2 := range bee.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if bee.semanticID != nil {
		abort = action(
			bee.semanticID,
		)
		if abort {
			return
		}
	}

	if bee.supplementalSemanticIDs != nil {
		for _, v3 := range bee.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if bee.qualifiers != nil {
		for _, v4 := range bee.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if bee.embeddedDataSpecifications != nil {
		for _, v5 := range bee.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	abort = action(
		bee.observed,
	)
	if abort {
		return
	}

	if bee.messageBroker != nil {
		abort = action(
			bee.messageBroker,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from bee.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on bee.
func (bee *BasicEventElement) Descend(
	action func(IClass) bool,
) (abort bool) {
	if bee.extensions != nil {
		for _, v := range bee.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if bee.displayName != nil {
		for _, v1 := range bee.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if bee.description != nil {
		for _, v2 := range bee.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if bee.semanticID != nil {
		abort = action(
			bee.semanticID,
		)
		if abort {
			return
		}
		abort = bee.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if bee.supplementalSemanticIDs != nil {
		for _, v3 := range bee.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if bee.qualifiers != nil {
		for _, v4 := range bee.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if bee.embeddedDataSpecifications != nil {
		for _, v5 := range bee.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	abort = action(
		bee.observed,
	)
	if abort {
		return
	}
	abort = bee.observed.Descend(
		action,
	)
	if abort {
		return
	}

	if bee.messageBroker != nil {
		abort = action(
			bee.messageBroker,
		)
		if abort {
			return
		}
		abort = bee.messageBroker.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of BasicEventElement with
// the given properties.
func NewBasicEventElement(
	observed IReference,
	direction Direction,
	state StateOfEvent,
) *BasicEventElement {
	return &BasicEventElement{
		observed: observed,
		direction: direction,
		state: state,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		messageTopic: nil,
		messageBroker: nil,
		lastUpdate: nil,
		minInterval: nil,
		maxInterval: nil,
	}
}

// An operation is a submodel element with input and output variables.
//
// Constraint AASd-134:
// For an [IOperation] the [IReferable.IDShort] of all
// [IOperationVariable.Value]'s in
// [IOperation.InputVariables], [IOperation.OutputVariables]
// and [IOperation.InoutputVariables] shall be unique.
type IOperation interface {
	ISubmodelElement

	// Input parameter of the operation.
	InputVariables() []IOperationVariable;

	SetInputVariables(
		value []IOperationVariable,
	);

	// Output parameter of the operation.
	OutputVariables() []IOperationVariable;

	SetOutputVariables(
		value []IOperationVariable,
	);

	// Parameter that is input and output of the operation.
	InoutputVariables() []IOperationVariable;

	SetInoutputVariables(
		value []IOperationVariable,
	);
}

// Check whether the instance corresponds to [aastypes.IOperation]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsOperation(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeOperation
	return
}

// Implements IOperation.
type Operation struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
	inputVariables []IOperationVariable
	outputVariables []IOperationVariable
	inoutputVariables []IOperationVariable
}

func (o *Operation) Extensions(
) []IExtension {
	return o.extensions
}

func (o *Operation) SetExtensions(
	value []IExtension,
) {
	o.extensions = value
}

func (o *Operation) Category(
) *string {
	return o.category
}

func (o *Operation) SetCategory(
	value *string,
) {
	o.category = value
}

func (o *Operation) IDShort(
) *string {
	return o.idShort
}

func (o *Operation) SetIDShort(
	value *string,
) {
	o.idShort = value
}

func (o *Operation) DisplayName(
) []ILangStringNameType {
	return o.displayName
}

func (o *Operation) SetDisplayName(
	value []ILangStringNameType,
) {
	o.displayName = value
}

func (o *Operation) Description(
) []ILangStringTextType {
	return o.description
}

func (o *Operation) SetDescription(
	value []ILangStringTextType,
) {
	o.description = value
}

func (o *Operation) SemanticID(
) IReference {
	return o.semanticID
}

func (o *Operation) SetSemanticID(
	value IReference,
) {
	o.semanticID = value
}

func (o *Operation) SupplementalSemanticIDs(
) []IReference {
	return o.supplementalSemanticIDs
}

func (o *Operation) SetSupplementalSemanticIDs(
	value []IReference,
) {
	o.supplementalSemanticIDs = value
}

func (o *Operation) Qualifiers(
) []IQualifier {
	return o.qualifiers
}

func (o *Operation) SetQualifiers(
	value []IQualifier,
) {
	o.qualifiers = value
}

func (o *Operation) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return o.embeddedDataSpecifications
}

func (o *Operation) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	o.embeddedDataSpecifications = value
}

func (o *Operation) InputVariables(
) []IOperationVariable {
	return o.inputVariables
}

func (o *Operation) SetInputVariables(
	value []IOperationVariable,
) {
	o.inputVariables = value
}

func (o *Operation) OutputVariables(
) []IOperationVariable {
	return o.outputVariables
}

func (o *Operation) SetOutputVariables(
	value []IOperationVariable,
) {
	o.outputVariables = value
}

func (o *Operation) InoutputVariables(
) []IOperationVariable {
	return o.inoutputVariables
}

func (o *Operation) SetInoutputVariables(
	value []IOperationVariable,
) {
	o.inoutputVariables = value
}

func (o *Operation) ModelType(
) ModelType {
	return ModelTypeOperation
}

// Apply the action on the instances referenced from o.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on o.
func (o *Operation) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if o.extensions != nil {
		for _, v := range o.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if o.displayName != nil {
		for _, v1 := range o.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if o.description != nil {
		for _, v2 := range o.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if o.semanticID != nil {
		abort = action(
			o.semanticID,
		)
		if abort {
			return
		}
	}

	if o.supplementalSemanticIDs != nil {
		for _, v3 := range o.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if o.qualifiers != nil {
		for _, v4 := range o.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if o.embeddedDataSpecifications != nil {
		for _, v5 := range o.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	if o.inputVariables != nil {
		for _, v6 := range o.inputVariables {
			abort = action(v6);
			if abort {
				return
			}
		}
	}

	if o.outputVariables != nil {
		for _, v7 := range o.outputVariables {
			abort = action(v7);
			if abort {
				return
			}
		}
	}

	if o.inoutputVariables != nil {
		for _, v8 := range o.inoutputVariables {
			abort = action(v8);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from o.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on o.
func (o *Operation) Descend(
	action func(IClass) bool,
) (abort bool) {
	if o.extensions != nil {
		for _, v := range o.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.displayName != nil {
		for _, v1 := range o.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.description != nil {
		for _, v2 := range o.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.semanticID != nil {
		abort = action(
			o.semanticID,
		)
		if abort {
			return
		}
		abort = o.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if o.supplementalSemanticIDs != nil {
		for _, v3 := range o.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.qualifiers != nil {
		for _, v4 := range o.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.embeddedDataSpecifications != nil {
		for _, v5 := range o.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.inputVariables != nil {
		for _, v6 := range o.inputVariables {
			abort = action(v6);
			if abort {
				return
			}

			abort = v6.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.outputVariables != nil {
		for _, v7 := range o.outputVariables {
			abort = action(v7);
			if abort {
				return
			}

			abort = v7.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if o.inoutputVariables != nil {
		for _, v8 := range o.inoutputVariables {
			abort = action(v8);
			if abort {
				return
			}

			abort = v8.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Operation with
// the given properties.
func NewOperation() *Operation {
	return &Operation{
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
		inputVariables: nil,
		outputVariables: nil,
		inoutputVariables: nil,
	}
}

// The value of an operation variable is a submodel element that is used as input
// and/or output variable of an operation.
type IOperationVariable interface {
	IClass

	// Describes an argument or result of an operation via a submodel element
	Value() ISubmodelElement;

	SetValue(
		value ISubmodelElement,
	);
}

// Check whether the instance corresponds to [aastypes.IOperationVariable]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsOperationVariable(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeOperationVariable
	return
}

// Implements IOperationVariable.
type OperationVariable struct {
	value ISubmodelElement
}

func (ov *OperationVariable) Value(
) ISubmodelElement {
	return ov.value
}

func (ov *OperationVariable) SetValue(
	value ISubmodelElement,
) {
	ov.value = value
}

func (ov *OperationVariable) ModelType(
) ModelType {
	return ModelTypeOperationVariable
}

// Apply the action on the instances referenced from ov.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on ov.
func (ov *OperationVariable) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		ov.value,
	)
	if abort {
		return
	}

	return
}

// Apply the action recursively on the instances referenced from ov.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on ov.
func (ov *OperationVariable) Descend(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		ov.value,
	)
	if abort {
		return
	}
	abort = ov.value.Descend(
		action,
	)
	if abort {
		return
	}

	return
}

// Create a new instance of OperationVariable with
// the given properties.
func NewOperationVariable(
	value ISubmodelElement,
) *OperationVariable {
	return &OperationVariable{
		value: value,
	}
}

// A capability is the implementation-independent description of the potential of an
// asset to achieve a certain effect in the physical or virtual world.
//
// NOTE: The [ICapability.SemanticID] of a capability is typically an ontology.
// Thus, reasoning on capabilities is enabled.
type ICapability interface {
	ISubmodelElement
}

// Check whether the instance corresponds to [aastypes.ICapability]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsCapability(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeCapability
	return
}

// Implements ICapability.
type Capability struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	semanticID IReference
	supplementalSemanticIDs []IReference
	qualifiers []IQualifier
	embeddedDataSpecifications []IEmbeddedDataSpecification
}

func (c *Capability) Extensions(
) []IExtension {
	return c.extensions
}

func (c *Capability) SetExtensions(
	value []IExtension,
) {
	c.extensions = value
}

func (c *Capability) Category(
) *string {
	return c.category
}

func (c *Capability) SetCategory(
	value *string,
) {
	c.category = value
}

func (c *Capability) IDShort(
) *string {
	return c.idShort
}

func (c *Capability) SetIDShort(
	value *string,
) {
	c.idShort = value
}

func (c *Capability) DisplayName(
) []ILangStringNameType {
	return c.displayName
}

func (c *Capability) SetDisplayName(
	value []ILangStringNameType,
) {
	c.displayName = value
}

func (c *Capability) Description(
) []ILangStringTextType {
	return c.description
}

func (c *Capability) SetDescription(
	value []ILangStringTextType,
) {
	c.description = value
}

func (c *Capability) SemanticID(
) IReference {
	return c.semanticID
}

func (c *Capability) SetSemanticID(
	value IReference,
) {
	c.semanticID = value
}

func (c *Capability) SupplementalSemanticIDs(
) []IReference {
	return c.supplementalSemanticIDs
}

func (c *Capability) SetSupplementalSemanticIDs(
	value []IReference,
) {
	c.supplementalSemanticIDs = value
}

func (c *Capability) Qualifiers(
) []IQualifier {
	return c.qualifiers
}

func (c *Capability) SetQualifiers(
	value []IQualifier,
) {
	c.qualifiers = value
}

func (c *Capability) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return c.embeddedDataSpecifications
}

func (c *Capability) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	c.embeddedDataSpecifications = value
}

func (c *Capability) ModelType(
) ModelType {
	return ModelTypeCapability
}

// Apply the action on the instances referenced from c.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on c.
func (c *Capability) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if c.extensions != nil {
		for _, v := range c.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if c.displayName != nil {
		for _, v1 := range c.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if c.description != nil {
		for _, v2 := range c.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if c.semanticID != nil {
		abort = action(
			c.semanticID,
		)
		if abort {
			return
		}
	}

	if c.supplementalSemanticIDs != nil {
		for _, v3 := range c.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if c.qualifiers != nil {
		for _, v4 := range c.qualifiers {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	if c.embeddedDataSpecifications != nil {
		for _, v5 := range c.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from c.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on c.
func (c *Capability) Descend(
	action func(IClass) bool,
) (abort bool) {
	if c.extensions != nil {
		for _, v := range c.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if c.displayName != nil {
		for _, v1 := range c.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if c.description != nil {
		for _, v2 := range c.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if c.semanticID != nil {
		abort = action(
			c.semanticID,
		)
		if abort {
			return
		}
		abort = c.semanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if c.supplementalSemanticIDs != nil {
		for _, v3 := range c.supplementalSemanticIDs {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if c.qualifiers != nil {
		for _, v4 := range c.qualifiers {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if c.embeddedDataSpecifications != nil {
		for _, v5 := range c.embeddedDataSpecifications {
			abort = action(v5);
			if abort {
				return
			}

			abort = v5.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Capability with
// the given properties.
func NewCapability() *Capability {
	return &Capability{
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		semanticID: nil,
		supplementalSemanticIDs: nil,
		qualifiers: nil,
		embeddedDataSpecifications: nil,
	}
}

// The semantics of a property or other elements that may have a semantic description
// is defined by a concept description.
//
// The description of the concept should follow a standardized schema (realized as
// data specification template).
//
// Constraint AASc-3a-004:
// For a [IConceptDescription] with [IConceptDescription.Category] `PROPERTY` or
// `VALUE` using data specification IEC61360,
// the [IDataSpecificationIEC61360.DataType] is mandatory and shall be
// one of: `DATE`, `STRING`, `STRING_TRANSLATABLE`, `INTEGER_MEASURE`,
// `INTEGER_COUNT`, `INTEGER_CURRENCY`, `REAL_MEASURE`, `REAL_COUNT`,
// `REAL_CURRENCY`, `BOOLEAN`, `RATIONAL`, `RATIONAL_MEASURE`,
// `TIME`, `TIMESTAMP`.
//
// NOTE: Note: categories are deprecated since V3.0 of Part 1a of the document series
// "Details of the Asset Administration Shell".
//
// Constraint AASc-3a-005:
// For a [IConceptDescription] with [IConceptDescription.Category] `REFERENCE`
// using data specification template IEC61360,
// the [IDataSpecificationIEC61360.DataType] shall be
// one of: `STRING`, `IRI`, `IRDI`.
//
// NOTE: Note: categories are deprecated since V3.0 of Part 1a of the document series
// "Details of the Asset Administration Shell".
//
// Constraint AASc-3a-006:
// For a [IConceptDescription] with [IConceptDescription.Category] `DOCUMENT`
// using data specification IEC61360,
// the [IDataSpecificationIEC61360.DataType] shall be one of `FILE`,
// `BLOB`, `HTML`
//
// NOTE: Categories are deprecated since V3.0 of Part 1a of the document series
// "Details of the Asset Administration Shell".
//
// Constraint AASc-3a-007:
// For a [IConceptDescription] with [IConceptDescription.Category] `QUALIFIER_TYPE`
// using data specification IEC61360,
// the [IDataSpecificationIEC61360.DataType] is mandatory and shall be
// defined.
//
// NOTE: Categories are deprecated since V3.0 of Part 1a of the document series
// "Details of the Asset Administration Shell".
//
// Constraint AASc-3a-008:
// For a [IConceptDescription] using data specification template IEC61360,
// [IDataSpecificationIEC61360.Definition] is mandatory and shall be
// defined at least in English.
//
// Exception: The concept description describes a value, i.e.
// [IDataSpecificationIEC61360.Value] is defined.
//
// Constraint AASc-3a-003:
// For a [IConceptDescription] using data specification template IEC61360,
// referenced via [IDataSpecificationIEC61360.ValueList]
// [IValueReferencePair.ValueID]
// the [IDataSpecificationIEC61360.Value] shall be set.
type IConceptDescription interface {
	IIdentifiable

	IHasDataSpecification

	// Reference to an external definition the concept is compatible to or was derived
	// from.
	//
	// NOTE: It is recommended to use a global reference.
	//
	// NOTE: Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360
	IsCaseOf() []IReference;

	SetIsCaseOf(
		value []IReference,
	);
}

// Check whether the instance corresponds to [aastypes.IConceptDescription]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsConceptDescription(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeConceptDescription
	return
}

// Implements IConceptDescription.
type ConceptDescription struct {
	extensions []IExtension
	category *string
	idShort *string
	displayName []ILangStringNameType
	description []ILangStringTextType
	administration IAdministrativeInformation
	id string
	embeddedDataSpecifications []IEmbeddedDataSpecification
	isCaseOf []IReference
}

func (cd *ConceptDescription) Extensions(
) []IExtension {
	return cd.extensions
}

func (cd *ConceptDescription) SetExtensions(
	value []IExtension,
) {
	cd.extensions = value
}

func (cd *ConceptDescription) Category(
) *string {
	return cd.category
}

func (cd *ConceptDescription) SetCategory(
	value *string,
) {
	cd.category = value
}

func (cd *ConceptDescription) IDShort(
) *string {
	return cd.idShort
}

func (cd *ConceptDescription) SetIDShort(
	value *string,
) {
	cd.idShort = value
}

func (cd *ConceptDescription) DisplayName(
) []ILangStringNameType {
	return cd.displayName
}

func (cd *ConceptDescription) SetDisplayName(
	value []ILangStringNameType,
) {
	cd.displayName = value
}

func (cd *ConceptDescription) Description(
) []ILangStringTextType {
	return cd.description
}

func (cd *ConceptDescription) SetDescription(
	value []ILangStringTextType,
) {
	cd.description = value
}

func (cd *ConceptDescription) Administration(
) IAdministrativeInformation {
	return cd.administration
}

func (cd *ConceptDescription) SetAdministration(
	value IAdministrativeInformation,
) {
	cd.administration = value
}

func (cd *ConceptDescription) ID(
) string {
	return cd.id
}

func (cd *ConceptDescription) SetID(
	value string,
) {
	cd.id = value
}

func (cd *ConceptDescription) EmbeddedDataSpecifications(
) []IEmbeddedDataSpecification {
	return cd.embeddedDataSpecifications
}

func (cd *ConceptDescription) SetEmbeddedDataSpecifications(
	value []IEmbeddedDataSpecification,
) {
	cd.embeddedDataSpecifications = value
}

func (cd *ConceptDescription) IsCaseOf(
) []IReference {
	return cd.isCaseOf
}

func (cd *ConceptDescription) SetIsCaseOf(
	value []IReference,
) {
	cd.isCaseOf = value
}

func (cd *ConceptDescription) ModelType(
) ModelType {
	return ModelTypeConceptDescription
}

// Apply the action on the instances referenced from cd.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on cd.
func (cd *ConceptDescription) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if cd.extensions != nil {
		for _, v := range cd.extensions {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if cd.displayName != nil {
		for _, v1 := range cd.displayName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if cd.description != nil {
		for _, v2 := range cd.description {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if cd.administration != nil {
		abort = action(
			cd.administration,
		)
		if abort {
			return
		}
	}

	if cd.embeddedDataSpecifications != nil {
		for _, v3 := range cd.embeddedDataSpecifications {
			abort = action(v3);
			if abort {
				return
			}
		}
	}

	if cd.isCaseOf != nil {
		for _, v4 := range cd.isCaseOf {
			abort = action(v4);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from cd.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on cd.
func (cd *ConceptDescription) Descend(
	action func(IClass) bool,
) (abort bool) {
	if cd.extensions != nil {
		for _, v := range cd.extensions {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if cd.displayName != nil {
		for _, v1 := range cd.displayName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if cd.description != nil {
		for _, v2 := range cd.description {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if cd.administration != nil {
		abort = action(
			cd.administration,
		)
		if abort {
			return
		}
		abort = cd.administration.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if cd.embeddedDataSpecifications != nil {
		for _, v3 := range cd.embeddedDataSpecifications {
			abort = action(v3);
			if abort {
				return
			}

			abort = v3.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if cd.isCaseOf != nil {
		for _, v4 := range cd.isCaseOf {
			abort = action(v4);
			if abort {
				return
			}

			abort = v4.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of ConceptDescription with
// the given properties.
func NewConceptDescription(
	id string,
) *ConceptDescription {
	return &ConceptDescription{
		id: id,
		extensions: nil,
		category: nil,
		idShort: nil,
		displayName: nil,
		description: nil,
		administration: nil,
		embeddedDataSpecifications: nil,
		isCaseOf: nil,
	}
}

// Reference types
type ReferenceTypes int;const (
	// External reference.
	ReferenceTypesExternalReference ReferenceTypes = iota
	// Model reference.
	ReferenceTypesModelReference
)

// List the literals of [ReferenceTypes].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfReferenceTypes = [...]ReferenceTypes {
	ReferenceTypesExternalReference,
	ReferenceTypesModelReference,
}

// Reference to either a model element of the same or another AAS or to an external
// entity.
//
// A reference is an ordered list of keys.
//
// A model reference is an ordered list of keys, each key referencing an element. The
// complete list of keys may for example be concatenated to a path that then gives
// unique access to an element.
//
// An external reference is a reference to an external entity.
//
// Constraint AASd-121:
// For [IReference]'s the value of [IKey.Type] of the first key of "
// [IReference.Keys] shall be one of [aasconstants.GloballyIdentifiables].
//
// Constraint AASd-122:
// For external references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesExternalReference], the value
// of [IKey.Type] of the first key of [IReference.Keys] shall be one of
// [aasconstants.GenericGloballyIdentifiables].
//
// Constraint AASd-123:
// For model references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesModelReference], the value
// of [IKey.Type] of the first key of [IReference.Keys] shall be one of
// [aasconstants.AASIdentifiables].
//
// Constraint AASd-124:
// For external references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesExternalReference], the last
// key of [IReference.Keys] shall be either one of
// [aasconstants.GenericGloballyIdentifiables] or one of
// [aasconstants.GenericFragmentKeys].
//
// Constraint AASd-125:
// For model references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesModelReference], with more
// than one key in [IReference.Keys] the value of [IKey.Type]
// of each of the keys following the first
// key of [IReference.Keys] shall be one of [aasconstants.FragmentKeys].
//
// NOTE: Constraint AASd-125 ensures that the shortest path is used.
//
// Constraint AASd-126:
// For model references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesModelReference], with more
// than one key in [IReference.Keys] the value of [IKey.Type]
// of the last key in the reference key chain may be
// one of [aasconstants.GenericFragmentKeys] or no key at all
// shall have a value out of [aasconstants.GenericFragmentKeys].
//
// Constraint AASd-127:
// For model references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesModelReference], with more
// than one key in [IReference.Keys] a key with [IKey.Type]
// [KeyTypesFragmentReference] shall be preceded by a key with
// [IKey.Type] [KeyTypesFile] or [KeyTypesBlob]. All other
// AAS fragments, i.e. [IKey.Type] values
// out of [aasconstants.AASSubmodelElementsAsKeys], do not support fragments.
//
// NOTE: Which kind of fragments are supported depends on the content type and the
// specification of allowed fragment identifiers for the corresponding resource
// being referenced via the reference.
//
// Constraint AASd-128:
// For model references, i.e. [IReference]'s with
// [IReference.Type] = [ReferenceTypesModelReference], the
// [IKey.Value] of a [IKey] preceded by a [IKey] with
// [IKey.Type] = [KeyTypesSubmodelElementList] is an integer
// number denoting the position in the array of the submodel element list.
type IReference interface {
	IClass

	// Type of the reference.
	//
	// Denotes, whether reference is an external reference or a model reference.
	Type() ReferenceTypes;

	SetType(
		value ReferenceTypes,
	);

	// [IHasSemantics.SemanticID] of the referenced model element
	// ([IReference.Type] = [ReferenceTypesModelReference]).
	//
	// For external references there typically is no semantic ID.
	//
	// NOTE: It is recommended to use a external reference.
	ReferredSemanticID() IReference;

	SetReferredSemanticID(
		value IReference,
	);

	// Unique references in their name space.
	Keys() []IKey;

	SetKeys(
		value []IKey,
	);
}

// Check whether the instance corresponds to [aastypes.IReference]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsReference(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeReference
	return
}

// Implements IReference.
type Reference struct {
	typE ReferenceTypes
	referredSemanticID IReference
	keys []IKey
}

func (r *Reference) Type(
) ReferenceTypes {
	return r.typE
}

func (r *Reference) SetType(
	value ReferenceTypes,
) {
	r.typE = value
}

func (r *Reference) ReferredSemanticID(
) IReference {
	return r.referredSemanticID
}

func (r *Reference) SetReferredSemanticID(
	value IReference,
) {
	r.referredSemanticID = value
}

func (r *Reference) Keys(
) []IKey {
	return r.keys
}

func (r *Reference) SetKeys(
	value []IKey,
) {
	r.keys = value
}

func (r *Reference) ModelType(
) ModelType {
	return ModelTypeReference
}

// Apply the action on the instances referenced from r.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on r.
func (r *Reference) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if r.referredSemanticID != nil {
		abort = action(
			r.referredSemanticID,
		)
		if abort {
			return
		}
	}

	for _, v := range r.keys {
		abort = action(v);
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from r.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on r.
func (r *Reference) Descend(
	action func(IClass) bool,
) (abort bool) {
	if r.referredSemanticID != nil {
		abort = action(
			r.referredSemanticID,
		)
		if abort {
			return
		}
		abort = r.referredSemanticID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	for _, v := range r.keys {
		abort = action(v);
		if abort {
			return
		}

		abort = v.Descend(
			action,
		);
		if abort {
			return
		}
	}

	return
}

// Create a new instance of Reference with
// the given properties.
func NewReference(
	typE ReferenceTypes,
	keys []IKey,
) *Reference {
	return &Reference{
		typE: typE,
		keys: keys,
		referredSemanticID: nil,
	}
}

// A key is a reference to an element by its ID.
type IKey interface {
	IClass

	// Denotes which kind of entity is referenced.
	//
	// In case [IKey.Type] = [KeyTypesGlobalReference],
	// the key represents a reference to a source that can be globally identified.
	//
	// In case [IKey.Type] = [KeyTypesFragmentReference] the key represents
	// a bookmark or a similar local identifier within its parent element as specified
	// by the key that precedes this key.
	//
	// In all other cases the key references a model element of the same or of another AAS.
	// The name of the model element is explicitly listed.
	Type() KeyTypes;

	SetType(
		value KeyTypes,
	);

	// The key value, for example an IRDI or an URI
	Value() string;

	SetValue(
		value string,
	);
}

// Check whether the instance corresponds to [aastypes.IKey]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsKey(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeKey
	return
}

// Implements IKey.
type Key struct {
	typE KeyTypes
	value string
}

func (k *Key) Type(
) KeyTypes {
	return k.typE
}

func (k *Key) SetType(
	value KeyTypes,
) {
	k.typE = value
}

func (k *Key) Value(
) string {
	return k.value
}

func (k *Key) SetValue(
	value string,
) {
	k.value = value
}

func (k *Key) ModelType(
) ModelType {
	return ModelTypeKey
}

// Apply the action on the instances referenced from k.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on k.
func (k *Key) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from k.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on k.
func (k *Key) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of Key with
// the given properties.
func NewKey(
	typE KeyTypes,
	value string,
) *Key {
	return &Key{
		typE: typE,
		value: value,
	}
}

// Enumeration of different key value types within a key.
type KeyTypes int;const (
	KeyTypesAnnotatedRelationshipElement KeyTypes = iota
	KeyTypesAssetAdministrationShell
	KeyTypesBasicEventElement
	KeyTypesBlob
	KeyTypesCapability
	KeyTypesConceptDescription
	// Data element.
	//
	// NOTE: Data Element is abstract, i.e. if a key uses [KeyTypesDataElement]
	// the reference may be a Property, a File etc.
	KeyTypesDataElement
	KeyTypesEntity
	// Event.
	//
	// NOTE: [IEventElement] is abstract.
	KeyTypesEventElement
	KeyTypesFile
	// Bookmark or a similar local identifier of a subordinate part of
	// a primary resource
	KeyTypesFragmentReference
	KeyTypesGlobalReference
	// Identifiable.
	//
	// NOTE: Identifiable is abstract, i.e. if a key uses “Identifiable” the reference
	// may be an Asset Administration Shell, a Submodel or a Concept Description.
	KeyTypesIdentifiable
	// Property with a value that can be provided in multiple languages
	KeyTypesMultiLanguageProperty
	KeyTypesOperation
	KeyTypesProperty
	// Range with min and max
	KeyTypesRange
	KeyTypesReferable
	// Reference
	KeyTypesReferenceElement
	// Relationship
	KeyTypesRelationshipElement
	KeyTypesSubmodel
	// Submodel Element
	//
	// NOTE: Submodel Element is abstract, i.e. if a key uses [KeyTypesSubmodelElement]
	// the reference may be a [IProperty], an [IOperation] etc.
	KeyTypesSubmodelElement
	// Struct of Submodel Elements
	KeyTypesSubmodelElementCollection
	// List of Submodel Elements
	KeyTypesSubmodelElementList
)

// List the literals of [KeyTypes].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfKeyTypes = [...]KeyTypes {
	KeyTypesAnnotatedRelationshipElement,
	KeyTypesAssetAdministrationShell,
	KeyTypesBasicEventElement,
	KeyTypesBlob,
	KeyTypesCapability,
	KeyTypesConceptDescription,
	KeyTypesDataElement,
	KeyTypesEntity,
	KeyTypesEventElement,
	KeyTypesFile,
	KeyTypesFragmentReference,
	KeyTypesGlobalReference,
	KeyTypesIdentifiable,
	KeyTypesMultiLanguageProperty,
	KeyTypesOperation,
	KeyTypesProperty,
	KeyTypesRange,
	KeyTypesReferable,
	KeyTypesReferenceElement,
	KeyTypesRelationshipElement,
	KeyTypesSubmodel,
	KeyTypesSubmodelElement,
	KeyTypesSubmodelElementCollection,
	KeyTypesSubmodelElementList,
}

// Enumeration listing all XSD anySimpleTypes
type DataTypeDefXSD int;const (
	DataTypeDefXSDAnyURI DataTypeDefXSD = iota
	DataTypeDefXSDBase64Binary
	DataTypeDefXSDBoolean
	DataTypeDefXSDByte
	DataTypeDefXSDDate
	DataTypeDefXSDDateTime
	DataTypeDefXSDDecimal
	DataTypeDefXSDDouble
	DataTypeDefXSDDuration
	DataTypeDefXSDFloat
	DataTypeDefXSDGDay
	DataTypeDefXSDGMonth
	DataTypeDefXSDGMonthDay
	DataTypeDefXSDGYear
	DataTypeDefXSDGYearMonth
	DataTypeDefXSDHexBinary
	DataTypeDefXSDInt
	DataTypeDefXSDInteger
	DataTypeDefXSDLong
	DataTypeDefXSDNegativeInteger
	DataTypeDefXSDNonNegativeInteger
	DataTypeDefXSDNonPositiveInteger
	DataTypeDefXSDPositiveInteger
	DataTypeDefXSDShort
	DataTypeDefXSDString
	DataTypeDefXSDTime
	DataTypeDefXSDUnsignedByte
	DataTypeDefXSDUnsignedInt
	DataTypeDefXSDUnsignedLong
	DataTypeDefXSDUnsignedShort
)

// List the literals of [DataTypeDefXSD].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfDataTypeDefXSD = [...]DataTypeDefXSD {
	DataTypeDefXSDAnyURI,
	DataTypeDefXSDBase64Binary,
	DataTypeDefXSDBoolean,
	DataTypeDefXSDByte,
	DataTypeDefXSDDate,
	DataTypeDefXSDDateTime,
	DataTypeDefXSDDecimal,
	DataTypeDefXSDDouble,
	DataTypeDefXSDDuration,
	DataTypeDefXSDFloat,
	DataTypeDefXSDGDay,
	DataTypeDefXSDGMonth,
	DataTypeDefXSDGMonthDay,
	DataTypeDefXSDGYear,
	DataTypeDefXSDGYearMonth,
	DataTypeDefXSDHexBinary,
	DataTypeDefXSDInt,
	DataTypeDefXSDInteger,
	DataTypeDefXSDLong,
	DataTypeDefXSDNegativeInteger,
	DataTypeDefXSDNonNegativeInteger,
	DataTypeDefXSDNonPositiveInteger,
	DataTypeDefXSDPositiveInteger,
	DataTypeDefXSDShort,
	DataTypeDefXSDString,
	DataTypeDefXSDTime,
	DataTypeDefXSDUnsignedByte,
	DataTypeDefXSDUnsignedInt,
	DataTypeDefXSDUnsignedLong,
	DataTypeDefXSDUnsignedShort,
}

// Strings with language tags
type IAbstractLangString interface {
	IClass

	// Language tag conforming to BCP 47
	Language() string;

	SetLanguage(
		value string,
	);

	// Text in the [IAbstractLangString.Language]
	Text() string;

	SetText(
		value string,
	);
}

// Check whether the instance corresponds to [aastypes.IAbstractLangString]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsAbstractLangString(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeLangStringNameType:
		ok = true
	case ModelTypeLangStringTextType:
		ok = true
	case ModelTypeLangStringPreferredNameTypeIEC61360:
		ok = true
	case ModelTypeLangStringShortNameTypeIEC61360:
		ok = true
	case ModelTypeLangStringDefinitionTypeIEC61360:
		ok = true
	}
	return
}

// String with length 128 maximum and minimum 1 characters and with language tags
type ILangStringNameType interface {
	IAbstractLangString
}

// Check whether the instance corresponds to [aastypes.ILangStringNameType]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsLangStringNameType(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeLangStringNameType
	return
}

// Implements ILangStringNameType.
type LangStringNameType struct {
	language string
	text string
}

func (lsnt *LangStringNameType) Language(
) string {
	return lsnt.language
}

func (lsnt *LangStringNameType) SetLanguage(
	value string,
) {
	lsnt.language = value
}

func (lsnt *LangStringNameType) Text(
) string {
	return lsnt.text
}

func (lsnt *LangStringNameType) SetText(
	value string,
) {
	lsnt.text = value
}

func (lsnt *LangStringNameType) ModelType(
) ModelType {
	return ModelTypeLangStringNameType
}

// Apply the action on the instances referenced from lsnt.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on lsnt.
func (lsnt *LangStringNameType) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from lsnt.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on lsnt.
func (lsnt *LangStringNameType) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of LangStringNameType with
// the given properties.
func NewLangStringNameType(
	language string,
	text string,
) *LangStringNameType {
	return &LangStringNameType{
		language: language,
		text: text,
	}
}

// String with length 1023 maximum and minimum 1 characters and with language tags
type ILangStringTextType interface {
	IAbstractLangString
}

// Check whether the instance corresponds to [aastypes.ILangStringTextType]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsLangStringTextType(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeLangStringTextType
	return
}

// Implements ILangStringTextType.
type LangStringTextType struct {
	language string
	text string
}

func (lstt *LangStringTextType) Language(
) string {
	return lstt.language
}

func (lstt *LangStringTextType) SetLanguage(
	value string,
) {
	lstt.language = value
}

func (lstt *LangStringTextType) Text(
) string {
	return lstt.text
}

func (lstt *LangStringTextType) SetText(
	value string,
) {
	lstt.text = value
}

func (lstt *LangStringTextType) ModelType(
) ModelType {
	return ModelTypeLangStringTextType
}

// Apply the action on the instances referenced from lstt.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on lstt.
func (lstt *LangStringTextType) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from lstt.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on lstt.
func (lstt *LangStringTextType) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of LangStringTextType with
// the given properties.
func NewLangStringTextType(
	language string,
	text string,
) *LangStringTextType {
	return &LangStringTextType{
		language: language,
		text: text,
	}
}

// Container for the sets of different identifiables.
//
// NOTE: w.r.t. file exchange: There is exactly one environment independent on how many
// files the contained elements are split. If the file is split then there
// shall be no element with the same identifier in two different files.
type IEnvironment interface {
	IClass

	// Asset administration shell
	AssetAdministrationShells() []IAssetAdministrationShell;

	SetAssetAdministrationShells(
		value []IAssetAdministrationShell,
	);

	// Submodel
	Submodels() []ISubmodel;

	SetSubmodels(
		value []ISubmodel,
	);

	// Concept description
	ConceptDescriptions() []IConceptDescription;

	SetConceptDescriptions(
		value []IConceptDescription,
	);
}

// Check whether the instance corresponds to [aastypes.IEnvironment]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsEnvironment(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeEnvironment
	return
}

// Implements IEnvironment.
type Environment struct {
	assetAdministrationShells []IAssetAdministrationShell
	submodels []ISubmodel
	conceptDescriptions []IConceptDescription
}

func (e *Environment) AssetAdministrationShells(
) []IAssetAdministrationShell {
	return e.assetAdministrationShells
}

func (e *Environment) SetAssetAdministrationShells(
	value []IAssetAdministrationShell,
) {
	e.assetAdministrationShells = value
}

func (e *Environment) Submodels(
) []ISubmodel {
	return e.submodels
}

func (e *Environment) SetSubmodels(
	value []ISubmodel,
) {
	e.submodels = value
}

func (e *Environment) ConceptDescriptions(
) []IConceptDescription {
	return e.conceptDescriptions
}

func (e *Environment) SetConceptDescriptions(
	value []IConceptDescription,
) {
	e.conceptDescriptions = value
}

func (e *Environment) ModelType(
) ModelType {
	return ModelTypeEnvironment
}

// Apply the action on the instances referenced from e.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on e.
func (e *Environment) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	if e.assetAdministrationShells != nil {
		for _, v := range e.assetAdministrationShells {
			abort = action(v);
			if abort {
				return
			}
		}
	}

	if e.submodels != nil {
		for _, v1 := range e.submodels {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if e.conceptDescriptions != nil {
		for _, v2 := range e.conceptDescriptions {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	return
}

// Apply the action recursively on the instances referenced from e.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on e.
func (e *Environment) Descend(
	action func(IClass) bool,
) (abort bool) {
	if e.assetAdministrationShells != nil {
		for _, v := range e.assetAdministrationShells {
			abort = action(v);
			if abort {
				return
			}

			abort = v.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.submodels != nil {
		for _, v1 := range e.submodels {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if e.conceptDescriptions != nil {
		for _, v2 := range e.conceptDescriptions {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	return
}

// Create a new instance of Environment with
// the given properties.
func NewEnvironment() *Environment {
	return &Environment{
		assetAdministrationShells: nil,
		submodels: nil,
		conceptDescriptions: nil,
	}
}

// Data specification content is part of a data specification template and defines
// which additional attributes shall be added to the element instance that references
// the data specification template and meta information about the template itself.
//
// Constraint AASc-3a-050:
// If the [IDataSpecificationIEC61360] is used
// for an element, the value of
// [IHasDataSpecification.EmbeddedDataSpecifications]
// shall contain the global reference to the IRI of the corresponding
// data specification template
// https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0
type IDataSpecificationContent interface {
	IClass
}

// Check whether the instance corresponds to [aastypes.IDataSpecificationContent]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsDataSpecificationContent(
	that IClass,
) (ok bool) {
	switch that.ModelType() {
	case ModelTypeDataSpecificationIEC61360:
		ok = true
	}
	return
}

// Embed the content of a data specification.
type IEmbeddedDataSpecification interface {
	IClass

	// Actual content of the data specification
	DataSpecificationContent() IDataSpecificationContent;

	SetDataSpecificationContent(
		value IDataSpecificationContent,
	);

	// Reference to the data specification
	DataSpecification() IReference;

	SetDataSpecification(
		value IReference,
	);
}

// Check whether the instance corresponds to [aastypes.IEmbeddedDataSpecification]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsEmbeddedDataSpecification(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeEmbeddedDataSpecification
	return
}

// Implements IEmbeddedDataSpecification.
type EmbeddedDataSpecification struct {
	dataSpecificationContent IDataSpecificationContent
	dataSpecification IReference
}

func (eds *EmbeddedDataSpecification) DataSpecificationContent(
) IDataSpecificationContent {
	return eds.dataSpecificationContent
}

func (eds *EmbeddedDataSpecification) SetDataSpecificationContent(
	value IDataSpecificationContent,
) {
	eds.dataSpecificationContent = value
}

func (eds *EmbeddedDataSpecification) DataSpecification(
) IReference {
	return eds.dataSpecification
}

func (eds *EmbeddedDataSpecification) SetDataSpecification(
	value IReference,
) {
	eds.dataSpecification = value
}

func (eds *EmbeddedDataSpecification) ModelType(
) ModelType {
	return ModelTypeEmbeddedDataSpecification
}

// Apply the action on the instances referenced from eds.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on eds.
func (eds *EmbeddedDataSpecification) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		eds.dataSpecificationContent,
	)
	if abort {
		return
	}

	abort = action(
		eds.dataSpecification,
	)
	if abort {
		return
	}

	return
}

// Apply the action recursively on the instances referenced from eds.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on eds.
func (eds *EmbeddedDataSpecification) Descend(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		eds.dataSpecificationContent,
	)
	if abort {
		return
	}
	abort = eds.dataSpecificationContent.Descend(
		action,
	)
	if abort {
		return
	}

	abort = action(
		eds.dataSpecification,
	)
	if abort {
		return
	}
	abort = eds.dataSpecification.Descend(
		action,
	)
	if abort {
		return
	}

	return
}

// Create a new instance of EmbeddedDataSpecification with
// the given properties.
func NewEmbeddedDataSpecification(
	dataSpecificationContent IDataSpecificationContent,
	dataSpecification IReference,
) *EmbeddedDataSpecification {
	return &EmbeddedDataSpecification{
		dataSpecificationContent: dataSpecificationContent,
		dataSpecification: dataSpecification,
	}
}

type DataTypeIEC61360 int;const (
	// values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
	// Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
	// "31 May 1999".
	DataTypeIEC61360Date DataTypeIEC61360 = iota
	// values consisting of sequence of characters but cannot be translated into other
	// languages
	DataTypeIEC61360String
	// values containing string but shall be represented as different string in different
	// languages
	DataTypeIEC61360StringTranslatable
	// values containing values that are measure of type INTEGER. In addition such a value
	// comes with a physical unit.
	DataTypeIEC61360IntegerMeasure
	// values containing values of type INTEGER but are no currencies or measures
	DataTypeIEC61360IntegerCount
	// values containing values of type INTEGER that are currencies
	DataTypeIEC61360IntegerCurrency
	// values containing values that are measures of type REAL. In addition such a value
	// comes with a physical unit.
	DataTypeIEC61360RealMeasure
	// values containing numbers that can be written as a terminating or non-terminating
	// decimal; a rational or irrational number but are no currencies or measures
	DataTypeIEC61360RealCount
	// values containing values of type REAL that are currencies
	DataTypeIEC61360RealCurrency
	// values representing truth of logic or Boolean algebra (TRUE, FALSE)
	DataTypeIEC61360Boolean
	// values containing values of type STRING conformant to Rfc 3987
	//
	// NOTE: In IEC61360-1 (2017) only URI is supported.
	// An IRI type allows in particular to express an URL or an URI.
	DataTypeIEC61360IRI
	// values conforming to ISO/IEC 11179 series global identifier sequences
	//
	// IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.
	//
	// ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
	// is “#” while the delimiter between DI and VI is confined to “##”
	//
	// ISO29002_IRDI values are values containing a global identifier that identifies an
	// administrated item in a registry. The structure of this identifier complies with
	// identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
	// requirements specified in ISO/TS 29002-5 for an "international registration data
	// identifier" (IRDI).
	DataTypeIEC61360IRDI
	// values containing values of type rational
	DataTypeIEC61360Rational
	// values containing values of type rational. In addition such a value comes with a
	// physical unit.
	DataTypeIEC61360RationalMeasure
	// values containing a time, conformant to ISO 8601:2004 but restricted to what is
	// allowed in the corresponding type in xml.
	//
	// Format hh:mm (ECLASS)
	//
	// Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
	// 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
	// Universal Time (UTC).
	DataTypeIEC61360Time
	// values containing a time, conformant to ISO 8601:2004 but restricted to what is
	// allowed in the corresponding type in xml.
	//
	// Format yyyy-mm-dd hh:mm (ECLASS)
	DataTypeIEC61360Timestamp
	// values containing an address to a file. The values are of type URI and can represent
	// an absolute or relative path.
	//
	// NOTE: IEC61360 does not support the file type.
	DataTypeIEC61360File
	// Values containing string with any sequence of characters, using the syntax of HTML5
	// (see W3C Recommendation 28:2014)
	DataTypeIEC61360HTML
	// values containing the content of a file. Values may be binaries.
	//
	// HTML conformant to HTML5 is a special blob.
	//
	// In IEC61360 binary is for a sequence of bits, each bit being represented by “0” and
	// “1” only. A binary is a blob but a blob may also contain other source code.
	DataTypeIEC61360Blob
)

// List the literals of [DataTypeIEC61360].
//
// Golang does not provide an elegant way to iterate over the literals, so
// this array helps you avoid common errors and pitfalls.
//
// Please do not modify the array in the caller's code.
var LiteralsOfDataTypeIEC61360 = [...]DataTypeIEC61360 {
	DataTypeIEC61360Date,
	DataTypeIEC61360String,
	DataTypeIEC61360StringTranslatable,
	DataTypeIEC61360IntegerMeasure,
	DataTypeIEC61360IntegerCount,
	DataTypeIEC61360IntegerCurrency,
	DataTypeIEC61360RealMeasure,
	DataTypeIEC61360RealCount,
	DataTypeIEC61360RealCurrency,
	DataTypeIEC61360Boolean,
	DataTypeIEC61360IRI,
	DataTypeIEC61360IRDI,
	DataTypeIEC61360Rational,
	DataTypeIEC61360RationalMeasure,
	DataTypeIEC61360Time,
	DataTypeIEC61360Timestamp,
	DataTypeIEC61360File,
	DataTypeIEC61360HTML,
	DataTypeIEC61360Blob,
}

// Value represented by up to four variants of a numeric value in a specific role:
// `MIN`, `NOM`, `TYP` and `MAX`. True means that the value is available,
// false means the value is not available.
//
// EXAMPLE from [IEC61360-1]: In the case of having a property which is
// of the LEVEL_TYPE min/max − expressing a range − only those two values
// need to be provided.
//
// NOTE: This is how AAS deals with the following combinations of level types:
//
//   • Either all attributes are false. In this case the concept is mapped
//     to a [IProperty] and level type is ignored.
//   • At most one of the attributes is set to true. In this case
//     the concept is mapped to a [IProperty].
//   • Min and max are set to true. In this case the concept is mapped
//     to a [IRange].
//   • More than one attribute is set to true but not min and max only
//     (see second case). In this case the concept is mapped
//     to a [ISubmodelElementCollection] with the corresponding
//     number of Properties.
//     Example: If attribute [ILevelType.Min] and [ILevelType.Nom] are set to true
//     then the concept is mapped to a [ISubmodelElementCollection]
//     with two Properties within: min and nom.
//     The data type of both Properties is the same.
//
// NOTE: In the cases 2. and 4. the [IProperty.SemanticID] of the Property
// or Properties within the [ISubmodelElementCollection] needs to include
// information about the level type. Otherwise, the semantics is not described
// in a unique way. Please refer to the specification.
type ILevelType interface {
	IClass

	// Minimum of the value
	Min() bool;

	SetMin(
		value bool,
	);

	// Nominal value (value as designated)
	Nom() bool;

	SetNom(
		value bool,
	);

	// Value as typically present
	Typ() bool;

	SetTyp(
		value bool,
	);

	// Maximum of the value
	Max() bool;

	SetMax(
		value bool,
	);
}

// Check whether the instance corresponds to [aastypes.ILevelType]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsLevelType(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeLevelType
	return
}

// Implements ILevelType.
type LevelType struct {
	min bool
	nom bool
	typ bool
	max bool
}

func (lt *LevelType) Min(
) bool {
	return lt.min
}

func (lt *LevelType) SetMin(
	value bool,
) {
	lt.min = value
}

func (lt *LevelType) Nom(
) bool {
	return lt.nom
}

func (lt *LevelType) SetNom(
	value bool,
) {
	lt.nom = value
}

func (lt *LevelType) Typ(
) bool {
	return lt.typ
}

func (lt *LevelType) SetTyp(
	value bool,
) {
	lt.typ = value
}

func (lt *LevelType) Max(
) bool {
	return lt.max
}

func (lt *LevelType) SetMax(
	value bool,
) {
	lt.max = value
}

func (lt *LevelType) ModelType(
) ModelType {
	return ModelTypeLevelType
}

// Apply the action on the instances referenced from lt.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on lt.
func (lt *LevelType) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from lt.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on lt.
func (lt *LevelType) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of LevelType with
// the given properties.
func NewLevelType(
	min bool,
	nom bool,
	typ bool,
	max bool,
) *LevelType {
	return &LevelType{
		min: min,
		nom: nom,
		typ: typ,
		max: max,
	}
}

// A value reference pair within a value list. Each value has a global unique id
// defining its semantic.
type IValueReferencePair interface {
	IClass

	// The value of the referenced concept definition of the value in [IValueReferencePair.ValueID].
	Value() string;

	SetValue(
		value string,
	);

	// Global unique id of the value.
	//
	// NOTE: It is recommended to use a global reference.
	ValueID() IReference;

	SetValueID(
		value IReference,
	);
}

// Check whether the instance corresponds to [aastypes.IValueReferencePair]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsValueReferencePair(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeValueReferencePair
	return
}

// Implements IValueReferencePair.
type ValueReferencePair struct {
	value string
	valueID IReference
}

func (vrp *ValueReferencePair) Value(
) string {
	return vrp.value
}

func (vrp *ValueReferencePair) SetValue(
	value string,
) {
	vrp.value = value
}

func (vrp *ValueReferencePair) ValueID(
) IReference {
	return vrp.valueID
}

func (vrp *ValueReferencePair) SetValueID(
	value IReference,
) {
	vrp.valueID = value
}

func (vrp *ValueReferencePair) ModelType(
) ModelType {
	return ModelTypeValueReferencePair
}

// Apply the action on the instances referenced from vrp.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on vrp.
func (vrp *ValueReferencePair) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		vrp.valueID,
	)
	if abort {
		return
	}

	return
}

// Apply the action recursively on the instances referenced from vrp.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on vrp.
func (vrp *ValueReferencePair) Descend(
	action func(IClass) bool,
) (abort bool) {
	abort = action(
		vrp.valueID,
	)
	if abort {
		return
	}
	abort = vrp.valueID.Descend(
		action,
	)
	if abort {
		return
	}

	return
}

// Create a new instance of ValueReferencePair with
// the given properties.
func NewValueReferencePair(
	value string,
	valueID IReference,
) *ValueReferencePair {
	return &ValueReferencePair{
		value: value,
		valueID: valueID,
	}
}

// A set of value reference pairs.
type IValueList interface {
	IClass

	// A pair of a value together with its global unique id.
	ValueReferencePairs() []IValueReferencePair;

	SetValueReferencePairs(
		value []IValueReferencePair,
	);
}

// Check whether the instance corresponds to [aastypes.IValueList]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsValueList(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeValueList
	return
}

// Implements IValueList.
type ValueList struct {
	valueReferencePairs []IValueReferencePair
}

func (vl *ValueList) ValueReferencePairs(
) []IValueReferencePair {
	return vl.valueReferencePairs
}

func (vl *ValueList) SetValueReferencePairs(
	value []IValueReferencePair,
) {
	vl.valueReferencePairs = value
}

func (vl *ValueList) ModelType(
) ModelType {
	return ModelTypeValueList
}

// Apply the action on the instances referenced from vl.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on vl.
func (vl *ValueList) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	for _, v := range vl.valueReferencePairs {
		abort = action(v);
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from vl.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on vl.
func (vl *ValueList) Descend(
	action func(IClass) bool,
) (abort bool) {
	for _, v := range vl.valueReferencePairs {
		abort = action(v);
		if abort {
			return
		}

		abort = v.Descend(
			action,
		);
		if abort {
			return
		}
	}

	return
}

// Create a new instance of ValueList with
// the given properties.
func NewValueList(
	valueReferencePairs []IValueReferencePair,
) *ValueList {
	return &ValueList{
		valueReferencePairs: valueReferencePairs,
	}
}

// String with length 255 maximum and minimum 1 characters and with language tags
//
// NOTE: It is advised to keep the length of the name limited to 35 characters.
type ILangStringPreferredNameTypeIEC61360 interface {
	IAbstractLangString
}

// Check whether the instance corresponds to [aastypes.ILangStringPreferredNameTypeIEC61360]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsLangStringPreferredNameTypeIEC61360(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeLangStringPreferredNameTypeIEC61360
	return
}

// Implements ILangStringPreferredNameTypeIEC61360.
type LangStringPreferredNameTypeIEC61360 struct {
	language string
	text string
}

func (lspnti6 *LangStringPreferredNameTypeIEC61360) Language(
) string {
	return lspnti6.language
}

func (lspnti6 *LangStringPreferredNameTypeIEC61360) SetLanguage(
	value string,
) {
	lspnti6.language = value
}

func (lspnti6 *LangStringPreferredNameTypeIEC61360) Text(
) string {
	return lspnti6.text
}

func (lspnti6 *LangStringPreferredNameTypeIEC61360) SetText(
	value string,
) {
	lspnti6.text = value
}

func (lspnti6 *LangStringPreferredNameTypeIEC61360) ModelType(
) ModelType {
	return ModelTypeLangStringPreferredNameTypeIEC61360
}

// Apply the action on the instances referenced from lspnti6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on lspnti6.
func (lspnti6 *LangStringPreferredNameTypeIEC61360) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from lspnti6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on lspnti6.
func (lspnti6 *LangStringPreferredNameTypeIEC61360) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of LangStringPreferredNameTypeIEC61360 with
// the given properties.
func NewLangStringPreferredNameTypeIEC61360(
	language string,
	text string,
) *LangStringPreferredNameTypeIEC61360 {
	return &LangStringPreferredNameTypeIEC61360{
		language: language,
		text: text,
	}
}

// String with length 18 maximum and minimum 1 characters and with language tags
type ILangStringShortNameTypeIEC61360 interface {
	IAbstractLangString
}

// Check whether the instance corresponds to [aastypes.ILangStringShortNameTypeIEC61360]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsLangStringShortNameTypeIEC61360(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeLangStringShortNameTypeIEC61360
	return
}

// Implements ILangStringShortNameTypeIEC61360.
type LangStringShortNameTypeIEC61360 struct {
	language string
	text string
}

func (lssnti6 *LangStringShortNameTypeIEC61360) Language(
) string {
	return lssnti6.language
}

func (lssnti6 *LangStringShortNameTypeIEC61360) SetLanguage(
	value string,
) {
	lssnti6.language = value
}

func (lssnti6 *LangStringShortNameTypeIEC61360) Text(
) string {
	return lssnti6.text
}

func (lssnti6 *LangStringShortNameTypeIEC61360) SetText(
	value string,
) {
	lssnti6.text = value
}

func (lssnti6 *LangStringShortNameTypeIEC61360) ModelType(
) ModelType {
	return ModelTypeLangStringShortNameTypeIEC61360
}

// Apply the action on the instances referenced from lssnti6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on lssnti6.
func (lssnti6 *LangStringShortNameTypeIEC61360) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from lssnti6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on lssnti6.
func (lssnti6 *LangStringShortNameTypeIEC61360) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of LangStringShortNameTypeIEC61360 with
// the given properties.
func NewLangStringShortNameTypeIEC61360(
	language string,
	text string,
) *LangStringShortNameTypeIEC61360 {
	return &LangStringShortNameTypeIEC61360{
		language: language,
		text: text,
	}
}

// String with length 1023 maximum and minimum 1 characters and with language tags
type ILangStringDefinitionTypeIEC61360 interface {
	IAbstractLangString
}

// Check whether the instance corresponds to [aastypes.ILangStringDefinitionTypeIEC61360]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsLangStringDefinitionTypeIEC61360(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeLangStringDefinitionTypeIEC61360
	return
}

// Implements ILangStringDefinitionTypeIEC61360.
type LangStringDefinitionTypeIEC61360 struct {
	language string
	text string
}

func (lsdti6 *LangStringDefinitionTypeIEC61360) Language(
) string {
	return lsdti6.language
}

func (lsdti6 *LangStringDefinitionTypeIEC61360) SetLanguage(
	value string,
) {
	lsdti6.language = value
}

func (lsdti6 *LangStringDefinitionTypeIEC61360) Text(
) string {
	return lsdti6.text
}

func (lsdti6 *LangStringDefinitionTypeIEC61360) SetText(
	value string,
) {
	lsdti6.text = value
}

func (lsdti6 *LangStringDefinitionTypeIEC61360) ModelType(
) ModelType {
	return ModelTypeLangStringDefinitionTypeIEC61360
}

// Apply the action on the instances referenced from lsdti6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on lsdti6.
func (lsdti6 *LangStringDefinitionTypeIEC61360) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Apply the action recursively on the instances referenced from lsdti6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on lsdti6.
func (lsdti6 *LangStringDefinitionTypeIEC61360) Descend(
	action func(IClass) bool,
) (abort bool) {
	// No descendable properties

	return
}

// Create a new instance of LangStringDefinitionTypeIEC61360 with
// the given properties.
func NewLangStringDefinitionTypeIEC61360(
	language string,
	text string,
) *LangStringDefinitionTypeIEC61360 {
	return &LangStringDefinitionTypeIEC61360{
		language: language,
		text: text,
	}
}

// Content of data specification template for concept descriptions for properties,
// values and value lists conformant to IEC 61360.
//
// NOTE: IEC61360 requires also a globally unique identifier for a concept
// description. This ID is not part of the data specification template.
// Instead the [IConceptDescription.ID] as inherited via
// [IIdentifiable] is used. Same holds for administrative
// information like the version and revision.
//
// NOTE: [IConceptDescription.IDShort] and [IDataSpecificationIEC61360.ShortName] are very
// similar. However, in this case the decision was to add
// [IDataSpecificationIEC61360.ShortName] explicitly to the data specification. Same holds for
// [IConceptDescription.DisplayName] and
// [IDataSpecificationIEC61360.PreferredName]. Same holds for
// [IConceptDescription.Description] and [IDataSpecificationIEC61360.Definition].
//
// Constraint AASc-3a-010:
// If [IDataSpecificationIEC61360.Value] is not empty then [IDataSpecificationIEC61360.ValueList] shall be empty
// and vice versa.
//
// NOTE: It is also possible that both [IDataSpecificationIEC61360.Value] and [IDataSpecificationIEC61360.ValueList] are
// empty. This is the case for concept descriptions that define the semantics
// of a property but do not have an enumeration ([IDataSpecificationIEC61360.ValueList]) as
// data type.
//
// NOTE: Although it is possible to define a [IConceptDescription] for a
// :attr:´value_list`,
// it is not possible to reuse this [IDataSpecificationIEC61360.ValueList].
// It is only possible to directly add a [IDataSpecificationIEC61360.ValueList] as data type
// to a specific semantic definition of a property.
//
// Constraint AASc-3a-009:
// If [IDataSpecificationIEC61360.DataType] one of:
// [DataTypeIEC61360IntegerMeasure],
// [DataTypeIEC61360RealMeasure],
// [DataTypeIEC61360RationalMeasure],
// [DataTypeIEC61360IntegerCurrency],
// [DataTypeIEC61360RealCurrency], then [IDataSpecificationIEC61360.Unit] or
// [IDataSpecificationIEC61360.UnitID] shall be defined.
type IDataSpecificationIEC61360 interface {
	IDataSpecificationContent

	// Preferred name
	//
	// NOTE: It is advised to keep the length of the name limited to 35 characters.
	//
	// Constraint AASc-3a-002:
	// [IDataSpecificationIEC61360.PreferredName] shall be provided at least in English.
	PreferredName() []ILangStringPreferredNameTypeIEC61360;

	SetPreferredName(
		value []ILangStringPreferredNameTypeIEC61360,
	);

	// Short name
	ShortName() []ILangStringShortNameTypeIEC61360;

	SetShortName(
		value []ILangStringShortNameTypeIEC61360,
	);

	// Unit
	Unit() *string;

	SetUnit(
		value *string,
	);

	// Unique unit id
	//
	// [IDataSpecificationIEC61360.Unit] and [IDataSpecificationIEC61360.UnitID] need to be consistent if both attributes
	// are set
	//
	// NOTE: It is recommended to use an external reference ID.
	UnitID() IReference;

	SetUnitID(
		value IReference,
	);

	// Source of definition
	SourceOfDefinition() *string;

	SetSourceOfDefinition(
		value *string,
	);

	// Symbol
	Symbol() *string;

	SetSymbol(
		value *string,
	);

	// Data Type
	DataType() *DataTypeIEC61360;

	SetDataType(
		value *DataTypeIEC61360,
	);

	// Definition in different languages
	Definition() []ILangStringDefinitionTypeIEC61360;

	SetDefinition(
		value []ILangStringDefinitionTypeIEC61360,
	);

	// Value Format
	//
	// NOTE: The value format is based on ISO 13584-42 and IEC 61360-2.
	ValueFormat() *string;

	SetValueFormat(
		value *string,
	);

	// List of allowed values
	ValueList() IValueList;

	SetValueList(
		value IValueList,
	);

	// Value
	Value() *string;

	SetValue(
		value *string,
	);

	// Set of levels.
	LevelType() ILevelType;

	SetLevelType(
		value ILevelType,
	);
}

// Check whether the instance corresponds to [aastypes.IDataSpecificationIEC61360]
// based on its run-time model type.
//
// The implementation uses a switch statements which is
// most probably compiled as an efficient jump table by the compiler.
func IsDataSpecificationIEC61360(
	that IClass,
) (ok bool) {
	ok = that.ModelType() == ModelTypeDataSpecificationIEC61360
	return
}

// Implements IDataSpecificationIEC61360.
type DataSpecificationIEC61360 struct {
	preferredName []ILangStringPreferredNameTypeIEC61360
	shortName []ILangStringShortNameTypeIEC61360
	unit *string
	unitID IReference
	sourceOfDefinition *string
	symbol *string
	dataType *DataTypeIEC61360
	definition []ILangStringDefinitionTypeIEC61360
	valueFormat *string
	valueList IValueList
	value *string
	levelType ILevelType
}

func (dsi6 *DataSpecificationIEC61360) PreferredName(
) []ILangStringPreferredNameTypeIEC61360 {
	return dsi6.preferredName
}

func (dsi6 *DataSpecificationIEC61360) SetPreferredName(
	value []ILangStringPreferredNameTypeIEC61360,
) {
	dsi6.preferredName = value
}

func (dsi6 *DataSpecificationIEC61360) ShortName(
) []ILangStringShortNameTypeIEC61360 {
	return dsi6.shortName
}

func (dsi6 *DataSpecificationIEC61360) SetShortName(
	value []ILangStringShortNameTypeIEC61360,
) {
	dsi6.shortName = value
}

func (dsi6 *DataSpecificationIEC61360) Unit(
) *string {
	return dsi6.unit
}

func (dsi6 *DataSpecificationIEC61360) SetUnit(
	value *string,
) {
	dsi6.unit = value
}

func (dsi6 *DataSpecificationIEC61360) UnitID(
) IReference {
	return dsi6.unitID
}

func (dsi6 *DataSpecificationIEC61360) SetUnitID(
	value IReference,
) {
	dsi6.unitID = value
}

func (dsi6 *DataSpecificationIEC61360) SourceOfDefinition(
) *string {
	return dsi6.sourceOfDefinition
}

func (dsi6 *DataSpecificationIEC61360) SetSourceOfDefinition(
	value *string,
) {
	dsi6.sourceOfDefinition = value
}

func (dsi6 *DataSpecificationIEC61360) Symbol(
) *string {
	return dsi6.symbol
}

func (dsi6 *DataSpecificationIEC61360) SetSymbol(
	value *string,
) {
	dsi6.symbol = value
}

func (dsi6 *DataSpecificationIEC61360) DataType(
) *DataTypeIEC61360 {
	return dsi6.dataType
}

func (dsi6 *DataSpecificationIEC61360) SetDataType(
	value *DataTypeIEC61360,
) {
	dsi6.dataType = value
}

func (dsi6 *DataSpecificationIEC61360) Definition(
) []ILangStringDefinitionTypeIEC61360 {
	return dsi6.definition
}

func (dsi6 *DataSpecificationIEC61360) SetDefinition(
	value []ILangStringDefinitionTypeIEC61360,
) {
	dsi6.definition = value
}

func (dsi6 *DataSpecificationIEC61360) ValueFormat(
) *string {
	return dsi6.valueFormat
}

func (dsi6 *DataSpecificationIEC61360) SetValueFormat(
	value *string,
) {
	dsi6.valueFormat = value
}

func (dsi6 *DataSpecificationIEC61360) ValueList(
) IValueList {
	return dsi6.valueList
}

func (dsi6 *DataSpecificationIEC61360) SetValueList(
	value IValueList,
) {
	dsi6.valueList = value
}

func (dsi6 *DataSpecificationIEC61360) Value(
) *string {
	return dsi6.value
}

func (dsi6 *DataSpecificationIEC61360) SetValue(
	value *string,
) {
	dsi6.value = value
}

func (dsi6 *DataSpecificationIEC61360) LevelType(
) ILevelType {
	return dsi6.levelType
}

func (dsi6 *DataSpecificationIEC61360) SetLevelType(
	value ILevelType,
) {
	dsi6.levelType = value
}

func (dsi6 *DataSpecificationIEC61360) ModelType(
) ModelType {
	return ModelTypeDataSpecificationIEC61360
}

// Apply the action on the instances referenced from dsi6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// We do not recurse into the referenced instances.
//
// The action is not applied on dsi6.
func (dsi6 *DataSpecificationIEC61360) DescendOnce(
	action func(IClass) bool,
) (abort bool) {
	for _, v := range dsi6.preferredName {
		abort = action(v);
		if abort {
			return
		}
	}

	if dsi6.shortName != nil {
		for _, v1 := range dsi6.shortName {
			abort = action(v1);
			if abort {
				return
			}
		}
	}

	if dsi6.unitID != nil {
		abort = action(
			dsi6.unitID,
		)
		if abort {
			return
		}
	}

	if dsi6.definition != nil {
		for _, v2 := range dsi6.definition {
			abort = action(v2);
			if abort {
				return
			}
		}
	}

	if dsi6.valueList != nil {
		abort = action(
			dsi6.valueList,
		)
		if abort {
			return
		}
	}

	if dsi6.levelType != nil {
		abort = action(
			dsi6.levelType,
		)
		if abort {
			return
		}
	}

	return
}

// Apply the action recursively on the instances referenced from dsi6.
//
// If any of the actions returns abort `true`, the descent is immediately
// stopped,  and abort `true` is also returned. Otherwise, return abort `false`.
//
// The action is not applied on dsi6.
func (dsi6 *DataSpecificationIEC61360) Descend(
	action func(IClass) bool,
) (abort bool) {
	for _, v := range dsi6.preferredName {
		abort = action(v);
		if abort {
			return
		}

		abort = v.Descend(
			action,
		);
		if abort {
			return
		}
	}

	if dsi6.shortName != nil {
		for _, v1 := range dsi6.shortName {
			abort = action(v1);
			if abort {
				return
			}

			abort = v1.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if dsi6.unitID != nil {
		abort = action(
			dsi6.unitID,
		)
		if abort {
			return
		}
		abort = dsi6.unitID.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if dsi6.definition != nil {
		for _, v2 := range dsi6.definition {
			abort = action(v2);
			if abort {
				return
			}

			abort = v2.Descend(
				action,
			);
			if abort {
				return
			}
		}
	}

	if dsi6.valueList != nil {
		abort = action(
			dsi6.valueList,
		)
		if abort {
			return
		}
		abort = dsi6.valueList.Descend(
			action,
		)
		if abort {
			return
		}
	}

	if dsi6.levelType != nil {
		abort = action(
			dsi6.levelType,
		)
		if abort {
			return
		}
		abort = dsi6.levelType.Descend(
			action,
		)
		if abort {
			return
		}
	}

	return
}

// Create a new instance of DataSpecificationIEC61360 with
// the given properties.
func NewDataSpecificationIEC61360(
	preferredName []ILangStringPreferredNameTypeIEC61360,
) *DataSpecificationIEC61360 {
	return &DataSpecificationIEC61360{
		preferredName: preferredName,
		shortName: nil,
		unit: nil,
		unitID: nil,
		sourceOfDefinition: nil,
		symbol: nil,
		dataType: nil,
		definition: nil,
		valueFormat: nil,
		valueList: nil,
		value: nil,
		levelType: nil,
	}
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
