// Package xmlization de/serializes model instances to and from XML.
//
// To de-serialize, call one of the `Unmarshal*` functions.
//
// To serialize, call the [Marshal] function.
package xmlization

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	b64 "encoding/base64"
	"encoding/xml"
	"fmt"
	"io"
	"math"
	"strconv"
	"strings"
	"unicode"
	aasreporting "github.com/aas-core-works/aas-core3.0-golang/reporting"
	aasstringification "github.com/aas-core-works/aas-core3.0-golang/stringification"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
	aasverification "github.com/aas-core-works/aas-core3.0-golang/verification"
)

// region De-serialization

// Represent an error during the de-serialization.
//
// Implements `error`.
type DeserializationError struct{
	Path *aasreporting.Path
	Message string
}

func newDeserializationError(message string) *DeserializationError {
	return &DeserializationError{
		Path: &aasreporting.Path{},
		Message: message,
	}
}

func (de *DeserializationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		de.PathString(),
		de.Message,
	)
}

// Render the path as a string.
func (de *DeserializationError) PathString() string {
	return aasreporting.ToRelativeXPath(de.Path)
}

// This is class for a sentinel token to signal the end-of-file.
type eof struct{}

// Check if the string `s` consists only of whitespace.
//
// An empty string causes panic â€” please cover that case before.
func isWhitespace(s string) bool {
	if len(s) == 0 {
		panic("Unexpected empty string")
	}
	for _, c := range s {
		if !unicode.IsSpace(c) {
			return false
		}
	}
	return true
}

// Read the next token from the `decoder` given the `current` token.
//
// If `current` token is [eof], return [eof].
func readNext(decoder *xml.Decoder, current xml.Token) (next xml.Token, err error) {
	if _, isEOF := current.(eof); isEOF {
		next = current
		return
	}

	var tokenErr error
	next, tokenErr = decoder.Token()
	if tokenErr != nil {
		if tokenErr == io.EOF {
			next = &eof{}
			return
		}

		err = tokenErr
		return
	}

	return
}

// Read all the possible whitespace and comments.
//
// Return the `next` token which is neither empty text, nor whitespace nor comment,
// or [eof], if we reached the end-of-file.
//
// If we already reached the end-of-file, simply return [eof].
func skipEmptyTextWhitespaceAndComments(
	decoder *xml.Decoder,
	current xml.Token,
) (next xml.Token, err error) {
	stop := false
	for !stop {
		if _, isEOF := current.(eof); isEOF {
			break
		}

		switch et := current.(type) {
		case xml.CharData:
			text := string(et)
			if len(text) != 0 && !isWhitespace(text) {
				stop = true
			} else {
				// We should proceed to the next token.
			}
		case xml.Comment:
			// We should proceed to the next token.
		default:
			stop = true
		}

		if !stop {
			current, err = readNext(decoder, current)
			if err != nil {
				return
			}
		}
	}

	next = current
	return
}

// Consume the text tokens (char data).
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readText(
	decoder *xml.Decoder,
	current xml.Token,
) (text string, next xml.Token, err error) {
	b := &strings.Builder{}

	stop := false
	for {
		if _, isEOF := current.(eof); isEOF {
			err = newDeserializationError(
				"Expected to read text, but reached the end-of-file",
			)
			return
		}

		switch et := current.(type) {
		case xml.CharData:
			b.WriteString(string(et))
			// Proceed to the next token.
		case xml.Comment:
			// Proceed to the next token.
		default:
			stop = true
		}

		if !stop {
			current, err = readNext(decoder, current)
			if err != nil {
				return
			}
		} else {
			break
		}
	}

	next = current
	text = b.String()
	return
}

// Consume the text tokens (char data) as a representation of a `xs:boolean`.
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsBoolean(
	decoder *xml.Decoder,
	current xml.Token,
) (value bool, next xml.Token, err error) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	switch text {
	case "1":
		value = true
	case "true":
		value = true
	case "0":
		value = false
	case "false":
		value = false
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a value as xs:boolean, but got: %s",
				text,
			),
		)
	}
	if err != nil {
		return
	}

	return
}

// Consume the text tokens (char data) as a representation of a `xs:long`.
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsLong(
	decoder *xml.Decoder,
	current xml.Token,
) (value int64, next xml.Token, err error) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	value, err = strconv.ParseInt(text, 10, 64)

	return
}

// Consume the text tokens (char data) as a representation of a `xs:double`.
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsDouble(
	decoder *xml.Decoder,
	current xml.Token,
) (value float64, next xml.Token, err error) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	// We need to check explicitly for the regular expression since
	// strconv.ParseFloat is too permissive. For example, it accepts "nan"
	// although only "NaN" is valid.
	// See: https://www.w3.org/TR/xmlschema-2/#double
	if !aasverification.MatchesXsDouble(text) {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a value as xs:double, but got: %s",
				text,
			),
		)
		return
	}

	var parseErr error
	value, parseErr = strconv.ParseFloat(text, 64)
	if parseErr != nil {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a value as xs:double, but it could not be parsed: %s: %s",
				parseErr.Error(), text,
			),
		)
		return
	}

	// NOTE (2023-06-14):
	// We explicitly do not check for loss of precision, as the majority of people will
	// use string representation of the floating point numbers ignoring the precision
	// issues. For example, the closest double-precision number to the number `359.9` is
	// `359.8999999999999772626324556767940521240234375`, but most people will simply
	// give `359.9` as the value.

	return
}

// Consume the text tokens (char data) as a base64-encoded bytes.
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsBase64EncodedBytes(
	decoder *xml.Decoder,
	current xml.Token,
) (value []byte, next xml.Token, err error) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var decodingErr error
	value, decodingErr = b64.StdEncoding.DecodeString(text)
	if decodingErr != nil {
		err = newDeserializationError(
			fmt.Sprintf(
				"Text could not be decoded as base64: %s",
				decodingErr.Error(),
			),
		)
		return
	}

	return
}

const Namespace = "https://admin-shell.io/aas/3/0"

// Check that the `current` token is a valid start element, *i.e.*, lives in [Namespace]
// and contains no attributes.
func checkStartElement(
	current xml.StartElement,
) (err error) {
	const xmlnsLen = len("xmlns")

	unexpectedAttr := 0
	for _, attr := range current.Attr {
		if (attr.Name.Space == "" && attr.Name.Local == "xmlns") ||
			attr.Name.Space == "xmlns" {
			continue
		}

		unexpectedAttr++
	}
	if unexpectedAttr != 0 {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected no attributes except 'xmlns' in the start element, "+
					"but got %d in the start element %s",
				unexpectedAttr, current.Name.Local,
			),
		)
		return
	}

	if current.Name.Space != Namespace {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected only start elements in the namespace %s, "+
					"but got a start element %s in the namespace %s",
				Namespace, current.Name.Local, current.Name.Space,
			),
		)
		return
	}

	return
}

// Expect a valid start element (as defined in [checkStartElement]) and extract its
// `local` name.
//
// This function is meant to be called whenever you know the runtime type of a token.
// If you do not know the runtime type, call [parseAsStartElementAndExtractLocalName]
// so that you can succinctly check the runtime type as well.
func extractLocalNameFromStartElement(
	current xml.StartElement,
) (local string, err error) {
	err = checkStartElement(current)
	if err != nil {
		return
	}

	local = current.Name.Local
	return
}

// Expect a valid start element (as defined in [checkStartElement]) and extract its
// local name.
//
// Valid means that we check that the start element lives in [Namespace] and contains
// no attributes.
//
// If you know the runtime type of `current` token, call
// [parseLocalNameFromStartElement] instead to save a cast.
func parseAsStartElementAndExtractLocalName(
	current xml.Token,
) (local string, err error) {
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected a start element, but reached the end-of-file",
		)
		return
	}

	et, ok := current.(xml.StartElement)
	if !ok {
		switch v := current.(type) {
		case xml.EndElement:
			err = newDeserializationError(
				fmt.Sprintf(
					"Expected a start element, but got an end element %s in namespace %s",
					v.Name.Local, v.Name.Space,
				),
			)
		case xml.CharData:
			err = newDeserializationError(
				fmt.Sprintf(
					"Expected a start element, but got text %s",
					string(v),
				),
			)
		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Expected a start element, but got %T: %v",
					current, current,
				),
			)
		}
		return
	}

	local, err = extractLocalNameFromStartElement(et)
	return
}

// Check that the `current` token is an end element, living in [Namespace], and
// having the `local` name.
func checkEndElement(current xml.Token, local string) (err error) {
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an end element %s, but reached the end-of-file",
				local,
			),
		)
		return
	}

	et, ok := current.(xml.EndElement)
	if !ok {
		switch v := current.(type) {
		case xml.StartElement:
			err = newDeserializationError(
				fmt.Sprintf(
					"Expected an end element %s, but got a start element %s in namespace %s",
					local, v.Name.Local, v.Name.Space,
				),
			)
		case xml.CharData:
			err = newDeserializationError(
				fmt.Sprintf(
					"Expected an end element %s, but got text %s",
					local, string(v),
				),
			)
		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Expected an end element %s, but got %T: %v",
					local, current, current,
				),
			)
		}
		return
	}

	if et.Name.Space != Namespace {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an end element %s in the namespace %s, "+
					"but got an end element in the namespace %s",
				local, Namespace, et.Name.Space,
			),
		)
		return
	}

	if et.Name.Local != local {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an end element %s, but got an end element %s",
				local, et.Name.Local,
			),
		)
		return
	}

	return
}

// Read a list of AAS instances as a sequence of XML elements.
//
// Every start element is considered to mark the start of an instance serialization. We
// stop the reading as soon as we encounter a non-start element.
//
// That last non-start element is returned as `next` element.
func readList[T aastypes.IClass](
	decoder *xml.Decoder,
	current xml.Token,
	readTWithLookahead func(
		aDecoder *xml.Decoder,
		aCurrent xml.Token,
	) (anInstance T, anErr error),
) (instances []T, next xml.Token, err error) {
	i := 0
	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, ok := current.(xml.StartElement); !ok {
			break
		}

		var instance T
		var instanceErr error
		instance, instanceErr = readTWithLookahead(decoder, current)
		if instanceErr != nil {
			if deseriaErr, ok := instanceErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependIndex(
					&aasreporting.IndexSegment{Index: i},
				)
			}
			err = instanceErr
			return
		}

		instances = append(instances, instance)

		i++

		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}
	}

	next = current
	return
}

// De-serialize an instance of [aastypes.IHasSemantics]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readHasSemanticsWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IHasSemantics,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "capability":
		instance, current, err = readCapabilityAsSequence(
			decoder, current,
		)
	case "entity":
		instance, current, err = readEntityAsSequence(
			decoder, current,
		)
	case "extension":
		instance, current, err = readExtensionAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "operation":
		instance, current, err = readOperationAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "qualifier":
		instance, current, err = readQualifierAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	case "specificAssetId":
		instance, current, err = readSpecificAssetIDAsSequence(
			decoder, current,
		)
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	case "submodelElementCollection":
		instance, current, err = readSubmodelElementCollectionAsSequence(
			decoder, current,
		)
	case "submodelElementList":
		instance, current, err = readSubmodelElementListAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IHasSemantics",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IHasSemantics]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalHasSemantics(
	decoder *xml.Decoder,
) (instance aastypes.IHasSemantics,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IHasSemantics "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readHasSemanticsWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IExtension]
// as a sequence of XML elements, each representing a property
// of [aastypes.IExtension].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readExtensionAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IExtension,
	next xml.Token,
	err error,
) {
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theName string
	var theValueType *aastypes.DataTypeDefXSD
	var theValue *string
	var theRefersTo []aastypes.IReference

	foundName := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IExtension, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "name":
			theName, current, valueErr = readText(
				decoder,
				current,
			)
			foundName = true

		case "valueType":
			var value aastypes.DataTypeDefXSD
			value, current, valueErr = readTextAsDataTypeDefXSD(
				decoder,
				current,
			)
			theValueType = &value

		case "value":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theValue = &value

		case "refersTo":
			theRefersTo, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundName {
		err = newDeserializationError(
			"The required property 'name' is missing",
		)
		return
	}

	instance = aastypes.NewExtension(
		theName,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetValueType(
		theValueType,
	)
	instance.SetValue(
		theValue,
	)
	instance.SetRefersTo(
		theRefersTo,
	)
	return
}

// De-serialize an instance of [aastypes.IExtension]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readExtensionWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IExtension,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "extension"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readExtensionAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IExtension]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalExtension(
	decoder *xml.Decoder,
) (instance aastypes.IExtension,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IExtension "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readExtensionWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IHasExtensions]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readHasExtensionsWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IHasExtensions,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "assetAdministrationShell":
		instance, current, err = readAssetAdministrationShellAsSequence(
			decoder, current,
		)
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "capability":
		instance, current, err = readCapabilityAsSequence(
			decoder, current,
		)
	case "conceptDescription":
		instance, current, err = readConceptDescriptionAsSequence(
			decoder, current,
		)
	case "entity":
		instance, current, err = readEntityAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "operation":
		instance, current, err = readOperationAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	case "submodelElementCollection":
		instance, current, err = readSubmodelElementCollectionAsSequence(
			decoder, current,
		)
	case "submodelElementList":
		instance, current, err = readSubmodelElementListAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IHasExtensions",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IHasExtensions]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalHasExtensions(
	decoder *xml.Decoder,
) (instance aastypes.IHasExtensions,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IHasExtensions "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readHasExtensionsWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IReferable]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readReferableWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IReferable,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "assetAdministrationShell":
		instance, current, err = readAssetAdministrationShellAsSequence(
			decoder, current,
		)
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "capability":
		instance, current, err = readCapabilityAsSequence(
			decoder, current,
		)
	case "conceptDescription":
		instance, current, err = readConceptDescriptionAsSequence(
			decoder, current,
		)
	case "entity":
		instance, current, err = readEntityAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "operation":
		instance, current, err = readOperationAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	case "submodelElementCollection":
		instance, current, err = readSubmodelElementCollectionAsSequence(
			decoder, current,
		)
	case "submodelElementList":
		instance, current, err = readSubmodelElementListAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IReferable",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IReferable]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalReferable(
	decoder *xml.Decoder,
) (instance aastypes.IReferable,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IReferable "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readReferableWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IIdentifiable]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readIdentifiableWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IIdentifiable,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "assetAdministrationShell":
		instance, current, err = readAssetAdministrationShellAsSequence(
			decoder, current,
		)
	case "conceptDescription":
		instance, current, err = readConceptDescriptionAsSequence(
			decoder, current,
		)
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IIdentifiable",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IIdentifiable]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalIdentifiable(
	decoder *xml.Decoder,
) (instance aastypes.IIdentifiable,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IIdentifiable "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readIdentifiableWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.ModellingKind].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsModellingKind(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.ModellingKind,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.ModellingKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of ModellingKind: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize an instance of [aastypes.IHasKind]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readHasKindWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IHasKind,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IHasKind",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IHasKind]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalHasKind(
	decoder *xml.Decoder,
) (instance aastypes.IHasKind,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IHasKind "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readHasKindWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IHasDataSpecification]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readHasDataSpecificationWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IHasDataSpecification,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "administrativeInformation":
		instance, current, err = readAdministrativeInformationAsSequence(
			decoder, current,
		)
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "assetAdministrationShell":
		instance, current, err = readAssetAdministrationShellAsSequence(
			decoder, current,
		)
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "capability":
		instance, current, err = readCapabilityAsSequence(
			decoder, current,
		)
	case "conceptDescription":
		instance, current, err = readConceptDescriptionAsSequence(
			decoder, current,
		)
	case "entity":
		instance, current, err = readEntityAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "operation":
		instance, current, err = readOperationAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	case "submodelElementCollection":
		instance, current, err = readSubmodelElementCollectionAsSequence(
			decoder, current,
		)
	case "submodelElementList":
		instance, current, err = readSubmodelElementListAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IHasDataSpecification",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IHasDataSpecification]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalHasDataSpecification(
	decoder *xml.Decoder,
) (instance aastypes.IHasDataSpecification,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IHasDataSpecification "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readHasDataSpecificationWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IAdministrativeInformation]
// as a sequence of XML elements, each representing a property
// of [aastypes.IAdministrativeInformation].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readAdministrativeInformationAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAdministrativeInformation,
	next xml.Token,
	err error,
) {
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theVersion *string
	var theRevision *string
	var theCreator aastypes.IReference
	var theTemplateID *string

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IAdministrativeInformation, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "version":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theVersion = &value

		case "revision":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theRevision = &value

		case "creator":
			theCreator, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "templateId":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theTemplateID = &value

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewAdministrativeInformation()
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetVersion(
		theVersion,
	)
	instance.SetRevision(
		theRevision,
	)
	instance.SetCreator(
		theCreator,
	)
	instance.SetTemplateID(
		theTemplateID,
	)
	return
}

// De-serialize an instance of [aastypes.IAdministrativeInformation]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readAdministrativeInformationWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAdministrativeInformation,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "administrativeInformation"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readAdministrativeInformationAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IAdministrativeInformation]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalAdministrativeInformation(
	decoder *xml.Decoder,
) (instance aastypes.IAdministrativeInformation,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IAdministrativeInformation "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readAdministrativeInformationWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IQualifiable]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readQualifiableWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IQualifiable,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "capability":
		instance, current, err = readCapabilityAsSequence(
			decoder, current,
		)
	case "entity":
		instance, current, err = readEntityAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "operation":
		instance, current, err = readOperationAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	case "submodel":
		instance, current, err = readSubmodelAsSequence(
			decoder, current,
		)
	case "submodelElementCollection":
		instance, current, err = readSubmodelElementCollectionAsSequence(
			decoder, current,
		)
	case "submodelElementList":
		instance, current, err = readSubmodelElementListAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IQualifiable",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IQualifiable]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalQualifiable(
	decoder *xml.Decoder,
) (instance aastypes.IQualifiable,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IQualifiable "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readQualifiableWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.QualifierKind].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsQualifierKind(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.QualifierKind,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.QualifierKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of QualifierKind: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize the instance of [aastypes.IQualifier]
// as a sequence of XML elements, each representing a property
// of [aastypes.IQualifier].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readQualifierAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IQualifier,
	next xml.Token,
	err error,
) {
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theKind *aastypes.QualifierKind
	var theType string
	var theValueType aastypes.DataTypeDefXSD
	var theValue *string
	var theValueID aastypes.IReference

	foundType := false
	foundValueType := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IQualifier, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "kind":
			var value aastypes.QualifierKind
			value, current, valueErr = readTextAsQualifierKind(
				decoder,
				current,
			)
			theKind = &value

		case "type":
			theType, current, valueErr = readText(
				decoder,
				current,
			)
			foundType = true

		case "valueType":
			theValueType, current, valueErr = readTextAsDataTypeDefXSD(
				decoder,
				current,
			)
			foundValueType = true

		case "value":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theValue = &value

		case "valueId":
			theValueID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing",
		)
		return
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing",
		)
		return
	}

	instance = aastypes.NewQualifier(
		theType,
		theValueType,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetKind(
		theKind,
	)
	instance.SetValue(
		theValue,
	)
	instance.SetValueID(
		theValueID,
	)
	return
}

// De-serialize an instance of [aastypes.IQualifier]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readQualifierWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IQualifier,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "qualifier"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readQualifierAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IQualifier]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalQualifier(
	decoder *xml.Decoder,
) (instance aastypes.IQualifier,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IQualifier "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readQualifierWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IAssetAdministrationShell]
// as a sequence of XML elements, each representing a property
// of [aastypes.IAssetAdministrationShell].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readAssetAdministrationShellAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAssetAdministrationShell,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theAdministration aastypes.IAdministrativeInformation
	var theID string
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theDerivedFrom aastypes.IReference
	var theAssetInformation aastypes.IAssetInformation
	var theSubmodels []aastypes.IReference

	foundID := false
	foundAssetInformation := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IAssetAdministrationShell, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "administration":
			theAdministration, current, valueErr =  readAdministrativeInformationAsSequence(
				decoder,
				current,
			)

		case "id":
			theID, current, valueErr = readText(
				decoder,
				current,
			)
			foundID = true

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "derivedFrom":
			theDerivedFrom, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "assetInformation":
			theAssetInformation, current, valueErr =  readAssetInformationAsSequence(
				decoder,
				current,
			)
			foundAssetInformation = true

		case "submodels":
			theSubmodels, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing",
		)
		return
	}

	if !foundAssetInformation {
		err = newDeserializationError(
			"The required property 'assetInformation' is missing",
		)
		return
	}

	instance = aastypes.NewAssetAdministrationShell(
		theID,
		theAssetInformation,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetAdministration(
		theAdministration,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetDerivedFrom(
		theDerivedFrom,
	)
	instance.SetSubmodels(
		theSubmodels,
	)
	return
}

// De-serialize an instance of [aastypes.IAssetAdministrationShell]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readAssetAdministrationShellWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAssetAdministrationShell,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "assetAdministrationShell"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readAssetAdministrationShellAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IAssetAdministrationShell]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalAssetAdministrationShell(
	decoder *xml.Decoder,
) (instance aastypes.IAssetAdministrationShell,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IAssetAdministrationShell "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readAssetAdministrationShellWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IAssetInformation]
// as a sequence of XML elements, each representing a property
// of [aastypes.IAssetInformation].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readAssetInformationAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAssetInformation,
	next xml.Token,
	err error,
) {
	var theAssetKind aastypes.AssetKind
	var theGlobalAssetID *string
	var theSpecificAssetIDs []aastypes.ISpecificAssetID
	var theAssetType *string
	var theDefaultThumbnail aastypes.IResource

	foundAssetKind := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IAssetInformation, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "assetKind":
			theAssetKind, current, valueErr = readTextAsAssetKind(
				decoder,
				current,
			)
			foundAssetKind = true

		case "globalAssetId":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theGlobalAssetID = &value

		case "specificAssetIds":
			theSpecificAssetIDs, current, valueErr = readList(
				decoder,
				current,
				readSpecificAssetIDWithLookahead,
			)

		case "assetType":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theAssetType = &value

		case "defaultThumbnail":
			theDefaultThumbnail, current, valueErr =  readResourceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundAssetKind {
		err = newDeserializationError(
			"The required property 'assetKind' is missing",
		)
		return
	}

	instance = aastypes.NewAssetInformation(
		theAssetKind,
	)
	instance.SetGlobalAssetID(
		theGlobalAssetID,
	)
	instance.SetSpecificAssetIDs(
		theSpecificAssetIDs,
	)
	instance.SetAssetType(
		theAssetType,
	)
	instance.SetDefaultThumbnail(
		theDefaultThumbnail,
	)
	return
}

// De-serialize an instance of [aastypes.IAssetInformation]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readAssetInformationWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAssetInformation,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "assetInformation"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readAssetInformationAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IAssetInformation]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalAssetInformation(
	decoder *xml.Decoder,
) (instance aastypes.IAssetInformation,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IAssetInformation "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readAssetInformationWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IResource]
// as a sequence of XML elements, each representing a property
// of [aastypes.IResource].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readResourceAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IResource,
	next xml.Token,
	err error,
) {
	var thePath string
	var theContentType *string

	foundPath := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IResource, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "path":
			thePath, current, valueErr = readText(
				decoder,
				current,
			)
			foundPath = true

		case "contentType":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theContentType = &value

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundPath {
		err = newDeserializationError(
			"The required property 'path' is missing",
		)
		return
	}

	instance = aastypes.NewResource(
		thePath,
	)
	instance.SetContentType(
		theContentType,
	)
	return
}

// De-serialize an instance of [aastypes.IResource]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readResourceWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IResource,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "resource"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readResourceAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IResource]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalResource(
	decoder *xml.Decoder,
) (instance aastypes.IResource,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IResource "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readResourceWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.AssetKind].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsAssetKind(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.AssetKind,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.AssetKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of AssetKind: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize the instance of [aastypes.ISpecificAssetID]
// as a sequence of XML elements, each representing a property
// of [aastypes.ISpecificAssetID].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readSpecificAssetIDAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISpecificAssetID,
	next xml.Token,
	err error,
) {
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theName string
	var theValue string
	var theExternalSubjectID aastypes.IReference

	foundName := false
	foundValue := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ISpecificAssetID, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "name":
			theName, current, valueErr = readText(
				decoder,
				current,
			)
			foundName = true

		case "value":
			theValue, current, valueErr = readText(
				decoder,
				current,
			)
			foundValue = true

		case "externalSubjectId":
			theExternalSubjectID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundName {
		err = newDeserializationError(
			"The required property 'name' is missing",
		)
		return
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	instance = aastypes.NewSpecificAssetID(
		theName,
		theValue,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetExternalSubjectID(
		theExternalSubjectID,
	)
	return
}

// De-serialize an instance of [aastypes.ISpecificAssetID]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readSpecificAssetIDWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISpecificAssetID,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "specificAssetId"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readSpecificAssetIDAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ISpecificAssetID]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalSpecificAssetID(
	decoder *xml.Decoder,
) (instance aastypes.ISpecificAssetID,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ISpecificAssetID "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readSpecificAssetIDWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ISubmodel]
// as a sequence of XML elements, each representing a property
// of [aastypes.ISubmodel].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readSubmodelAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodel,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theAdministration aastypes.IAdministrativeInformation
	var theID string
	var theKind *aastypes.ModellingKind
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theSubmodelElements []aastypes.ISubmodelElement

	foundID := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ISubmodel, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "administration":
			theAdministration, current, valueErr =  readAdministrativeInformationAsSequence(
				decoder,
				current,
			)

		case "id":
			theID, current, valueErr = readText(
				decoder,
				current,
			)
			foundID = true

		case "kind":
			var value aastypes.ModellingKind
			value, current, valueErr = readTextAsModellingKind(
				decoder,
				current,
			)
			theKind = &value

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "submodelElements":
			theSubmodelElements, current, valueErr = readList(
				decoder,
				current,
				readSubmodelElementWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing",
		)
		return
	}

	instance = aastypes.NewSubmodel(
		theID,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetAdministration(
		theAdministration,
	)
	instance.SetKind(
		theKind,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetSubmodelElements(
		theSubmodelElements,
	)
	return
}

// De-serialize an instance of [aastypes.ISubmodel]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readSubmodelWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodel,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "submodel"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readSubmodelAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ISubmodel]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalSubmodel(
	decoder *xml.Decoder,
) (instance aastypes.ISubmodel,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ISubmodel "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readSubmodelWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.ISubmodelElement]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readSubmodelElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodelElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "capability":
		instance, current, err = readCapabilityAsSequence(
			decoder, current,
		)
	case "entity":
		instance, current, err = readEntityAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "operation":
		instance, current, err = readOperationAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	case "submodelElementCollection":
		instance, current, err = readSubmodelElementCollectionAsSequence(
			decoder, current,
		)
	case "submodelElementList":
		instance, current, err = readSubmodelElementListAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for ISubmodelElement",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ISubmodelElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalSubmodelElement(
	decoder *xml.Decoder,
) (instance aastypes.ISubmodelElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ISubmodelElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readSubmodelElementWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IRelationshipElement]
// as a sequence of XML elements, each representing a property
// of [aastypes.IRelationshipElement].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readRelationshipElementAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IRelationshipElement,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theFirst aastypes.IReference
	var theSecond aastypes.IReference

	foundFirst := false
	foundSecond := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IRelationshipElement, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "first":
			theFirst, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundFirst = true

		case "second":
			theSecond, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundSecond = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundFirst {
		err = newDeserializationError(
			"The required property 'first' is missing",
		)
		return
	}

	if !foundSecond {
		err = newDeserializationError(
			"The required property 'second' is missing",
		)
		return
	}

	instance = aastypes.NewRelationshipElement(
		theFirst,
		theSecond,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	return
}

// De-serialize an instance of [aastypes.IRelationshipElement]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readRelationshipElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IRelationshipElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "annotatedRelationshipElement":
		instance, current, err = readAnnotatedRelationshipElementAsSequence(
			decoder, current,
		)
	case "relationshipElement":
		instance, current, err = readRelationshipElementAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IRelationshipElement",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IRelationshipElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalRelationshipElement(
	decoder *xml.Decoder,
) (instance aastypes.IRelationshipElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IRelationshipElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readRelationshipElementWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.AASSubmodelElements].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsAASSubmodelElements(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.AASSubmodelElements,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.AASSubmodelElementsFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of AASSubmodelElements: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize the instance of [aastypes.ISubmodelElementList]
// as a sequence of XML elements, each representing a property
// of [aastypes.ISubmodelElementList].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readSubmodelElementListAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodelElementList,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theOrderRelevant *bool
	var theSemanticIDListElement aastypes.IReference
	var theTypeValueListElement aastypes.AASSubmodelElements
	var theValueTypeListElement *aastypes.DataTypeDefXSD
	var theValue []aastypes.ISubmodelElement

	foundTypeValueListElement := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ISubmodelElementList, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "orderRelevant":
			var value bool
			value, current, valueErr = readTextAsBoolean(
				decoder,
				current,
			)
			theOrderRelevant = &value

		case "semanticIdListElement":
			theSemanticIDListElement, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "typeValueListElement":
			theTypeValueListElement, current, valueErr = readTextAsAASSubmodelElements(
				decoder,
				current,
			)
			foundTypeValueListElement = true

		case "valueTypeListElement":
			var value aastypes.DataTypeDefXSD
			value, current, valueErr = readTextAsDataTypeDefXSD(
				decoder,
				current,
			)
			theValueTypeListElement = &value

		case "value":
			theValue, current, valueErr = readList(
				decoder,
				current,
				readSubmodelElementWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundTypeValueListElement {
		err = newDeserializationError(
			"The required property 'typeValueListElement' is missing",
		)
		return
	}

	instance = aastypes.NewSubmodelElementList(
		theTypeValueListElement,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetOrderRelevant(
		theOrderRelevant,
	)
	instance.SetSemanticIDListElement(
		theSemanticIDListElement,
	)
	instance.SetValueTypeListElement(
		theValueTypeListElement,
	)
	instance.SetValue(
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.ISubmodelElementList]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readSubmodelElementListWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodelElementList,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "submodelElementList"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readSubmodelElementListAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ISubmodelElementList]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalSubmodelElementList(
	decoder *xml.Decoder,
) (instance aastypes.ISubmodelElementList,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ISubmodelElementList "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readSubmodelElementListWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ISubmodelElementCollection]
// as a sequence of XML elements, each representing a property
// of [aastypes.ISubmodelElementCollection].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readSubmodelElementCollectionAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodelElementCollection,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue []aastypes.ISubmodelElement

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ISubmodelElementCollection, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "value":
			theValue, current, valueErr = readList(
				decoder,
				current,
				readSubmodelElementWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewSubmodelElementCollection()
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetValue(
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.ISubmodelElementCollection]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readSubmodelElementCollectionWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ISubmodelElementCollection,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "submodelElementCollection"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readSubmodelElementCollectionAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ISubmodelElementCollection]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalSubmodelElementCollection(
	decoder *xml.Decoder,
) (instance aastypes.ISubmodelElementCollection,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ISubmodelElementCollection "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readSubmodelElementCollectionWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IDataElement]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readDataElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IDataElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "blob":
		instance, current, err = readBlobAsSequence(
			decoder, current,
		)
	case "file":
		instance, current, err = readFileAsSequence(
			decoder, current,
		)
	case "multiLanguageProperty":
		instance, current, err = readMultiLanguagePropertyAsSequence(
			decoder, current,
		)
	case "property":
		instance, current, err = readPropertyAsSequence(
			decoder, current,
		)
	case "range":
		instance, current, err = readRangeAsSequence(
			decoder, current,
		)
	case "referenceElement":
		instance, current, err = readReferenceElementAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IDataElement",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IDataElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalDataElement(
	decoder *xml.Decoder,
) (instance aastypes.IDataElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IDataElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readDataElementWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IProperty]
// as a sequence of XML elements, each representing a property
// of [aastypes.IProperty].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readPropertyAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IProperty,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValueType aastypes.DataTypeDefXSD
	var theValue *string
	var theValueID aastypes.IReference

	foundValueType := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IProperty, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "valueType":
			theValueType, current, valueErr = readTextAsDataTypeDefXSD(
				decoder,
				current,
			)
			foundValueType = true

		case "value":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theValue = &value

		case "valueId":
			theValueID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing",
		)
		return
	}

	instance = aastypes.NewProperty(
		theValueType,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetValue(
		theValue,
	)
	instance.SetValueID(
		theValueID,
	)
	return
}

// De-serialize an instance of [aastypes.IProperty]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readPropertyWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IProperty,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "property"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readPropertyAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IProperty]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalProperty(
	decoder *xml.Decoder,
) (instance aastypes.IProperty,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IProperty "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readPropertyWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IMultiLanguageProperty]
// as a sequence of XML elements, each representing a property
// of [aastypes.IMultiLanguageProperty].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readMultiLanguagePropertyAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IMultiLanguageProperty,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue []aastypes.ILangStringTextType
	var theValueID aastypes.IReference

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IMultiLanguageProperty, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "value":
			theValue, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "valueId":
			theValueID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewMultiLanguageProperty()
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetValue(
		theValue,
	)
	instance.SetValueID(
		theValueID,
	)
	return
}

// De-serialize an instance of [aastypes.IMultiLanguageProperty]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readMultiLanguagePropertyWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IMultiLanguageProperty,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "multiLanguageProperty"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readMultiLanguagePropertyAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IMultiLanguageProperty]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalMultiLanguageProperty(
	decoder *xml.Decoder,
) (instance aastypes.IMultiLanguageProperty,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IMultiLanguageProperty "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readMultiLanguagePropertyWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IRange]
// as a sequence of XML elements, each representing a property
// of [aastypes.IRange].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readRangeAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IRange,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValueType aastypes.DataTypeDefXSD
	var theMin *string
	var theMax *string

	foundValueType := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IRange, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "valueType":
			theValueType, current, valueErr = readTextAsDataTypeDefXSD(
				decoder,
				current,
			)
			foundValueType = true

		case "min":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theMin = &value

		case "max":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theMax = &value

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing",
		)
		return
	}

	instance = aastypes.NewRange(
		theValueType,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetMin(
		theMin,
	)
	instance.SetMax(
		theMax,
	)
	return
}

// De-serialize an instance of [aastypes.IRange]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readRangeWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IRange,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "range"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readRangeAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IRange]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalRange(
	decoder *xml.Decoder,
) (instance aastypes.IRange,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IRange "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readRangeWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IReferenceElement]
// as a sequence of XML elements, each representing a property
// of [aastypes.IReferenceElement].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readReferenceElementAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IReferenceElement,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue aastypes.IReference

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IReferenceElement, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "value":
			theValue, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewReferenceElement()
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetValue(
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.IReferenceElement]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readReferenceElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IReferenceElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "referenceElement"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readReferenceElementAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IReferenceElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalReferenceElement(
	decoder *xml.Decoder,
) (instance aastypes.IReferenceElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IReferenceElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readReferenceElementWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IBlob]
// as a sequence of XML elements, each representing a property
// of [aastypes.IBlob].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readBlobAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IBlob,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue []byte
	var theContentType string

	foundContentType := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IBlob, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "value":
			theValue, current, valueErr = readTextAsBase64EncodedBytes(
				decoder,
				current,
			)

		case "contentType":
			theContentType, current, valueErr = readText(
				decoder,
				current,
			)
			foundContentType = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundContentType {
		err = newDeserializationError(
			"The required property 'contentType' is missing",
		)
		return
	}

	instance = aastypes.NewBlob(
		theContentType,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetValue(
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.IBlob]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readBlobWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IBlob,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "blob"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readBlobAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IBlob]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalBlob(
	decoder *xml.Decoder,
) (instance aastypes.IBlob,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IBlob "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readBlobWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IFile]
// as a sequence of XML elements, each representing a property
// of [aastypes.IFile].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readFileAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IFile,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theValue *string
	var theContentType string

	foundContentType := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IFile, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "value":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theValue = &value

		case "contentType":
			theContentType, current, valueErr = readText(
				decoder,
				current,
			)
			foundContentType = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundContentType {
		err = newDeserializationError(
			"The required property 'contentType' is missing",
		)
		return
	}

	instance = aastypes.NewFile(
		theContentType,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetValue(
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.IFile]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readFileWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IFile,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "file"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readFileAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IFile]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalFile(
	decoder *xml.Decoder,
) (instance aastypes.IFile,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IFile "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readFileWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IAnnotatedRelationshipElement]
// as a sequence of XML elements, each representing a property
// of [aastypes.IAnnotatedRelationshipElement].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readAnnotatedRelationshipElementAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAnnotatedRelationshipElement,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theFirst aastypes.IReference
	var theSecond aastypes.IReference
	var theAnnotations []aastypes.IDataElement

	foundFirst := false
	foundSecond := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IAnnotatedRelationshipElement, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "first":
			theFirst, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundFirst = true

		case "second":
			theSecond, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundSecond = true

		case "annotations":
			theAnnotations, current, valueErr = readList(
				decoder,
				current,
				readDataElementWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundFirst {
		err = newDeserializationError(
			"The required property 'first' is missing",
		)
		return
	}

	if !foundSecond {
		err = newDeserializationError(
			"The required property 'second' is missing",
		)
		return
	}

	instance = aastypes.NewAnnotatedRelationshipElement(
		theFirst,
		theSecond,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetAnnotations(
		theAnnotations,
	)
	return
}

// De-serialize an instance of [aastypes.IAnnotatedRelationshipElement]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readAnnotatedRelationshipElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAnnotatedRelationshipElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "annotatedRelationshipElement"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readAnnotatedRelationshipElementAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IAnnotatedRelationshipElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalAnnotatedRelationshipElement(
	decoder *xml.Decoder,
) (instance aastypes.IAnnotatedRelationshipElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IAnnotatedRelationshipElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readAnnotatedRelationshipElementWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IEntity]
// as a sequence of XML elements, each representing a property
// of [aastypes.IEntity].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readEntityAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEntity,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theStatements []aastypes.ISubmodelElement
	var theEntityType aastypes.EntityType
	var theGlobalAssetID *string
	var theSpecificAssetIDs []aastypes.ISpecificAssetID

	foundEntityType := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IEntity, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "statements":
			theStatements, current, valueErr = readList(
				decoder,
				current,
				readSubmodelElementWithLookahead,
			)

		case "entityType":
			theEntityType, current, valueErr = readTextAsEntityType(
				decoder,
				current,
			)
			foundEntityType = true

		case "globalAssetId":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theGlobalAssetID = &value

		case "specificAssetIds":
			theSpecificAssetIDs, current, valueErr = readList(
				decoder,
				current,
				readSpecificAssetIDWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundEntityType {
		err = newDeserializationError(
			"The required property 'entityType' is missing",
		)
		return
	}

	instance = aastypes.NewEntity(
		theEntityType,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetStatements(
		theStatements,
	)
	instance.SetGlobalAssetID(
		theGlobalAssetID,
	)
	instance.SetSpecificAssetIDs(
		theSpecificAssetIDs,
	)
	return
}

// De-serialize an instance of [aastypes.IEntity]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readEntityWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEntity,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "entity"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readEntityAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IEntity]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalEntity(
	decoder *xml.Decoder,
) (instance aastypes.IEntity,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IEntity "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readEntityWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.EntityType].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsEntityType(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.EntityType,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.EntityTypeFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of EntityType: %v",
				text,
			),
		)
		return
	}

	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.Direction].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsDirection(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.Direction,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.DirectionFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of Direction: %v",
				text,
			),
		)
		return
	}

	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.StateOfEvent].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsStateOfEvent(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.StateOfEvent,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.StateOfEventFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of StateOfEvent: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize the instance of [aastypes.IEventPayload]
// as a sequence of XML elements, each representing a property
// of [aastypes.IEventPayload].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readEventPayloadAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEventPayload,
	next xml.Token,
	err error,
) {
	var theSource aastypes.IReference
	var theSourceSemanticID aastypes.IReference
	var theObservableReference aastypes.IReference
	var theObservableSemanticID aastypes.IReference
	var theTopic *string
	var theSubjectID aastypes.IReference
	var theTimeStamp string
	var thePayload []byte

	foundSource := false
	foundObservableReference := false
	foundTimeStamp := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IEventPayload, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "source":
			theSource, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundSource = true

		case "sourceSemanticId":
			theSourceSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "observableReference":
			theObservableReference, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundObservableReference = true

		case "observableSemanticId":
			theObservableSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "topic":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theTopic = &value

		case "subjectId":
			theSubjectID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "timeStamp":
			theTimeStamp, current, valueErr = readText(
				decoder,
				current,
			)
			foundTimeStamp = true

		case "payload":
			thePayload, current, valueErr = readTextAsBase64EncodedBytes(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundSource {
		err = newDeserializationError(
			"The required property 'source' is missing",
		)
		return
	}

	if !foundObservableReference {
		err = newDeserializationError(
			"The required property 'observableReference' is missing",
		)
		return
	}

	if !foundTimeStamp {
		err = newDeserializationError(
			"The required property 'timeStamp' is missing",
		)
		return
	}

	instance = aastypes.NewEventPayload(
		theSource,
		theObservableReference,
		theTimeStamp,
	)
	instance.SetSourceSemanticID(
		theSourceSemanticID,
	)
	instance.SetObservableSemanticID(
		theObservableSemanticID,
	)
	instance.SetTopic(
		theTopic,
	)
	instance.SetSubjectID(
		theSubjectID,
	)
	instance.SetPayload(
		thePayload,
	)
	return
}

// De-serialize an instance of [aastypes.IEventPayload]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readEventPayloadWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEventPayload,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "eventPayload"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readEventPayloadAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IEventPayload]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalEventPayload(
	decoder *xml.Decoder,
) (instance aastypes.IEventPayload,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IEventPayload "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readEventPayloadWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IEventElement]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readEventElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEventElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "basicEventElement":
		instance, current, err = readBasicEventElementAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IEventElement",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IEventElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalEventElement(
	decoder *xml.Decoder,
) (instance aastypes.IEventElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IEventElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readEventElementWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IBasicEventElement]
// as a sequence of XML elements, each representing a property
// of [aastypes.IBasicEventElement].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readBasicEventElementAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IBasicEventElement,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theObserved aastypes.IReference
	var theDirection aastypes.Direction
	var theState aastypes.StateOfEvent
	var theMessageTopic *string
	var theMessageBroker aastypes.IReference
	var theLastUpdate *string
	var theMinInterval *string
	var theMaxInterval *string

	foundObserved := false
	foundDirection := false
	foundState := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IBasicEventElement, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "observed":
			theObserved, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundObserved = true

		case "direction":
			theDirection, current, valueErr = readTextAsDirection(
				decoder,
				current,
			)
			foundDirection = true

		case "state":
			theState, current, valueErr = readTextAsStateOfEvent(
				decoder,
				current,
			)
			foundState = true

		case "messageTopic":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theMessageTopic = &value

		case "messageBroker":
			theMessageBroker, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "lastUpdate":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theLastUpdate = &value

		case "minInterval":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theMinInterval = &value

		case "maxInterval":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theMaxInterval = &value

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundObserved {
		err = newDeserializationError(
			"The required property 'observed' is missing",
		)
		return
	}

	if !foundDirection {
		err = newDeserializationError(
			"The required property 'direction' is missing",
		)
		return
	}

	if !foundState {
		err = newDeserializationError(
			"The required property 'state' is missing",
		)
		return
	}

	instance = aastypes.NewBasicEventElement(
		theObserved,
		theDirection,
		theState,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetMessageTopic(
		theMessageTopic,
	)
	instance.SetMessageBroker(
		theMessageBroker,
	)
	instance.SetLastUpdate(
		theLastUpdate,
	)
	instance.SetMinInterval(
		theMinInterval,
	)
	instance.SetMaxInterval(
		theMaxInterval,
	)
	return
}

// De-serialize an instance of [aastypes.IBasicEventElement]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readBasicEventElementWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IBasicEventElement,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "basicEventElement"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readBasicEventElementAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IBasicEventElement]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalBasicEventElement(
	decoder *xml.Decoder,
) (instance aastypes.IBasicEventElement,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IBasicEventElement "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readBasicEventElementWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IOperation]
// as a sequence of XML elements, each representing a property
// of [aastypes.IOperation].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readOperationAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IOperation,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theInputVariables []aastypes.IOperationVariable
	var theOutputVariables []aastypes.IOperationVariable
	var theInoutputVariables []aastypes.IOperationVariable

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IOperation, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "inputVariables":
			theInputVariables, current, valueErr = readList(
				decoder,
				current,
				readOperationVariableWithLookahead,
			)

		case "outputVariables":
			theOutputVariables, current, valueErr = readList(
				decoder,
				current,
				readOperationVariableWithLookahead,
			)

		case "inoutputVariables":
			theInoutputVariables, current, valueErr = readList(
				decoder,
				current,
				readOperationVariableWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewOperation()
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetInputVariables(
		theInputVariables,
	)
	instance.SetOutputVariables(
		theOutputVariables,
	)
	instance.SetInoutputVariables(
		theInoutputVariables,
	)
	return
}

// De-serialize an instance of [aastypes.IOperation]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readOperationWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IOperation,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "operation"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readOperationAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IOperation]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalOperation(
	decoder *xml.Decoder,
) (instance aastypes.IOperation,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IOperation "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readOperationWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IOperationVariable]
// as a sequence of XML elements, each representing a property
// of [aastypes.IOperationVariable].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readOperationVariableAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IOperationVariable,
	next xml.Token,
	err error,
) {
	var theValue aastypes.ISubmodelElement

	foundValue := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IOperationVariable, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "value":
			theValue, valueErr =  unmarshalSubmodelElement(
				decoder,
			)
			// unmarshalSubmodelElement stops at the end element,
			// so we look ahead to the next element.
			if valueErr == nil {
				current, valueErr = readNext(decoder, current)
			}
			foundValue = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	instance = aastypes.NewOperationVariable(
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.IOperationVariable]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readOperationVariableWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IOperationVariable,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "operationVariable"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readOperationVariableAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IOperationVariable]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalOperationVariable(
	decoder *xml.Decoder,
) (instance aastypes.IOperationVariable,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IOperationVariable "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readOperationVariableWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ICapability]
// as a sequence of XML elements, each representing a property
// of [aastypes.ICapability].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readCapabilityAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ICapability,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theSemanticID aastypes.IReference
	var theSupplementalSemanticIDs []aastypes.IReference
	var theQualifiers []aastypes.IQualifier
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ICapability, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "semanticId":
			theSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "supplementalSemanticIds":
			theSupplementalSemanticIDs, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		case "qualifiers":
			theQualifiers, current, valueErr = readList(
				decoder,
				current,
				readQualifierWithLookahead,
			)

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewCapability()
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetSemanticID(
		theSemanticID,
	)
	instance.SetSupplementalSemanticIDs(
		theSupplementalSemanticIDs,
	)
	instance.SetQualifiers(
		theQualifiers,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	return
}

// De-serialize an instance of [aastypes.ICapability]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readCapabilityWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ICapability,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "capability"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readCapabilityAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ICapability]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalCapability(
	decoder *xml.Decoder,
) (instance aastypes.ICapability,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ICapability "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readCapabilityWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IConceptDescription]
// as a sequence of XML elements, each representing a property
// of [aastypes.IConceptDescription].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readConceptDescriptionAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IConceptDescription,
	next xml.Token,
	err error,
) {
	var theExtensions []aastypes.IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []aastypes.ILangStringNameType
	var theDescription []aastypes.ILangStringTextType
	var theAdministration aastypes.IAdministrativeInformation
	var theID string
	var theEmbeddedDataSpecifications []aastypes.IEmbeddedDataSpecification
	var theIsCaseOf []aastypes.IReference

	foundID := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IConceptDescription, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "extensions":
			theExtensions, current, valueErr = readList(
				decoder,
				current,
				readExtensionWithLookahead,
			)

		case "category":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theCategory = &value

		case "idShort":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theIDShort = &value

		case "displayName":
			theDisplayName, current, valueErr = readList(
				decoder,
				current,
				readLangStringNameTypeWithLookahead,
			)

		case "description":
			theDescription, current, valueErr = readList(
				decoder,
				current,
				readLangStringTextTypeWithLookahead,
			)

		case "administration":
			theAdministration, current, valueErr =  readAdministrativeInformationAsSequence(
				decoder,
				current,
			)

		case "id":
			theID, current, valueErr = readText(
				decoder,
				current,
			)
			foundID = true

		case "embeddedDataSpecifications":
			theEmbeddedDataSpecifications, current, valueErr = readList(
				decoder,
				current,
				readEmbeddedDataSpecificationWithLookahead,
			)

		case "isCaseOf":
			theIsCaseOf, current, valueErr = readList(
				decoder,
				current,
				readReferenceWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing",
		)
		return
	}

	instance = aastypes.NewConceptDescription(
		theID,
	)
	instance.SetExtensions(
		theExtensions,
	)
	instance.SetCategory(
		theCategory,
	)
	instance.SetIDShort(
		theIDShort,
	)
	instance.SetDisplayName(
		theDisplayName,
	)
	instance.SetDescription(
		theDescription,
	)
	instance.SetAdministration(
		theAdministration,
	)
	instance.SetEmbeddedDataSpecifications(
		theEmbeddedDataSpecifications,
	)
	instance.SetIsCaseOf(
		theIsCaseOf,
	)
	return
}

// De-serialize an instance of [aastypes.IConceptDescription]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readConceptDescriptionWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IConceptDescription,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "conceptDescription"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readConceptDescriptionAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IConceptDescription]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalConceptDescription(
	decoder *xml.Decoder,
) (instance aastypes.IConceptDescription,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IConceptDescription "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readConceptDescriptionWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.ReferenceTypes].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsReferenceTypes(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.ReferenceTypes,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.ReferenceTypesFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of ReferenceTypes: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize the instance of [aastypes.IReference]
// as a sequence of XML elements, each representing a property
// of [aastypes.IReference].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readReferenceAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IReference,
	next xml.Token,
	err error,
) {
	var theType aastypes.ReferenceTypes
	var theReferredSemanticID aastypes.IReference
	var theKeys []aastypes.IKey

	foundType := false
	foundKeys := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IReference, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "type":
			theType, current, valueErr = readTextAsReferenceTypes(
				decoder,
				current,
			)
			foundType = true

		case "referredSemanticId":
			theReferredSemanticID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "keys":
			theKeys, current, valueErr = readList(
				decoder,
				current,
				readKeyWithLookahead,
			)
			foundKeys = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing",
		)
		return
	}

	if !foundKeys {
		err = newDeserializationError(
			"The required property 'keys' is missing",
		)
		return
	}

	instance = aastypes.NewReference(
		theType,
		theKeys,
	)
	instance.SetReferredSemanticID(
		theReferredSemanticID,
	)
	return
}

// De-serialize an instance of [aastypes.IReference]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readReferenceWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IReference,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "reference"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readReferenceAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IReference]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalReference(
	decoder *xml.Decoder,
) (instance aastypes.IReference,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IReference "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readReferenceWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IKey]
// as a sequence of XML elements, each representing a property
// of [aastypes.IKey].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readKeyAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IKey,
	next xml.Token,
	err error,
) {
	var theType aastypes.KeyTypes
	var theValue string

	foundType := false
	foundValue := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IKey, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "type":
			theType, current, valueErr = readTextAsKeyTypes(
				decoder,
				current,
			)
			foundType = true

		case "value":
			theValue, current, valueErr = readText(
				decoder,
				current,
			)
			foundValue = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing",
		)
		return
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	instance = aastypes.NewKey(
		theType,
		theValue,
	)
	return
}

// De-serialize an instance of [aastypes.IKey]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readKeyWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IKey,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "key"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readKeyAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IKey]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalKey(
	decoder *xml.Decoder,
) (instance aastypes.IKey,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IKey "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readKeyWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.KeyTypes].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsKeyTypes(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.KeyTypes,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.KeyTypesFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of KeyTypes: %v",
				text,
			),
		)
		return
	}

	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.DataTypeDefXSD].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsDataTypeDefXSD(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.DataTypeDefXSD,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.DataTypeDefXSDFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of DataTypeDefXSD: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize an instance of [aastypes.IAbstractLangString]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readAbstractLangStringWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IAbstractLangString,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "langStringDefinitionTypeIec61360":
		instance, current, err = readLangStringDefinitionTypeIEC61360AsSequence(
			decoder, current,
		)
	case "langStringNameType":
		instance, current, err = readLangStringNameTypeAsSequence(
			decoder, current,
		)
	case "langStringPreferredNameTypeIec61360":
		instance, current, err = readLangStringPreferredNameTypeIEC61360AsSequence(
			decoder, current,
		)
	case "langStringShortNameTypeIec61360":
		instance, current, err = readLangStringShortNameTypeIEC61360AsSequence(
			decoder, current,
		)
	case "langStringTextType":
		instance, current, err = readLangStringTextTypeAsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IAbstractLangString",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IAbstractLangString]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalAbstractLangString(
	decoder *xml.Decoder,
) (instance aastypes.IAbstractLangString,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IAbstractLangString "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readAbstractLangStringWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ILangStringNameType]
// as a sequence of XML elements, each representing a property
// of [aastypes.ILangStringNameType].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readLangStringNameTypeAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringNameType,
	next xml.Token,
	err error,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ILangStringNameType, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "language":
			theLanguage, current, valueErr = readText(
				decoder,
				current,
			)
			foundLanguage = true

		case "text":
			theText, current, valueErr = readText(
				decoder,
				current,
			)
			foundText = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	instance = aastypes.NewLangStringNameType(
		theLanguage,
		theText,
	)
	return
}

// De-serialize an instance of [aastypes.ILangStringNameType]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readLangStringNameTypeWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringNameType,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "langStringNameType"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readLangStringNameTypeAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ILangStringNameType]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalLangStringNameType(
	decoder *xml.Decoder,
) (instance aastypes.ILangStringNameType,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ILangStringNameType "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readLangStringNameTypeWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ILangStringTextType]
// as a sequence of XML elements, each representing a property
// of [aastypes.ILangStringTextType].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readLangStringTextTypeAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringTextType,
	next xml.Token,
	err error,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ILangStringTextType, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "language":
			theLanguage, current, valueErr = readText(
				decoder,
				current,
			)
			foundLanguage = true

		case "text":
			theText, current, valueErr = readText(
				decoder,
				current,
			)
			foundText = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	instance = aastypes.NewLangStringTextType(
		theLanguage,
		theText,
	)
	return
}

// De-serialize an instance of [aastypes.ILangStringTextType]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readLangStringTextTypeWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringTextType,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "langStringTextType"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readLangStringTextTypeAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ILangStringTextType]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalLangStringTextType(
	decoder *xml.Decoder,
) (instance aastypes.ILangStringTextType,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ILangStringTextType "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readLangStringTextTypeWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IEnvironment]
// as a sequence of XML elements, each representing a property
// of [aastypes.IEnvironment].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readEnvironmentAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEnvironment,
	next xml.Token,
	err error,
) {
	var theAssetAdministrationShells []aastypes.IAssetAdministrationShell
	var theSubmodels []aastypes.ISubmodel
	var theConceptDescriptions []aastypes.IConceptDescription

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IEnvironment, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "assetAdministrationShells":
			theAssetAdministrationShells, current, valueErr = readList(
				decoder,
				current,
				readAssetAdministrationShellWithLookahead,
			)

		case "submodels":
			theSubmodels, current, valueErr = readList(
				decoder,
				current,
				readSubmodelWithLookahead,
			)

		case "conceptDescriptions":
			theConceptDescriptions, current, valueErr = readList(
				decoder,
				current,
				readConceptDescriptionWithLookahead,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	instance = aastypes.NewEnvironment()
	instance.SetAssetAdministrationShells(
		theAssetAdministrationShells,
	)
	instance.SetSubmodels(
		theSubmodels,
	)
	instance.SetConceptDescriptions(
		theConceptDescriptions,
	)
	return
}

// De-serialize an instance of [aastypes.IEnvironment]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readEnvironmentWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEnvironment,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "environment"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readEnvironmentAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IEnvironment]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalEnvironment(
	decoder *xml.Decoder,
) (instance aastypes.IEnvironment,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IEnvironment "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readEnvironmentWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize an instance of [aastypes.IDataSpecificationContent]
// as an XML element where the start element is expected to have been already read
// as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readDataSpecificationContentWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IDataSpecificationContent,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
	case "dataSpecificationIec61360":
		instance, current, err = readDataSpecificationIEC61360AsSequence(
			decoder, current,
		)
	default:
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected start element %s as discriminator "+
					"for IDataSpecificationContent",
				local,
			),
		)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IDataSpecificationContent]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalDataSpecificationContent(
	decoder *xml.Decoder,
) (instance aastypes.IDataSpecificationContent,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IDataSpecificationContent "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readDataSpecificationContentWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IEmbeddedDataSpecification]
// as a sequence of XML elements, each representing a property
// of [aastypes.IEmbeddedDataSpecification].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readEmbeddedDataSpecificationAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEmbeddedDataSpecification,
	next xml.Token,
	err error,
) {
	var theDataSpecificationContent aastypes.IDataSpecificationContent
	var theDataSpecification aastypes.IReference

	foundDataSpecificationContent := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IEmbeddedDataSpecification, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "dataSpecificationContent":
			theDataSpecificationContent, valueErr =  unmarshalDataSpecificationContent(
				decoder,
			)
			// unmarshalDataSpecificationContent stops at the end element,
			// so we look ahead to the next element.
			if valueErr == nil {
				current, valueErr = readNext(decoder, current)
			}
			foundDataSpecificationContent = true

		case "dataSpecification":
			theDataSpecification, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundDataSpecificationContent {
		err = newDeserializationError(
			"The required property 'dataSpecificationContent' is missing",
		)
		return
	}

	instance = aastypes.NewEmbeddedDataSpecification(
		theDataSpecificationContent,
	)
	instance.SetDataSpecification(
		theDataSpecification,
	)
	return
}

// De-serialize an instance of [aastypes.IEmbeddedDataSpecification]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readEmbeddedDataSpecificationWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IEmbeddedDataSpecification,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "embeddedDataSpecification"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readEmbeddedDataSpecificationAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IEmbeddedDataSpecification]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalEmbeddedDataSpecification(
	decoder *xml.Decoder,
) (instance aastypes.IEmbeddedDataSpecification,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IEmbeddedDataSpecification "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readEmbeddedDataSpecificationWithLookahead(
		decoder,
		current,
	)
	return
}

// Consume the text tokens (char data) as a string-encoded literal of
// [aastypes.DataTypeIEC61360].
//
// Any comment tokens are skipped.
//
// The resulting `next` token points to the first token which is neither text
// nor comment.
//
// If we reached the end-of-file, `next` is an [eof] sentinel token.
func readTextAsDataTypeIEC61360(
	decoder *xml.Decoder,
	current xml.Token,
) (value aastypes.DataTypeIEC61360,
	next xml.Token,
	err error,
) {
	var text string
	text, next, err = readText(decoder, current)
	if err != nil {
		return
	}

	var ok bool
	value, ok = aasstringification.DataTypeIEC61360FromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Unexpected literal of DataTypeIEC61360: %v",
				text,
			),
		)
		return
	}

	return
}

// De-serialize the instance of [aastypes.ILevelType]
// as a sequence of XML elements, each representing a property
// of [aastypes.ILevelType].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readLevelTypeAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILevelType,
	next xml.Token,
	err error,
) {
	var theMin bool
	var theNom bool
	var theTyp bool
	var theMax bool

	foundMin := false
	foundNom := false
	foundTyp := false
	foundMax := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ILevelType, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "min":
			theMin, current, valueErr = readTextAsBoolean(
				decoder,
				current,
			)
			foundMin = true

		case "nom":
			theNom, current, valueErr = readTextAsBoolean(
				decoder,
				current,
			)
			foundNom = true

		case "typ":
			theTyp, current, valueErr = readTextAsBoolean(
				decoder,
				current,
			)
			foundTyp = true

		case "max":
			theMax, current, valueErr = readTextAsBoolean(
				decoder,
				current,
			)
			foundMax = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundMin {
		err = newDeserializationError(
			"The required property 'min' is missing",
		)
		return
	}

	if !foundNom {
		err = newDeserializationError(
			"The required property 'nom' is missing",
		)
		return
	}

	if !foundTyp {
		err = newDeserializationError(
			"The required property 'typ' is missing",
		)
		return
	}

	if !foundMax {
		err = newDeserializationError(
			"The required property 'max' is missing",
		)
		return
	}

	instance = aastypes.NewLevelType(
		theMin,
		theNom,
		theTyp,
		theMax,
	)
	return
}

// De-serialize an instance of [aastypes.ILevelType]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readLevelTypeWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILevelType,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "levelType"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readLevelTypeAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ILevelType]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalLevelType(
	decoder *xml.Decoder,
) (instance aastypes.ILevelType,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ILevelType "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readLevelTypeWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IValueReferencePair]
// as a sequence of XML elements, each representing a property
// of [aastypes.IValueReferencePair].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readValueReferencePairAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IValueReferencePair,
	next xml.Token,
	err error,
) {
	var theValue string
	var theValueID aastypes.IReference

	foundValue := false
	foundValueID := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IValueReferencePair, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "value":
			theValue, current, valueErr = readText(
				decoder,
				current,
			)
			foundValue = true

		case "valueId":
			theValueID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)
			foundValueID = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing",
		)
		return
	}

	if !foundValueID {
		err = newDeserializationError(
			"The required property 'valueId' is missing",
		)
		return
	}

	instance = aastypes.NewValueReferencePair(
		theValue,
		theValueID,
	)
	return
}

// De-serialize an instance of [aastypes.IValueReferencePair]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readValueReferencePairWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IValueReferencePair,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "valueReferencePair"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readValueReferencePairAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IValueReferencePair]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalValueReferencePair(
	decoder *xml.Decoder,
) (instance aastypes.IValueReferencePair,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IValueReferencePair "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readValueReferencePairWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IValueList]
// as a sequence of XML elements, each representing a property
// of [aastypes.IValueList].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readValueListAsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IValueList,
	next xml.Token,
	err error,
) {
	var theValueReferencePairs []aastypes.IValueReferencePair

	foundValueReferencePairs := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IValueList, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "valueReferencePairs":
			theValueReferencePairs, current, valueErr = readList(
				decoder,
				current,
				readValueReferencePairWithLookahead,
			)
			foundValueReferencePairs = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundValueReferencePairs {
		err = newDeserializationError(
			"The required property 'valueReferencePairs' is missing",
		)
		return
	}

	instance = aastypes.NewValueList(
		theValueReferencePairs,
	)
	return
}

// De-serialize an instance of [aastypes.IValueList]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readValueListWithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IValueList,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "valueList"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readValueListAsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IValueList]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalValueList(
	decoder *xml.Decoder,
) (instance aastypes.IValueList,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IValueList "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readValueListWithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ILangStringPreferredNameTypeIEC61360]
// as a sequence of XML elements, each representing a property
// of [aastypes.ILangStringPreferredNameTypeIEC61360].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readLangStringPreferredNameTypeIEC61360AsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringPreferredNameTypeIEC61360,
	next xml.Token,
	err error,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ILangStringPreferredNameTypeIEC61360, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "language":
			theLanguage, current, valueErr = readText(
				decoder,
				current,
			)
			foundLanguage = true

		case "text":
			theText, current, valueErr = readText(
				decoder,
				current,
			)
			foundText = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	instance = aastypes.NewLangStringPreferredNameTypeIEC61360(
		theLanguage,
		theText,
	)
	return
}

// De-serialize an instance of [aastypes.ILangStringPreferredNameTypeIEC61360]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readLangStringPreferredNameTypeIEC61360WithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringPreferredNameTypeIEC61360,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "langStringPreferredNameTypeIec61360"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readLangStringPreferredNameTypeIEC61360AsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ILangStringPreferredNameTypeIEC61360]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalLangStringPreferredNameTypeIEC61360(
	decoder *xml.Decoder,
) (instance aastypes.ILangStringPreferredNameTypeIEC61360,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ILangStringPreferredNameTypeIEC61360 "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readLangStringPreferredNameTypeIEC61360WithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ILangStringShortNameTypeIEC61360]
// as a sequence of XML elements, each representing a property
// of [aastypes.ILangStringShortNameTypeIEC61360].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readLangStringShortNameTypeIEC61360AsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringShortNameTypeIEC61360,
	next xml.Token,
	err error,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ILangStringShortNameTypeIEC61360, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "language":
			theLanguage, current, valueErr = readText(
				decoder,
				current,
			)
			foundLanguage = true

		case "text":
			theText, current, valueErr = readText(
				decoder,
				current,
			)
			foundText = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	instance = aastypes.NewLangStringShortNameTypeIEC61360(
		theLanguage,
		theText,
	)
	return
}

// De-serialize an instance of [aastypes.ILangStringShortNameTypeIEC61360]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readLangStringShortNameTypeIEC61360WithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringShortNameTypeIEC61360,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "langStringShortNameTypeIec61360"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readLangStringShortNameTypeIEC61360AsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ILangStringShortNameTypeIEC61360]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalLangStringShortNameTypeIEC61360(
	decoder *xml.Decoder,
) (instance aastypes.ILangStringShortNameTypeIEC61360,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ILangStringShortNameTypeIEC61360 "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readLangStringShortNameTypeIEC61360WithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.ILangStringDefinitionTypeIEC61360]
// as a sequence of XML elements, each representing a property
// of [aastypes.ILangStringDefinitionTypeIEC61360].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readLangStringDefinitionTypeIEC61360AsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringDefinitionTypeIEC61360,
	next xml.Token,
	err error,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of ILangStringDefinitionTypeIEC61360, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "language":
			theLanguage, current, valueErr = readText(
				decoder,
				current,
			)
			foundLanguage = true

		case "text":
			theText, current, valueErr = readText(
				decoder,
				current,
			)
			foundText = true

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing",
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing",
		)
		return
	}

	instance = aastypes.NewLangStringDefinitionTypeIEC61360(
		theLanguage,
		theText,
	)
	return
}

// De-serialize an instance of [aastypes.ILangStringDefinitionTypeIEC61360]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readLangStringDefinitionTypeIEC61360WithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.ILangStringDefinitionTypeIEC61360,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "langStringDefinitionTypeIec61360"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readLangStringDefinitionTypeIEC61360AsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.ILangStringDefinitionTypeIEC61360]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalLangStringDefinitionTypeIEC61360(
	decoder *xml.Decoder,
) (instance aastypes.ILangStringDefinitionTypeIEC61360,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of ILangStringDefinitionTypeIEC61360 "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readLangStringDefinitionTypeIEC61360WithLookahead(
		decoder,
		current,
	)
	return
}

// De-serialize the instance of [aastypes.IDataSpecificationIEC61360]
// as a sequence of XML elements, each representing a property
// of [aastypes.IDataSpecificationIEC61360].
//
// The reading stops as soon as we encounter a non-start element, and we return
// that token as the `next` token.
func readDataSpecificationIEC61360AsSequence(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IDataSpecificationIEC61360,
	next xml.Token,
	err error,
) {
	var thePreferredName []aastypes.ILangStringPreferredNameTypeIEC61360
	var theShortName []aastypes.ILangStringShortNameTypeIEC61360
	var theUnit *string
	var theUnitID aastypes.IReference
	var theSourceOfDefinition *string
	var theSymbol *string
	var theDataType *aastypes.DataTypeIEC61360
	var theDefinition []aastypes.ILangStringDefinitionTypeIEC61360
	var theValueFormat *string
	var theValueList aastypes.IValueList
	var theValue *string
	var theLevelType aastypes.ILevelType

	foundPreferredName := false

	for {
		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		if _, isEOF := current.(eof); isEOF {
			break
		}

		startElement, ok := current.(xml.StartElement)
		if !ok {
			if charData, isCharData := current.(xml.CharData); isCharData {
				err = newDeserializationError(
					fmt.Sprintf(
						"Expected a sequence of XML elements representing properties "+
						"of IDataSpecificationIEC61360, but got text: %s",
						string(charData),
					),
				)
				return
			}

			break
		}

		var local string
		local, err = extractLocalNameFromStartElement(startElement)
		if err != nil {
			return
		}

		// Move the current to the content of the XML element
		current, err = readNext(decoder, nil)
		if err != nil {
			return
		}

		var valueErr error
		switch local {
		case "preferredName":
			thePreferredName, current, valueErr = readList(
				decoder,
				current,
				readLangStringPreferredNameTypeIEC61360WithLookahead,
			)
			foundPreferredName = true

		case "shortName":
			theShortName, current, valueErr = readList(
				decoder,
				current,
				readLangStringShortNameTypeIEC61360WithLookahead,
			)

		case "unit":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theUnit = &value

		case "unitId":
			theUnitID, current, valueErr =  readReferenceAsSequence(
				decoder,
				current,
			)

		case "sourceOfDefinition":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theSourceOfDefinition = &value

		case "symbol":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theSymbol = &value

		case "dataType":
			var value aastypes.DataTypeIEC61360
			value, current, valueErr = readTextAsDataTypeIEC61360(
				decoder,
				current,
			)
			theDataType = &value

		case "definition":
			theDefinition, current, valueErr = readList(
				decoder,
				current,
				readLangStringDefinitionTypeIEC61360WithLookahead,
			)

		case "valueFormat":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theValueFormat = &value

		case "valueList":
			theValueList, current, valueErr =  readValueListAsSequence(
				decoder,
				current,
			)

		case "value":
			var value string
			value, current, valueErr = readText(
				decoder,
				current,
			)
			theValue = &value

		case "levelType":
			theLevelType, current, valueErr =  readLevelTypeAsSequence(
				decoder,
				current,
			)

		default:
			valueErr = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property",
				),
			)
		}

		if valueErr != nil {
			if deseriaErr, ok := valueErr.(*DeserializationError); ok {
				deseriaErr.Path.PrependName(
					&aasreporting.NameSegment{Name: local},
				)
			}
			err = valueErr
		}

		if err != nil {
			return
		}

		current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
		if err != nil {
			return
		}

		err = checkEndElement(current, local)
		if err != nil {
			return
		}

		current, err = readNext(decoder, current)
		if err != nil {
			return
		}
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	next = current

	if !foundPreferredName {
		err = newDeserializationError(
			"The required property 'preferredName' is missing",
		)
		return
	}

	instance = aastypes.NewDataSpecificationIEC61360(
		thePreferredName,
	)
	instance.SetShortName(
		theShortName,
	)
	instance.SetUnit(
		theUnit,
	)
	instance.SetUnitID(
		theUnitID,
	)
	instance.SetSourceOfDefinition(
		theSourceOfDefinition,
	)
	instance.SetSymbol(
		theSymbol,
	)
	instance.SetDataType(
		theDataType,
	)
	instance.SetDefinition(
		theDefinition,
	)
	instance.SetValueFormat(
		theValueFormat,
	)
	instance.SetValueList(
		theValueList,
	)
	instance.SetValue(
		theValue,
	)
	instance.SetLevelType(
		theLevelType,
	)
	return
}

// De-serialize an instance of [aastypes.IDataSpecificationIEC61360]
// as an XML element where the start element is expected to have been already
// read as `current` token.
//
// The de-serialization stops by consuming the final end element.
func readDataSpecificationIEC61360WithLookahead(
	decoder *xml.Decoder,
	current xml.Token,
) (instance aastypes.IDataSpecificationIEC61360,
	err error,
) {
	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	expectedLocal := "dataSpecificationIec61360"
	if local != expectedLocal {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a start element with local name %s, "+
					"but got a start element with local name %s",
				expectedLocal, local,
			),
		)
		return
	}

	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	instance, current, err = readDataSpecificationIEC61360AsSequence(
		decoder,
		current,
)
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// Unmarshal an instance of [aastypes.IDataSpecificationIEC61360]
// serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func unmarshalDataSpecificationIEC61360(
	decoder *xml.Decoder,
) (instance aastypes.IDataSpecificationIEC61360,
	err error,
) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if _, isEOF := current.(eof); isEOF {
		err = newDeserializationError(
			"Expected an instance of IDataSpecificationIEC61360 "+
				"serialized as an XML element, but reached the end of file.",
		)
		return
	}

	instance, err = readDataSpecificationIEC61360WithLookahead(
		decoder,
		current,
	)
	return
}

// Unmarshal an instance of [aastypes.IClass] serialized as an XML element.
//
// The XML element must live in the [Namespace] space.
func Unmarshal(
	decoder *xml.Decoder,
) (instance aastypes.IClass, err error) {
	var current xml.Token
	current, err = readNext(decoder, nil)
	if err != nil {
		return
	}

	current, err = skipEmptyTextWhitespaceAndComments(decoder, current)
	if err != nil {
		return
	}

	var local string
	local, err = parseAsStartElementAndExtractLocalName(
		current,
	)
	if err != nil {
		return
	}

	// Move the current to the properties of the instance
	current, err = readNext(decoder, current)
	if err != nil {
		return
	}

	switch local {
		case "extension":
			instance, current, err = readExtensionAsSequence(
				decoder, current,
			)
		case "administrativeInformation":
			instance, current, err = readAdministrativeInformationAsSequence(
				decoder, current,
			)
		case "qualifier":
			instance, current, err = readQualifierAsSequence(
				decoder, current,
			)
		case "assetAdministrationShell":
			instance, current, err = readAssetAdministrationShellAsSequence(
				decoder, current,
			)
		case "assetInformation":
			instance, current, err = readAssetInformationAsSequence(
				decoder, current,
			)
		case "resource":
			instance, current, err = readResourceAsSequence(
				decoder, current,
			)
		case "specificAssetId":
			instance, current, err = readSpecificAssetIDAsSequence(
				decoder, current,
			)
		case "submodel":
			instance, current, err = readSubmodelAsSequence(
				decoder, current,
			)
		case "relationshipElement":
			instance, current, err = readRelationshipElementAsSequence(
				decoder, current,
			)
		case "submodelElementList":
			instance, current, err = readSubmodelElementListAsSequence(
				decoder, current,
			)
		case "submodelElementCollection":
			instance, current, err = readSubmodelElementCollectionAsSequence(
				decoder, current,
			)
		case "property":
			instance, current, err = readPropertyAsSequence(
				decoder, current,
			)
		case "multiLanguageProperty":
			instance, current, err = readMultiLanguagePropertyAsSequence(
				decoder, current,
			)
		case "range":
			instance, current, err = readRangeAsSequence(
				decoder, current,
			)
		case "referenceElement":
			instance, current, err = readReferenceElementAsSequence(
				decoder, current,
			)
		case "blob":
			instance, current, err = readBlobAsSequence(
				decoder, current,
			)
		case "file":
			instance, current, err = readFileAsSequence(
				decoder, current,
			)
		case "annotatedRelationshipElement":
			instance, current, err = readAnnotatedRelationshipElementAsSequence(
				decoder, current,
			)
		case "entity":
			instance, current, err = readEntityAsSequence(
				decoder, current,
			)
		case "eventPayload":
			instance, current, err = readEventPayloadAsSequence(
				decoder, current,
			)
		case "basicEventElement":
			instance, current, err = readBasicEventElementAsSequence(
				decoder, current,
			)
		case "operation":
			instance, current, err = readOperationAsSequence(
				decoder, current,
			)
		case "operationVariable":
			instance, current, err = readOperationVariableAsSequence(
				decoder, current,
			)
		case "capability":
			instance, current, err = readCapabilityAsSequence(
				decoder, current,
			)
		case "conceptDescription":
			instance, current, err = readConceptDescriptionAsSequence(
				decoder, current,
			)
		case "reference":
			instance, current, err = readReferenceAsSequence(
				decoder, current,
			)
		case "key":
			instance, current, err = readKeyAsSequence(
				decoder, current,
			)
		case "langStringNameType":
			instance, current, err = readLangStringNameTypeAsSequence(
				decoder, current,
			)
		case "langStringTextType":
			instance, current, err = readLangStringTextTypeAsSequence(
				decoder, current,
			)
		case "environment":
			instance, current, err = readEnvironmentAsSequence(
				decoder, current,
			)
		case "embeddedDataSpecification":
			instance, current, err = readEmbeddedDataSpecificationAsSequence(
				decoder, current,
			)
		case "levelType":
			instance, current, err = readLevelTypeAsSequence(
				decoder, current,
			)
		case "valueReferencePair":
			instance, current, err = readValueReferencePairAsSequence(
				decoder, current,
			)
		case "valueList":
			instance, current, err = readValueListAsSequence(
				decoder, current,
			)
		case "langStringPreferredNameTypeIec61360":
			instance, current, err = readLangStringPreferredNameTypeIEC61360AsSequence(
				decoder, current,
			)
		case "langStringShortNameTypeIec61360":
			instance, current, err = readLangStringShortNameTypeIEC61360AsSequence(
				decoder, current,
			)
		case "langStringDefinitionTypeIec61360":
			instance, current, err = readLangStringDefinitionTypeIEC61360AsSequence(
				decoder, current,
			)
		case "dataSpecificationIec61360":
			instance, current, err = readDataSpecificationIEC61360AsSequence(
				decoder, current,
			)
		default:
				err = newDeserializationError(
					fmt.Sprintf(
						"Unexpected XML element name %s as class discriminator",
						local,
					),
				)
	}
	if err != nil {
		return
	}

	err = checkEndElement(current, local)
	return
}

// endregion

// region Serialization

// Represent an error during the serialization.
//
// Implements `error`.
type SerializationError struct {
	Path    *aasreporting.Path
	Message string
}

func newSerializationError(message string) *SerializationError {
	return &SerializationError{
		Path:    &aasreporting.Path{},
		Message: message,
	}
}

func (se *SerializationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		se.PathString(),
		se.Message,
	)
}

// Render the path as a string.
func (se *SerializationError) PathString() string {
	return aasreporting.ToGolangPath(se.Path)
}

// Write the start element with the given `local` name to the encoder.
//
// Do not flush.
//
// If the `withNamespace` is set, set the [xml.Name.Space] property in the element
// accordingly.
func writeStartElement(
	encoder *xml.Encoder,
	local string,
	withNamespace bool,
) (err error) {
	startElement := xml.StartElement{Name: xml.Name{Local: local}}
	if withNamespace {
		startElement.Name.Space = Namespace
	}

	err = encoder.EncodeToken(startElement)
	return
}

// Write the end element with the given `local` name to the encoder.
//
// Do not flush.
//
// If the `withNamespace` is set, set the [xml.Name.Space] property in the element
// accordingly.
func writeEndElement(
	encoder *xml.Encoder,
	local string,
	withNamespace bool,
) (err error) {
	endElement := xml.EndElement{Name: xml.Name{Local: local}}
	if withNamespace {
		endElement.Name.Space = Namespace
	}

	err = encoder.EncodeToken(endElement)
	return
}

// Write the `text` to the encoder.
//
// Do not flush.
//
// If `text` is empty, do nothing.
func writeText(
	encoder *xml.Encoder,
	text string,
) (err error) {
	if len(text) > 0 {
		err = encoder.EncodeToken(
			xml.CharData([]byte(text)),
		)
	}
	return
}

// Write the `value` of a property as `xs:boolean` enclosed in an XML element.
//
// Do not flush.
//
// The XML namespace is expected to have been defined outside of the resulting XML
// element.
func writeBooleanProperty(
	encoder *xml.Encoder,
	local string,
	value bool,
) (err error) {
	err = writeStartElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	text := "true"
	if !value {
		text = "false"
	}
	err = writeText(encoder, text)
	if err != nil {
		return
	}

	err = writeEndElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	return
}

// Write the `value` of a property as `xs:long` enclosed in an XML element.
//
// Do not flush.
//
// The XML namespace is expected to have been defined outside of the resulting XML
// element.
func writeLongProperty(
	encoder *xml.Encoder,
	local string,
	value int64,
	withNamespace bool,
) (err error) {
	err = writeStartElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	text := strconv.FormatInt(value, 10)
	err = writeText(encoder, text)
	if err != nil {
		return
	}

	err = writeEndElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	return
}

// Write the `value` of a property as `xs:double` enclosed in an XML element.
//
// Do not flush.
//
// The XML namespace is expected to have been defined outside of the resulting XML
// element.
func writeDoubleProperty(
	encoder *xml.Encoder,
	local string,
	value float64,
) (err error) {
	err = writeStartElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	var text string

	// See: https://www.w3.org/TR/xmlschema-2/#double
	// for the exact literals.
	if math.IsInf(value, 0) {
		if value < 0 {
			text = "-INF"
		} else {
			text = "INF"
		}
	} else if math.IsNaN(value) {
		text = "NaN"
	} else {
		text = strconv.FormatFloat(value, 'g', -1, 64)
	}

	err = writeText(encoder, text)
	if err != nil {
		return
	}

	err = writeEndElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	return
}

// Write the `value` of a property as `xs:string` enclosed in an XML element.
//
// Do not flush.
//
// The XML namespace is expected to have been defined outside of the resulting XML
// element.
func writeStringProperty(
	encoder *xml.Encoder,
	local string,
	value string,
) (err error) {
	err = writeStartElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	err = writeText(encoder, value)
	if err != nil {
		return
	}

	err = writeEndElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	return
}

// Write the `value` of a property as base64-encoded bytes.
//
// Do not flush.
//
// The XML namespace is expected to have been defined outside of the resulting XML
// element.
func writeBytesProperty(
	encoder *xml.Encoder,
	local string,
	value []byte,
) (err error) {
	err = writeStartElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	text := b64.StdEncoding.EncodeToString(
		value,
	)

	err = writeText(encoder, text)
	if err != nil {
		return
	}

	err = writeEndElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	return
}

// Serialize the list of instances as a sequence of XML elements enclosed in a parent
// XML element with the `local` name.
func writeListProperty[T aastypes.IClass](
	encoder *xml.Encoder,
	local string,
	list []T,
) (err error) {
	err = writeStartElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	for i, item := range list {
		err = Marshal(
			encoder,
			item,
			false,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i,
					},
				)
			}
			return
		}
	}

	err = writeEndElement(
		encoder,
		local,
		false,
	)
	if err != nil {
		return
	}

	return
}

// Serialize the instance
// of [aastypes.IExtension]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeExtensionAsSequence(
	encoder *xml.Encoder,
	that aastypes.IExtension,
) (err error) {
	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Name

	err = writeStringProperty(
		encoder,
		"name",
		that.Name(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Name()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueType

	theValueType := that.ValueType()

	if theValueType != nil {
		err = writeDataTypeDefXSDProperty(
			encoder,
			"valueType",
			*theValueType,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueType()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeStringProperty(
			encoder,
			"value",
			*theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region RefersTo

	theRefersTo := that.RefersTo()

	if theRefersTo != nil {
		err = writeListProperty(
			encoder,
			"refersTo",
			theRefersTo,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "RefersTo()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IExtension]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeExtension(
	encoder *xml.Encoder,
	that aastypes.IExtension,
	withNamespace bool,
) (err error) {
	local := "extension"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeExtensionAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.ModellingKind]
// enclosed in an XML element.
//
// Do not flush.
func writeModellingKindProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.ModellingKind,
) (err error) {
	text, ok := aasstringification.ModellingKindToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of ModellingKind: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.IAdministrativeInformation]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeAdministrativeInformationAsSequence(
	encoder *xml.Encoder,
	that aastypes.IAdministrativeInformation,
) (err error) {
	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Version

	theVersion := that.Version()

	if theVersion != nil {
		err = writeStringProperty(
			encoder,
			"version",
			*theVersion,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Version()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Revision

	theRevision := that.Revision()

	if theRevision != nil {
		err = writeStringProperty(
			encoder,
			"revision",
			*theRevision,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Revision()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Creator

	theCreator := that.Creator()

	if theCreator != nil {
		err = writeStartElement(
			encoder,
			"creator",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theCreator,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Creator()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"creator",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region TemplateID

	theTemplateID := that.TemplateID()

	if theTemplateID != nil {
		err = writeStringProperty(
			encoder,
			"templateId",
			*theTemplateID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "TemplateID()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IAdministrativeInformation]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeAdministrativeInformation(
	encoder *xml.Encoder,
	that aastypes.IAdministrativeInformation,
	withNamespace bool,
) (err error) {
	local := "administrativeInformation"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeAdministrativeInformationAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.QualifierKind]
// enclosed in an XML element.
//
// Do not flush.
func writeQualifierKindProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.QualifierKind,
) (err error) {
	text, ok := aasstringification.QualifierKindToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of QualifierKind: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.IQualifier]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeQualifierAsSequence(
	encoder *xml.Encoder,
	that aastypes.IQualifier,
) (err error) {
	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Kind

	theKind := that.Kind()

	if theKind != nil {
		err = writeQualifierKindProperty(
			encoder,
			"kind",
			*theKind,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Kind()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Type

	err = writeStringProperty(
		encoder,
		"type",
		that.Type(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Type()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueType

	err = writeDataTypeDefXSDProperty(
		encoder,
		"valueType",
		that.ValueType(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueType()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeStringProperty(
			encoder,
			"value",
			*theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueID

	theValueID := that.ValueID()

	if theValueID != nil {
		err = writeStartElement(
			encoder,
			"valueId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theValueID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"valueId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IQualifier]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeQualifier(
	encoder *xml.Encoder,
	that aastypes.IQualifier,
	withNamespace bool,
) (err error) {
	local := "qualifier"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeQualifierAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IAssetAdministrationShell]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeAssetAdministrationShellAsSequence(
	encoder *xml.Encoder,
	that aastypes.IAssetAdministrationShell,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Administration

	theAdministration := that.Administration()

	if theAdministration != nil {
		err = writeStartElement(
			encoder,
			"administration",
			false,
		)
		if err != nil {
			return
		}
		err = writeAdministrativeInformationAsSequence(
			encoder,
			theAdministration,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"administration",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ID

	err = writeStringProperty(
		encoder,
		"id",
		that.ID(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DerivedFrom

	theDerivedFrom := that.DerivedFrom()

	if theDerivedFrom != nil {
		err = writeStartElement(
			encoder,
			"derivedFrom",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theDerivedFrom,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DerivedFrom()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"derivedFrom",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region AssetInformation

	err = writeStartElement(
		encoder,
		"assetInformation",
		false,
	)
	if err != nil {
		return
	}
	err = writeAssetInformationAsSequence(
		encoder,
		that.AssetInformation(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "AssetInformation()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"assetInformation",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Submodels

	theSubmodels := that.Submodels()

	if theSubmodels != nil {
		err = writeListProperty(
			encoder,
			"submodels",
			theSubmodels,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Submodels()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IAssetAdministrationShell]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeAssetAdministrationShell(
	encoder *xml.Encoder,
	that aastypes.IAssetAdministrationShell,
	withNamespace bool,
) (err error) {
	local := "assetAdministrationShell"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeAssetAdministrationShellAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IAssetInformation]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeAssetInformationAsSequence(
	encoder *xml.Encoder,
	that aastypes.IAssetInformation,
) (err error) {
	// region AssetKind

	err = writeAssetKindProperty(
		encoder,
		"assetKind",
		that.AssetKind(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "AssetKind()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region GlobalAssetID

	theGlobalAssetID := that.GlobalAssetID()

	if theGlobalAssetID != nil {
		err = writeStringProperty(
			encoder,
			"globalAssetId",
			*theGlobalAssetID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "GlobalAssetID()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SpecificAssetIDs

	theSpecificAssetIDs := that.SpecificAssetIDs()

	if theSpecificAssetIDs != nil {
		err = writeListProperty(
			encoder,
			"specificAssetIds",
			theSpecificAssetIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SpecificAssetIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region AssetType

	theAssetType := that.AssetType()

	if theAssetType != nil {
		err = writeStringProperty(
			encoder,
			"assetType",
			*theAssetType,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetType()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DefaultThumbnail

	theDefaultThumbnail := that.DefaultThumbnail()

	if theDefaultThumbnail != nil {
		err = writeStartElement(
			encoder,
			"defaultThumbnail",
			false,
		)
		if err != nil {
			return
		}
		err = writeResourceAsSequence(
			encoder,
			theDefaultThumbnail,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DefaultThumbnail()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"defaultThumbnail",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IAssetInformation]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeAssetInformation(
	encoder *xml.Encoder,
	that aastypes.IAssetInformation,
	withNamespace bool,
) (err error) {
	local := "assetInformation"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeAssetInformationAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IResource]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeResourceAsSequence(
	encoder *xml.Encoder,
	that aastypes.IResource,
) (err error) {
	// region Path

	err = writeStringProperty(
		encoder,
		"path",
		that.Path(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Path()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ContentType

	theContentType := that.ContentType()

	if theContentType != nil {
		err = writeStringProperty(
			encoder,
			"contentType",
			*theContentType,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ContentType()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IResource]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeResource(
	encoder *xml.Encoder,
	that aastypes.IResource,
	withNamespace bool,
) (err error) {
	local := "resource"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeResourceAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.AssetKind]
// enclosed in an XML element.
//
// Do not flush.
func writeAssetKindProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.AssetKind,
) (err error) {
	text, ok := aasstringification.AssetKindToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of AssetKind: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.ISpecificAssetID]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeSpecificAssetIDAsSequence(
	encoder *xml.Encoder,
	that aastypes.ISpecificAssetID,
) (err error) {
	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Name

	err = writeStringProperty(
		encoder,
		"name",
		that.Name(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Name()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	err = writeStringProperty(
		encoder,
		"value",
		that.Value(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ExternalSubjectID

	theExternalSubjectID := that.ExternalSubjectID()

	if theExternalSubjectID != nil {
		err = writeStartElement(
			encoder,
			"externalSubjectId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theExternalSubjectID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ExternalSubjectID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"externalSubjectId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ISpecificAssetID]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeSpecificAssetID(
	encoder *xml.Encoder,
	that aastypes.ISpecificAssetID,
	withNamespace bool,
) (err error) {
	local := "specificAssetId"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeSpecificAssetIDAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ISubmodel]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeSubmodelAsSequence(
	encoder *xml.Encoder,
	that aastypes.ISubmodel,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Administration

	theAdministration := that.Administration()

	if theAdministration != nil {
		err = writeStartElement(
			encoder,
			"administration",
			false,
		)
		if err != nil {
			return
		}
		err = writeAdministrativeInformationAsSequence(
			encoder,
			theAdministration,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"administration",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ID

	err = writeStringProperty(
		encoder,
		"id",
		that.ID(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Kind

	theKind := that.Kind()

	if theKind != nil {
		err = writeModellingKindProperty(
			encoder,
			"kind",
			*theKind,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Kind()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SubmodelElements

	theSubmodelElements := that.SubmodelElements()

	if theSubmodelElements != nil {
		err = writeListProperty(
			encoder,
			"submodelElements",
			theSubmodelElements,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SubmodelElements()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ISubmodel]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeSubmodel(
	encoder *xml.Encoder,
	that aastypes.ISubmodel,
	withNamespace bool,
) (err error) {
	local := "submodel"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeSubmodelAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IRelationshipElement]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeRelationshipElementAsSequence(
	encoder *xml.Encoder,
	that aastypes.IRelationshipElement,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region First

	err = writeStartElement(
		encoder,
		"first",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.First(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "First()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"first",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Second

	err = writeStartElement(
		encoder,
		"second",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.Second(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Second()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"second",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IRelationshipElement]
// enclosed in an XML element which represents the model type.
//
// Do not dispatch on the runtime model type, *i.e.*, assume that the runtime model type
// is exactly [aastypes.ModelTypeRelationshipElement]. If you need dispatch,
// call [Marshal].
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeRelationshipElementWithoutDispatch(
	encoder *xml.Encoder,
	that aastypes.IRelationshipElement,
	withNamespace bool,
) (err error) {
	local := "relationshipElement"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeRelationshipElementAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.AASSubmodelElements]
// enclosed in an XML element.
//
// Do not flush.
func writeAASSubmodelElementsProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.AASSubmodelElements,
) (err error) {
	text, ok := aasstringification.AASSubmodelElementsToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of AASSubmodelElements: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.ISubmodelElementList]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeSubmodelElementListAsSequence(
	encoder *xml.Encoder,
	that aastypes.ISubmodelElementList,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region OrderRelevant

	theOrderRelevant := that.OrderRelevant()

	if theOrderRelevant != nil {
		err = writeBooleanProperty(
			encoder,
			"orderRelevant",
			*theOrderRelevant,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "OrderRelevant()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticIDListElement

	theSemanticIDListElement := that.SemanticIDListElement()

	if theSemanticIDListElement != nil {
		err = writeStartElement(
			encoder,
			"semanticIdListElement",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticIDListElement,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticIDListElement()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticIdListElement",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region TypeValueListElement

	err = writeAASSubmodelElementsProperty(
		encoder,
		"typeValueListElement",
		that.TypeValueListElement(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "TypeValueListElement()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueTypeListElement

	theValueTypeListElement := that.ValueTypeListElement()

	if theValueTypeListElement != nil {
		err = writeDataTypeDefXSDProperty(
			encoder,
			"valueTypeListElement",
			*theValueTypeListElement,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueTypeListElement()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeListProperty(
			encoder,
			"value",
			theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ISubmodelElementList]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeSubmodelElementList(
	encoder *xml.Encoder,
	that aastypes.ISubmodelElementList,
	withNamespace bool,
) (err error) {
	local := "submodelElementList"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeSubmodelElementListAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ISubmodelElementCollection]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeSubmodelElementCollectionAsSequence(
	encoder *xml.Encoder,
	that aastypes.ISubmodelElementCollection,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeListProperty(
			encoder,
			"value",
			theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ISubmodelElementCollection]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeSubmodelElementCollection(
	encoder *xml.Encoder,
	that aastypes.ISubmodelElementCollection,
	withNamespace bool,
) (err error) {
	local := "submodelElementCollection"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeSubmodelElementCollectionAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IProperty]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writePropertyAsSequence(
	encoder *xml.Encoder,
	that aastypes.IProperty,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueType

	err = writeDataTypeDefXSDProperty(
		encoder,
		"valueType",
		that.ValueType(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueType()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeStringProperty(
			encoder,
			"value",
			*theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueID

	theValueID := that.ValueID()

	if theValueID != nil {
		err = writeStartElement(
			encoder,
			"valueId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theValueID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"valueId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IProperty]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeProperty(
	encoder *xml.Encoder,
	that aastypes.IProperty,
	withNamespace bool,
) (err error) {
	local := "property"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writePropertyAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IMultiLanguageProperty]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeMultiLanguagePropertyAsSequence(
	encoder *xml.Encoder,
	that aastypes.IMultiLanguageProperty,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeListProperty(
			encoder,
			"value",
			theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueID

	theValueID := that.ValueID()

	if theValueID != nil {
		err = writeStartElement(
			encoder,
			"valueId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theValueID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"valueId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IMultiLanguageProperty]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeMultiLanguageProperty(
	encoder *xml.Encoder,
	that aastypes.IMultiLanguageProperty,
	withNamespace bool,
) (err error) {
	local := "multiLanguageProperty"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeMultiLanguagePropertyAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IRange]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeRangeAsSequence(
	encoder *xml.Encoder,
	that aastypes.IRange,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueType

	err = writeDataTypeDefXSDProperty(
		encoder,
		"valueType",
		that.ValueType(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueType()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Min

	theMin := that.Min()

	if theMin != nil {
		err = writeStringProperty(
			encoder,
			"min",
			*theMin,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Min()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Max

	theMax := that.Max()

	if theMax != nil {
		err = writeStringProperty(
			encoder,
			"max",
			*theMax,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Max()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IRange]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeRange(
	encoder *xml.Encoder,
	that aastypes.IRange,
	withNamespace bool,
) (err error) {
	local := "range"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeRangeAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IReferenceElement]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeReferenceElementAsSequence(
	encoder *xml.Encoder,
	that aastypes.IReferenceElement,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeStartElement(
			encoder,
			"value",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"value",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IReferenceElement]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeReferenceElement(
	encoder *xml.Encoder,
	that aastypes.IReferenceElement,
	withNamespace bool,
) (err error) {
	local := "referenceElement"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeReferenceElementAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IBlob]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeBlobAsSequence(
	encoder *xml.Encoder,
	that aastypes.IBlob,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeBytesProperty(
			encoder,
			"value",
			theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ContentType

	err = writeStringProperty(
		encoder,
		"contentType",
		that.ContentType(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ContentType()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IBlob]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeBlob(
	encoder *xml.Encoder,
	that aastypes.IBlob,
	withNamespace bool,
) (err error) {
	local := "blob"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeBlobAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IFile]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeFileAsSequence(
	encoder *xml.Encoder,
	that aastypes.IFile,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeStringProperty(
			encoder,
			"value",
			*theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ContentType

	err = writeStringProperty(
		encoder,
		"contentType",
		that.ContentType(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ContentType()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IFile]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeFile(
	encoder *xml.Encoder,
	that aastypes.IFile,
	withNamespace bool,
) (err error) {
	local := "file"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeFileAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IAnnotatedRelationshipElement]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeAnnotatedRelationshipElementAsSequence(
	encoder *xml.Encoder,
	that aastypes.IAnnotatedRelationshipElement,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region First

	err = writeStartElement(
		encoder,
		"first",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.First(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "First()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"first",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Second

	err = writeStartElement(
		encoder,
		"second",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.Second(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Second()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"second",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Annotations

	theAnnotations := that.Annotations()

	if theAnnotations != nil {
		err = writeListProperty(
			encoder,
			"annotations",
			theAnnotations,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Annotations()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IAnnotatedRelationshipElement]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeAnnotatedRelationshipElement(
	encoder *xml.Encoder,
	that aastypes.IAnnotatedRelationshipElement,
	withNamespace bool,
) (err error) {
	local := "annotatedRelationshipElement"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeAnnotatedRelationshipElementAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IEntity]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeEntityAsSequence(
	encoder *xml.Encoder,
	that aastypes.IEntity,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Statements

	theStatements := that.Statements()

	if theStatements != nil {
		err = writeListProperty(
			encoder,
			"statements",
			theStatements,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Statements()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EntityType

	err = writeEntityTypeProperty(
		encoder,
		"entityType",
		that.EntityType(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "EntityType()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region GlobalAssetID

	theGlobalAssetID := that.GlobalAssetID()

	if theGlobalAssetID != nil {
		err = writeStringProperty(
			encoder,
			"globalAssetId",
			*theGlobalAssetID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "GlobalAssetID()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SpecificAssetIDs

	theSpecificAssetIDs := that.SpecificAssetIDs()

	if theSpecificAssetIDs != nil {
		err = writeListProperty(
			encoder,
			"specificAssetIds",
			theSpecificAssetIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SpecificAssetIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IEntity]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeEntity(
	encoder *xml.Encoder,
	that aastypes.IEntity,
	withNamespace bool,
) (err error) {
	local := "entity"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeEntityAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.EntityType]
// enclosed in an XML element.
//
// Do not flush.
func writeEntityTypeProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.EntityType,
) (err error) {
	text, ok := aasstringification.EntityTypeToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of EntityType: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Write the `value` of a property as string representation
// of [aastypes.Direction]
// enclosed in an XML element.
//
// Do not flush.
func writeDirectionProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.Direction,
) (err error) {
	text, ok := aasstringification.DirectionToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of Direction: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Write the `value` of a property as string representation
// of [aastypes.StateOfEvent]
// enclosed in an XML element.
//
// Do not flush.
func writeStateOfEventProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.StateOfEvent,
) (err error) {
	text, ok := aasstringification.StateOfEventToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of StateOfEvent: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.IEventPayload]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeEventPayloadAsSequence(
	encoder *xml.Encoder,
	that aastypes.IEventPayload,
) (err error) {
	// region Source

	err = writeStartElement(
		encoder,
		"source",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.Source(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Source()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"source",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SourceSemanticID

	theSourceSemanticID := that.SourceSemanticID()

	if theSourceSemanticID != nil {
		err = writeStartElement(
			encoder,
			"sourceSemanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSourceSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SourceSemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"sourceSemanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ObservableReference

	err = writeStartElement(
		encoder,
		"observableReference",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.ObservableReference(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ObservableReference()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"observableReference",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ObservableSemanticID

	theObservableSemanticID := that.ObservableSemanticID()

	if theObservableSemanticID != nil {
		err = writeStartElement(
			encoder,
			"observableSemanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theObservableSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ObservableSemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"observableSemanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Topic

	theTopic := that.Topic()

	if theTopic != nil {
		err = writeStringProperty(
			encoder,
			"topic",
			*theTopic,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Topic()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SubjectID

	theSubjectID := that.SubjectID()

	if theSubjectID != nil {
		err = writeStartElement(
			encoder,
			"subjectId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSubjectID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SubjectID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"subjectId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region TimeStamp

	err = writeStringProperty(
		encoder,
		"timeStamp",
		that.TimeStamp(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "TimeStamp()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Payload

	thePayload := that.Payload()

	if thePayload != nil {
		err = writeBytesProperty(
			encoder,
			"payload",
			thePayload,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Payload()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IEventPayload]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeEventPayload(
	encoder *xml.Encoder,
	that aastypes.IEventPayload,
	withNamespace bool,
) (err error) {
	local := "eventPayload"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeEventPayloadAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IBasicEventElement]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeBasicEventElementAsSequence(
	encoder *xml.Encoder,
	that aastypes.IBasicEventElement,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Observed

	err = writeStartElement(
		encoder,
		"observed",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.Observed(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Observed()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"observed",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Direction

	err = writeDirectionProperty(
		encoder,
		"direction",
		that.Direction(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Direction()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region State

	err = writeStateOfEventProperty(
		encoder,
		"state",
		that.State(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "State()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region MessageTopic

	theMessageTopic := that.MessageTopic()

	if theMessageTopic != nil {
		err = writeStringProperty(
			encoder,
			"messageTopic",
			*theMessageTopic,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MessageTopic()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region MessageBroker

	theMessageBroker := that.MessageBroker()

	if theMessageBroker != nil {
		err = writeStartElement(
			encoder,
			"messageBroker",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theMessageBroker,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MessageBroker()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"messageBroker",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region LastUpdate

	theLastUpdate := that.LastUpdate()

	if theLastUpdate != nil {
		err = writeStringProperty(
			encoder,
			"lastUpdate",
			*theLastUpdate,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "LastUpdate()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region MinInterval

	theMinInterval := that.MinInterval()

	if theMinInterval != nil {
		err = writeStringProperty(
			encoder,
			"minInterval",
			*theMinInterval,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MinInterval()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region MaxInterval

	theMaxInterval := that.MaxInterval()

	if theMaxInterval != nil {
		err = writeStringProperty(
			encoder,
			"maxInterval",
			*theMaxInterval,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MaxInterval()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IBasicEventElement]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeBasicEventElement(
	encoder *xml.Encoder,
	that aastypes.IBasicEventElement,
	withNamespace bool,
) (err error) {
	local := "basicEventElement"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeBasicEventElementAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IOperation]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeOperationAsSequence(
	encoder *xml.Encoder,
	that aastypes.IOperation,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region InputVariables

	theInputVariables := that.InputVariables()

	if theInputVariables != nil {
		err = writeListProperty(
			encoder,
			"inputVariables",
			theInputVariables,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "InputVariables()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region OutputVariables

	theOutputVariables := that.OutputVariables()

	if theOutputVariables != nil {
		err = writeListProperty(
			encoder,
			"outputVariables",
			theOutputVariables,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "OutputVariables()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region InoutputVariables

	theInoutputVariables := that.InoutputVariables()

	if theInoutputVariables != nil {
		err = writeListProperty(
			encoder,
			"inoutputVariables",
			theInoutputVariables,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "InoutputVariables()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IOperation]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeOperation(
	encoder *xml.Encoder,
	that aastypes.IOperation,
	withNamespace bool,
) (err error) {
	local := "operation"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeOperationAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IOperationVariable]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeOperationVariableAsSequence(
	encoder *xml.Encoder,
	that aastypes.IOperationVariable,
) (err error) {
	// region Value

	err = writeStartElement(
		encoder,
		"value",
	false,
	)
	if err != nil {
		return
	}
	err = Marshal(
		encoder,
		that.Value(),
		false,
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"value",
	false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IOperationVariable]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeOperationVariable(
	encoder *xml.Encoder,
	that aastypes.IOperationVariable,
	withNamespace bool,
) (err error) {
	local := "operationVariable"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeOperationVariableAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ICapability]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeCapabilityAsSequence(
	encoder *xml.Encoder,
	that aastypes.ICapability,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SemanticID

	theSemanticID := that.SemanticID()

	if theSemanticID != nil {
		err = writeStartElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"semanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SupplementalSemanticIDs

	theSupplementalSemanticIDs := that.SupplementalSemanticIDs()

	if theSupplementalSemanticIDs != nil {
		err = writeListProperty(
			encoder,
			"supplementalSemanticIds",
			theSupplementalSemanticIDs,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Qualifiers

	theQualifiers := that.Qualifiers()

	if theQualifiers != nil {
		err = writeListProperty(
			encoder,
			"qualifiers",
			theQualifiers,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ICapability]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeCapability(
	encoder *xml.Encoder,
	that aastypes.ICapability,
	withNamespace bool,
) (err error) {
	local := "capability"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeCapabilityAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IConceptDescription]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeConceptDescriptionAsSequence(
	encoder *xml.Encoder,
	that aastypes.IConceptDescription,
) (err error) {
	// region Extensions

	theExtensions := that.Extensions()

	if theExtensions != nil {
		err = writeListProperty(
			encoder,
			"extensions",
			theExtensions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Category

	theCategory := that.Category()

	if theCategory != nil {
		err = writeStringProperty(
			encoder,
			"category",
			*theCategory,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IDShort

	theIDShort := that.IDShort()

	if theIDShort != nil {
		err = writeStringProperty(
			encoder,
			"idShort",
			*theIDShort,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DisplayName

	theDisplayName := that.DisplayName()

	if theDisplayName != nil {
		err = writeListProperty(
			encoder,
			"displayName",
			theDisplayName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Description

	theDescription := that.Description()

	if theDescription != nil {
		err = writeListProperty(
			encoder,
			"description",
			theDescription,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Administration

	theAdministration := that.Administration()

	if theAdministration != nil {
		err = writeStartElement(
			encoder,
			"administration",
			false,
		)
		if err != nil {
			return
		}
		err = writeAdministrativeInformationAsSequence(
			encoder,
			theAdministration,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"administration",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ID

	err = writeStringProperty(
		encoder,
		"id",
		that.ID(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region EmbeddedDataSpecifications

	theEmbeddedDataSpecifications := that.EmbeddedDataSpecifications()

	if theEmbeddedDataSpecifications != nil {
		err = writeListProperty(
			encoder,
			"embeddedDataSpecifications",
			theEmbeddedDataSpecifications,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region IsCaseOf

	theIsCaseOf := that.IsCaseOf()

	if theIsCaseOf != nil {
		err = writeListProperty(
			encoder,
			"isCaseOf",
			theIsCaseOf,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IsCaseOf()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IConceptDescription]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeConceptDescription(
	encoder *xml.Encoder,
	that aastypes.IConceptDescription,
	withNamespace bool,
) (err error) {
	local := "conceptDescription"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeConceptDescriptionAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.ReferenceTypes]
// enclosed in an XML element.
//
// Do not flush.
func writeReferenceTypesProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.ReferenceTypes,
) (err error) {
	text, ok := aasstringification.ReferenceTypesToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of ReferenceTypes: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.IReference]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeReferenceAsSequence(
	encoder *xml.Encoder,
	that aastypes.IReference,
) (err error) {
	// region Type

	err = writeReferenceTypesProperty(
		encoder,
		"type",
		that.Type(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Type()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ReferredSemanticID

	theReferredSemanticID := that.ReferredSemanticID()

	if theReferredSemanticID != nil {
		err = writeStartElement(
			encoder,
			"referredSemanticId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theReferredSemanticID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ReferredSemanticID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"referredSemanticId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Keys

	err = writeListProperty(
		encoder,
		"keys",
		that.Keys(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Keys()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IReference]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeReference(
	encoder *xml.Encoder,
	that aastypes.IReference,
	withNamespace bool,
) (err error) {
	local := "reference"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeReferenceAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IKey]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeKeyAsSequence(
	encoder *xml.Encoder,
	that aastypes.IKey,
) (err error) {
	// region Type

	err = writeKeyTypesProperty(
		encoder,
		"type",
		that.Type(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Type()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	err = writeStringProperty(
		encoder,
		"value",
		that.Value(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IKey]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeKey(
	encoder *xml.Encoder,
	that aastypes.IKey,
	withNamespace bool,
) (err error) {
	local := "key"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeKeyAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.KeyTypes]
// enclosed in an XML element.
//
// Do not flush.
func writeKeyTypesProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.KeyTypes,
) (err error) {
	text, ok := aasstringification.KeyTypesToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of KeyTypes: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Write the `value` of a property as string representation
// of [aastypes.DataTypeDefXSD]
// enclosed in an XML element.
//
// Do not flush.
func writeDataTypeDefXSDProperty(
	encoder *xml.Encoder,
	local string,
	value aastypes.DataTypeDefXSD,
) (err error) {
	text, ok := aasstringification.DataTypeDefXSDToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of DataTypeDefXSD: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.ILangStringNameType]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeLangStringNameTypeAsSequence(
	encoder *xml.Encoder,
	that aastypes.ILangStringNameType,
) (err error) {
	// region Language

	err = writeStringProperty(
		encoder,
		"language",
		that.Language(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Text

	err = writeStringProperty(
		encoder,
		"text",
		that.Text(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ILangStringNameType]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeLangStringNameType(
	encoder *xml.Encoder,
	that aastypes.ILangStringNameType,
	withNamespace bool,
) (err error) {
	local := "langStringNameType"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeLangStringNameTypeAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ILangStringTextType]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeLangStringTextTypeAsSequence(
	encoder *xml.Encoder,
	that aastypes.ILangStringTextType,
) (err error) {
	// region Language

	err = writeStringProperty(
		encoder,
		"language",
		that.Language(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Text

	err = writeStringProperty(
		encoder,
		"text",
		that.Text(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ILangStringTextType]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeLangStringTextType(
	encoder *xml.Encoder,
	that aastypes.ILangStringTextType,
	withNamespace bool,
) (err error) {
	local := "langStringTextType"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeLangStringTextTypeAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IEnvironment]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeEnvironmentAsSequence(
	encoder *xml.Encoder,
	that aastypes.IEnvironment,
) (err error) {
	// region AssetAdministrationShells

	theAssetAdministrationShells := that.AssetAdministrationShells()

	if theAssetAdministrationShells != nil {
		err = writeListProperty(
			encoder,
			"assetAdministrationShells",
			theAssetAdministrationShells,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetAdministrationShells()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Submodels

	theSubmodels := that.Submodels()

	if theSubmodels != nil {
		err = writeListProperty(
			encoder,
			"submodels",
			theSubmodels,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Submodels()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ConceptDescriptions

	theConceptDescriptions := that.ConceptDescriptions()

	if theConceptDescriptions != nil {
		err = writeListProperty(
			encoder,
			"conceptDescriptions",
			theConceptDescriptions,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ConceptDescriptions()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IEnvironment]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeEnvironment(
	encoder *xml.Encoder,
	that aastypes.IEnvironment,
	withNamespace bool,
) (err error) {
	local := "environment"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeEnvironmentAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IEmbeddedDataSpecification]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeEmbeddedDataSpecificationAsSequence(
	encoder *xml.Encoder,
	that aastypes.IEmbeddedDataSpecification,
) (err error) {
	// region DataSpecificationContent

	err = writeStartElement(
		encoder,
		"dataSpecificationContent",
	false,
	)
	if err != nil {
		return
	}
	err = Marshal(
		encoder,
		that.DataSpecificationContent(),
		false,
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DataSpecificationContent()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"dataSpecificationContent",
	false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DataSpecification

	theDataSpecification := that.DataSpecification()

	if theDataSpecification != nil {
		err = writeStartElement(
			encoder,
			"dataSpecification",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theDataSpecification,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DataSpecification()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"dataSpecification",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IEmbeddedDataSpecification]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeEmbeddedDataSpecification(
	encoder *xml.Encoder,
	that aastypes.IEmbeddedDataSpecification,
	withNamespace bool,
) (err error) {
	local := "embeddedDataSpecification"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeEmbeddedDataSpecificationAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Write the `value` of a property as string representation
// of [aastypes.DataTypeIEC61360]
// enclosed in an XML element.
//
// Do not flush.
func writeDataTypeIEC61360Property(
	encoder *xml.Encoder,
	local string,
	value aastypes.DataTypeIEC61360,
) (err error) {
	text, ok := aasstringification.DataTypeIEC61360ToString(
		value,
	)
	if !ok {
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected literal of DataTypeIEC61360: %v",
				value,
			),
		)
		return
	}

	err = writeStringProperty(encoder, local, text)
	return
}

// Serialize the instance
// of [aastypes.ILevelType]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeLevelTypeAsSequence(
	encoder *xml.Encoder,
	that aastypes.ILevelType,
) (err error) {
	// region Min

	err = writeBooleanProperty(
		encoder,
		"min",
		that.Min(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Min()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Nom

	err = writeBooleanProperty(
		encoder,
		"nom",
		that.Nom(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Nom()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Typ

	err = writeBooleanProperty(
		encoder,
		"typ",
		that.Typ(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Typ()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Max

	err = writeBooleanProperty(
		encoder,
		"max",
		that.Max(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Max()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ILevelType]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeLevelType(
	encoder *xml.Encoder,
	that aastypes.ILevelType,
	withNamespace bool,
) (err error) {
	local := "levelType"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeLevelTypeAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IValueReferencePair]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeValueReferencePairAsSequence(
	encoder *xml.Encoder,
	that aastypes.IValueReferencePair,
) (err error) {
	// region Value

	err = writeStringProperty(
		encoder,
		"value",
		that.Value(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueID

	err = writeStartElement(
		encoder,
		"valueId",
		false,
	)
	if err != nil {
		return
	}
	err = writeReferenceAsSequence(
		encoder,
		that.ValueID(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID()",
				},
			)
		}
		return
	}
	err = writeEndElement(
		encoder,
		"valueId",
		false,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IValueReferencePair]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeValueReferencePair(
	encoder *xml.Encoder,
	that aastypes.IValueReferencePair,
	withNamespace bool,
) (err error) {
	local := "valueReferencePair"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeValueReferencePairAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IValueList]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeValueListAsSequence(
	encoder *xml.Encoder,
	that aastypes.IValueList,
) (err error) {
	// region ValueReferencePairs

	err = writeListProperty(
		encoder,
		"valueReferencePairs",
		that.ValueReferencePairs(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueReferencePairs()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IValueList]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeValueList(
	encoder *xml.Encoder,
	that aastypes.IValueList,
	withNamespace bool,
) (err error) {
	local := "valueList"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeValueListAsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ILangStringPreferredNameTypeIEC61360]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeLangStringPreferredNameTypeIEC61360AsSequence(
	encoder *xml.Encoder,
	that aastypes.ILangStringPreferredNameTypeIEC61360,
) (err error) {
	// region Language

	err = writeStringProperty(
		encoder,
		"language",
		that.Language(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Text

	err = writeStringProperty(
		encoder,
		"text",
		that.Text(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ILangStringPreferredNameTypeIEC61360]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeLangStringPreferredNameTypeIEC61360(
	encoder *xml.Encoder,
	that aastypes.ILangStringPreferredNameTypeIEC61360,
	withNamespace bool,
) (err error) {
	local := "langStringPreferredNameTypeIec61360"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeLangStringPreferredNameTypeIEC61360AsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ILangStringShortNameTypeIEC61360]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeLangStringShortNameTypeIEC61360AsSequence(
	encoder *xml.Encoder,
	that aastypes.ILangStringShortNameTypeIEC61360,
) (err error) {
	// region Language

	err = writeStringProperty(
		encoder,
		"language",
		that.Language(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Text

	err = writeStringProperty(
		encoder,
		"text",
		that.Text(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ILangStringShortNameTypeIEC61360]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeLangStringShortNameTypeIEC61360(
	encoder *xml.Encoder,
	that aastypes.ILangStringShortNameTypeIEC61360,
	withNamespace bool,
) (err error) {
	local := "langStringShortNameTypeIec61360"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeLangStringShortNameTypeIEC61360AsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.ILangStringDefinitionTypeIEC61360]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeLangStringDefinitionTypeIEC61360AsSequence(
	encoder *xml.Encoder,
	that aastypes.ILangStringDefinitionTypeIEC61360,
) (err error) {
	// region Language

	err = writeStringProperty(
		encoder,
		"language",
		that.Language(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Text

	err = writeStringProperty(
		encoder,
		"text",
		that.Text(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.ILangStringDefinitionTypeIEC61360]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeLangStringDefinitionTypeIEC61360(
	encoder *xml.Encoder,
	that aastypes.ILangStringDefinitionTypeIEC61360,
	withNamespace bool,
) (err error) {
	local := "langStringDefinitionTypeIec61360"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeLangStringDefinitionTypeIEC61360AsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize the instance
// of [aastypes.IDataSpecificationIEC61360]
// as a sequence of properties, each represented as an XML element.
//
// The XML namespace is expected to be set in the one of the parent elements
// enclosing the sequence.
//
// Flush at the end element of each property.
func writeDataSpecificationIEC61360AsSequence(
	encoder *xml.Encoder,
	that aastypes.IDataSpecificationIEC61360,
) (err error) {
	// region PreferredName

	err = writeListProperty(
		encoder,
		"preferredName",
		that.PreferredName(),
	)
	if err != nil {
		if seriaErr, ok := err.(*SerializationError); ok {
			seriaErr.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "PreferredName()",
				},
			)
		}
		return
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ShortName

	theShortName := that.ShortName()

	if theShortName != nil {
		err = writeListProperty(
			encoder,
			"shortName",
			theShortName,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ShortName()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Unit

	theUnit := that.Unit()

	if theUnit != nil {
		err = writeStringProperty(
			encoder,
			"unit",
			*theUnit,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Unit()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region UnitID

	theUnitID := that.UnitID()

	if theUnitID != nil {
		err = writeStartElement(
			encoder,
			"unitId",
			false,
		)
		if err != nil {
			return
		}
		err = writeReferenceAsSequence(
			encoder,
			theUnitID,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "UnitID()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"unitId",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region SourceOfDefinition

	theSourceOfDefinition := that.SourceOfDefinition()

	if theSourceOfDefinition != nil {
		err = writeStringProperty(
			encoder,
			"sourceOfDefinition",
			*theSourceOfDefinition,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SourceOfDefinition()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Symbol

	theSymbol := that.Symbol()

	if theSymbol != nil {
		err = writeStringProperty(
			encoder,
			"symbol",
			*theSymbol,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Symbol()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region DataType

	theDataType := that.DataType()

	if theDataType != nil {
		err = writeDataTypeIEC61360Property(
			encoder,
			"dataType",
			*theDataType,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DataType()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Definition

	theDefinition := that.Definition()

	if theDefinition != nil {
		err = writeListProperty(
			encoder,
			"definition",
			theDefinition,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Definition()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueFormat

	theValueFormat := that.ValueFormat()

	if theValueFormat != nil {
		err = writeStringProperty(
			encoder,
			"valueFormat",
			*theValueFormat,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueFormat()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region ValueList

	theValueList := that.ValueList()

	if theValueList != nil {
		err = writeStartElement(
			encoder,
			"valueList",
			false,
		)
		if err != nil {
			return
		}
		err = writeValueListAsSequence(
			encoder,
			theValueList,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueList()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"valueList",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region Value

	theValue := that.Value()

	if theValue != nil {
		err = writeStringProperty(
			encoder,
			"value",
			*theValue,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value()",
					},
				)
			}
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	// region LevelType

	theLevelType := that.LevelType()

	if theLevelType != nil {
		err = writeStartElement(
			encoder,
			"levelType",
			false,
		)
		if err != nil {
			return
		}
		err = writeLevelTypeAsSequence(
			encoder,
			theLevelType,
		)
		if err != nil {
			if seriaErr, ok := err.(*SerializationError); ok {
				seriaErr.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "LevelType()",
					},
				)
			}
			return
		}
		err = writeEndElement(
			encoder,
			"levelType",
			false,
		)
		if err != nil {
			return
		}
	}

	err = encoder.Flush()
	if err != nil {
		return err
	}

	// endregion

	return
}

// Serialize the instance of [aastypes.IDataSpecificationIEC61360]
// enclosed in an XML element which represents the model type.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the outer XML element.
//
// Flush once the closing end element has been written.
func writeDataSpecificationIEC61360(
	encoder *xml.Encoder,
	that aastypes.IDataSpecificationIEC61360,
	withNamespace bool,
) (err error) {
	local := "dataSpecificationIec61360"
	
	err = writeStartElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = writeDataSpecificationIEC61360AsSequence(
		encoder,
		that,
	)
	if err != nil {
		return
	}
	
	err = writeEndElement(
		encoder,
		local,
		withNamespace,
	)
	if err != nil {
		return
	}

	err = encoder.Flush()
	return
}

// Serialize `that` instance as an XML element.
//
// If `withNamespace` is set, the `xmlns` attribute is set in the XML element
// to [Namespace].
func Marshal(
	encoder *xml.Encoder,
	that aastypes.IClass,
	withNamespace bool,
) (err error) {
	switch that.ModelType() {
	case aastypes.ModelTypeExtension:
		err = writeExtension(
			encoder,
			that.(aastypes.IExtension),
			withNamespace,
		)
	case aastypes.ModelTypeAdministrativeInformation:
		err = writeAdministrativeInformation(
			encoder,
			that.(aastypes.IAdministrativeInformation),
			withNamespace,
		)
	case aastypes.ModelTypeQualifier:
		err = writeQualifier(
			encoder,
			that.(aastypes.IQualifier),
			withNamespace,
		)
	case aastypes.ModelTypeAssetAdministrationShell:
		err = writeAssetAdministrationShell(
			encoder,
			that.(aastypes.IAssetAdministrationShell),
			withNamespace,
		)
	case aastypes.ModelTypeAssetInformation:
		err = writeAssetInformation(
			encoder,
			that.(aastypes.IAssetInformation),
			withNamespace,
		)
	case aastypes.ModelTypeResource:
		err = writeResource(
			encoder,
			that.(aastypes.IResource),
			withNamespace,
		)
	case aastypes.ModelTypeSpecificAssetID:
		err = writeSpecificAssetID(
			encoder,
			that.(aastypes.ISpecificAssetID),
			withNamespace,
		)
	case aastypes.ModelTypeSubmodel:
		err = writeSubmodel(
			encoder,
			that.(aastypes.ISubmodel),
			withNamespace,
		)
	case aastypes.ModelTypeRelationshipElement:
		err = writeRelationshipElementWithoutDispatch(
			encoder,
			that.(aastypes.IRelationshipElement),
			withNamespace,
		)
	case aastypes.ModelTypeSubmodelElementList:
		err = writeSubmodelElementList(
			encoder,
			that.(aastypes.ISubmodelElementList),
			withNamespace,
		)
	case aastypes.ModelTypeSubmodelElementCollection:
		err = writeSubmodelElementCollection(
			encoder,
			that.(aastypes.ISubmodelElementCollection),
			withNamespace,
		)
	case aastypes.ModelTypeProperty:
		err = writeProperty(
			encoder,
			that.(aastypes.IProperty),
			withNamespace,
		)
	case aastypes.ModelTypeMultiLanguageProperty:
		err = writeMultiLanguageProperty(
			encoder,
			that.(aastypes.IMultiLanguageProperty),
			withNamespace,
		)
	case aastypes.ModelTypeRange:
		err = writeRange(
			encoder,
			that.(aastypes.IRange),
			withNamespace,
		)
	case aastypes.ModelTypeReferenceElement:
		err = writeReferenceElement(
			encoder,
			that.(aastypes.IReferenceElement),
			withNamespace,
		)
	case aastypes.ModelTypeBlob:
		err = writeBlob(
			encoder,
			that.(aastypes.IBlob),
			withNamespace,
		)
	case aastypes.ModelTypeFile:
		err = writeFile(
			encoder,
			that.(aastypes.IFile),
			withNamespace,
		)
	case aastypes.ModelTypeAnnotatedRelationshipElement:
		err = writeAnnotatedRelationshipElement(
			encoder,
			that.(aastypes.IAnnotatedRelationshipElement),
			withNamespace,
		)
	case aastypes.ModelTypeEntity:
		err = writeEntity(
			encoder,
			that.(aastypes.IEntity),
			withNamespace,
		)
	case aastypes.ModelTypeEventPayload:
		err = writeEventPayload(
			encoder,
			that.(aastypes.IEventPayload),
			withNamespace,
		)
	case aastypes.ModelTypeBasicEventElement:
		err = writeBasicEventElement(
			encoder,
			that.(aastypes.IBasicEventElement),
			withNamespace,
		)
	case aastypes.ModelTypeOperation:
		err = writeOperation(
			encoder,
			that.(aastypes.IOperation),
			withNamespace,
		)
	case aastypes.ModelTypeOperationVariable:
		err = writeOperationVariable(
			encoder,
			that.(aastypes.IOperationVariable),
			withNamespace,
		)
	case aastypes.ModelTypeCapability:
		err = writeCapability(
			encoder,
			that.(aastypes.ICapability),
			withNamespace,
		)
	case aastypes.ModelTypeConceptDescription:
		err = writeConceptDescription(
			encoder,
			that.(aastypes.IConceptDescription),
			withNamespace,
		)
	case aastypes.ModelTypeReference:
		err = writeReference(
			encoder,
			that.(aastypes.IReference),
			withNamespace,
		)
	case aastypes.ModelTypeKey:
		err = writeKey(
			encoder,
			that.(aastypes.IKey),
			withNamespace,
		)
	case aastypes.ModelTypeLangStringNameType:
		err = writeLangStringNameType(
			encoder,
			that.(aastypes.ILangStringNameType),
			withNamespace,
		)
	case aastypes.ModelTypeLangStringTextType:
		err = writeLangStringTextType(
			encoder,
			that.(aastypes.ILangStringTextType),
			withNamespace,
		)
	case aastypes.ModelTypeEnvironment:
		err = writeEnvironment(
			encoder,
			that.(aastypes.IEnvironment),
			withNamespace,
		)
	case aastypes.ModelTypeEmbeddedDataSpecification:
		err = writeEmbeddedDataSpecification(
			encoder,
			that.(aastypes.IEmbeddedDataSpecification),
			withNamespace,
		)
	case aastypes.ModelTypeLevelType:
		err = writeLevelType(
			encoder,
			that.(aastypes.ILevelType),
			withNamespace,
		)
	case aastypes.ModelTypeValueReferencePair:
		err = writeValueReferencePair(
			encoder,
			that.(aastypes.IValueReferencePair),
			withNamespace,
		)
	case aastypes.ModelTypeValueList:
		err = writeValueList(
			encoder,
			that.(aastypes.IValueList),
			withNamespace,
		)
	case aastypes.ModelTypeLangStringPreferredNameTypeIEC61360:
		err = writeLangStringPreferredNameTypeIEC61360(
			encoder,
			that.(aastypes.ILangStringPreferredNameTypeIEC61360),
			withNamespace,
		)
	case aastypes.ModelTypeLangStringShortNameTypeIEC61360:
		err = writeLangStringShortNameTypeIEC61360(
			encoder,
			that.(aastypes.ILangStringShortNameTypeIEC61360),
			withNamespace,
		)
	case aastypes.ModelTypeLangStringDefinitionTypeIEC61360:
		err = writeLangStringDefinitionTypeIEC61360(
			encoder,
			that.(aastypes.ILangStringDefinitionTypeIEC61360),
			withNamespace,
		)
	case aastypes.ModelTypeDataSpecificationIEC61360:
		err = writeDataSpecificationIEC61360(
			encoder,
			that.(aastypes.IDataSpecificationIEC61360),
			withNamespace,
		)
	default:
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected model type: %v",
				that.ModelType(),
			),
		)
	}
	return
}

// endregion

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
