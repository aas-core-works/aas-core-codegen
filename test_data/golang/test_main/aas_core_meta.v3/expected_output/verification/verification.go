// Package verification allows you to verify model instances.
//
// The main function is [Verify].
//
// Other verification functions (`Verify*`) are left for modularity, in case you want
// to be explicit about the typing in your code. However, in the large majority of
// the cases, you only want to call [Verify].
package verification

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	"math/big"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	aascommon "github.com/aas-core-works/aas-core3.0-golang/common"
	aasconstants "github.com/aas-core-works/aas-core3.0-golang/constants"
	aasreporting "github.com/aas-core-works/aas-core3.0-golang/reporting"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
)

// Represent a verification violation.
//
// Implements `error`.
type VerificationError struct{
	Path *aasreporting.Path
	Message string
}

func newVerificationError(message string) *VerificationError {
	return &VerificationError{
		Path: &aasreporting.Path{},
		Message: message,
	}
}

func (ve *VerificationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		ve.PathString(),
		ve.Message,
	)
}

// Render the path as a string.
func (ve *VerificationError) PathString() string {
	return aasreporting.ToGolangPath(ve.Path)
}

func constructMatchesIDShort() *regexp.Regexp {
	pattern := "^[a-zA-Z][a-zA-Z0-9_]*$"

	return regexp.MustCompile(
		pattern,
	)
}

var matchesIDShortRe = constructMatchesIDShort()

// Check that text is a valid short ID.
func MatchesIDShort(text string) bool {
	return matchesIDShortRe.MatchString(
		text,
	)
}

func constructMatchesVersionType() *regexp.Regexp {
	pattern := "^(0|[1-9][0-9]*)$"

	return regexp.MustCompile(
		pattern,
	)
}

var matchesVersionTypeRe = constructMatchesVersionType()

// Check that text is a valid version string.
func MatchesVersionType(text string) bool {
	return matchesVersionTypeRe.MatchString(
		text,
	)
}

func constructMatchesRevisionType() *regexp.Regexp {
	pattern := "^(0|[1-9][0-9]*)$"

	return regexp.MustCompile(
		pattern,
	)
}

var matchesRevisionTypeRe = constructMatchesRevisionType()

// Check that text is a valid revision string.
func MatchesRevisionType(text string) bool {
	return matchesRevisionTypeRe.MatchString(
		text,
	)
}

func constructMatchesXsDateTimeUTC() *regexp.Regexp {
	digit := "[0-9]"
	yearFrag := aascommon.Concat(
		"-?(([1-9]",
		digit,
		digit,
		digit,
		"+)|(0",
		digit,
		digit,
		digit,
		"))",
	)
	monthFrag := "((0[1-9])|(1[0-2]))"
	dayFrag := aascommon.Concat(
		"((0[1-9])|([12]",
		digit,
		")|(3[01]))",
	)
	hourFrag := aascommon.Concat(
		"(([01]",
		digit,
		")|(2[0-3]))",
	)
	minuteFrag := aascommon.Concat(
		"[0-5]",
		digit,
	)
	secondFrag := aascommon.Concat(
		"([0-5]",
		digit,
		")(\\.",
		digit,
		"+)?",
	)
	endOfDayFrag := "24:00:00(\\.0+)?"
	timezoneFrag := "(Z|\\+00:00|-00:00)"
	dateTimeLexicalRep := aascommon.Concat(
		yearFrag,
		"-",
		monthFrag,
		"-",
		dayFrag,
		"T((",
		hourFrag,
		":",
		minuteFrag,
		":",
		secondFrag,
		")|",
		endOfDayFrag,
		")",
		timezoneFrag,
	)
	pattern := aascommon.Concat(
		"^",
		dateTimeLexicalRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsDateTimeUTCRe = constructMatchesXsDateTimeUTC()

// Check that text conforms to the pattern of an `xs:dateTime`.
//
// The time zone must be fixed to UTC. We verify only that the `text` matches
// a pre-defined pattern. We do not verify that the day of month is
// correct nor do we check for leap seconds.
//
// See: https://www.w3.org/TR/xmlschema-2/#dateTime
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDateTimeUTC(text string) bool {
	return matchesXsDateTimeUTCRe.MatchString(
		text,
	)
}

// Check that `value` is a valid `xs:dateTime` with
// the time zone set to UTC.
func IsXsDateTimeUTC(value string) bool {
	if !MatchesXsDateTime(value) {
		return false
	}

	date, _, ok := strings.Cut(value, "T")
	if !ok {
		panic(
			fmt.Sprintf(
				"Expected 'T' in the date-time if it matches the expected regex, " +
				"but got: %s",
				value,
			),
		)
	}
	return IsXsDate(date)
}

func constructMatchesMIMEType() *regexp.Regexp {
	tchar := "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]"
	token := aascommon.Concat(
		"(",
		tchar,
		")+",
	)
	typE := token
	subtype := token
	ows := "[ \\t]*"
	obsText := "[-ÿ]"
	qdText := aascommon.Concat(
		"([\\t !#-\\[\\]-~]|",
		obsText,
		")",
	)
	quotedPair := aascommon.Concat(
		"\\\\([\\t !-~]|",
		obsText,
		")",
	)
	quotedString := aascommon.Concat(
		"\"(",
		qdText,
		"|",
		quotedPair,
		")*\"",
	)
	parameter := aascommon.Concat(
		token,
		"=(",
		token,
		"|",
		quotedString,
		")",
	)
	mediaType := aascommon.Concat(
		"^",
		typE,
		"/",
		subtype,
		"(",
		ows,
		";",
		ows,
		parameter,
		")*$",
	)

	return regexp.MustCompile(
		mediaType,
	)
}

var matchesMIMETypeRe = constructMatchesMIMEType()

// Check that text conforms to the pattern of MIME type.
//
// The definition has been taken from:
// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesMIMEType(text string) bool {
	return matchesMIMETypeRe.MatchString(
		text,
	)
}

func constructMatchesRFC8089Path() *regexp.Regexp {
	h16 := "[0-9A-Fa-f]{1,4}"
	decOctet := "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
	ipv4address := aascommon.Concat(
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet,
	)
	ls32 := aascommon.Concat(
		"(",
		h16,
		":",
		h16,
		"|",
		ipv4address,
		")",
	)
	ipv6address := aascommon.Concat(
		"((",
		h16,
		":){6}",
		ls32,
		"|::(",
		h16,
		":){5}",
		ls32,
		"|(",
		h16,
		")?::(",
		h16,
		":){4}",
		ls32,
		"|((",
		h16,
		":)?",
		h16,
		")?::(",
		h16,
		":){3}",
		ls32,
		"|((",
		h16,
		":){2}",
		h16,
		")?::(",
		h16,
		":){2}",
		ls32,
		"|((",
		h16,
		":){3}",
		h16,
		")?::",
		h16,
		":",
		ls32,
		"|((",
		h16,
		":){4}",
		h16,
		")?::",
		ls32,
		"|((",
		h16,
		":){5}",
		h16,
		")?::",
		h16,
		"|((",
		h16,
		":){6}",
		h16,
		")?::)",
	)
	unreserved := "[a-zA-Z0-9\\-._~]"
	subDelims := "[!$&'()*+,;=]"
	ipvfuture := aascommon.Concat(
		"[vV][0-9A-Fa-f]+\\.(",
		unreserved,
		"|",
		subDelims,
		"|:)+",
	)
	ipLiteral := aascommon.Concat(
		"\\[(",
		ipv6address,
		"|",
		ipvfuture,
		")\\]",
	)
	pctEncoded := "%[0-9A-Fa-f][0-9A-Fa-f]"
	regName := aascommon.Concat(
		"(",
		unreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		")*",
	)
	host := aascommon.Concat(
		"(",
		ipLiteral,
		"|",
		ipv4address,
		"|",
		regName,
		")",
	)
	fileAuth := aascommon.Concat(
		"(localhost|",
		host,
		")",
	)
	pchar := aascommon.Concat(
		"(",
		unreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|[:@])",
	)
	segmentNz := aascommon.Concat(
		"(",
		pchar,
		")+",
	)
	segment := aascommon.Concat(
		"(",
		pchar,
		")*",
	)
	pathAbsolute := aascommon.Concat(
		"/(",
		segmentNz,
		"(/",
		segment,
		")*)?",
	)
	authPath := aascommon.Concat(
		"(",
		fileAuth,
		")?",
		pathAbsolute,
	)
	localPath := pathAbsolute
	fileHierPart := aascommon.Concat(
		"(//",
		authPath,
		"|",
		localPath,
		")",
	)
	fileScheme := "file"
	fileUri := aascommon.Concat(
		fileScheme,
		":",
		fileHierPart,
	)
	pattern := aascommon.Concat(
		"^",
		fileUri,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesRFC8089PathRe = constructMatchesRFC8089Path()

// Check that text is a path conforming to the pattern of RFC 8089.
//
// The definition has been taken from:
// https://datatracker.ietf.org/doc/html/rfc8089
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesRFC8089Path(text string) bool {
	return matchesRFC8089PathRe.MatchString(
		text,
	)
}

func constructMatchesBCP47() *regexp.Regexp {
	alphanum := "[a-zA-Z0-9]"
	singleton := "[0-9A-WY-Za-wy-z]"
	extension := aascommon.Concat(
		singleton,
		"(-(",
		alphanum,
		"){2,8})+",
	)
	extlang := "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}"
	irregular := "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)"
	regular := "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)"
	grandfathered := aascommon.Concat(
		"(",
		irregular,
		"|",
		regular,
		")",
	)
	language := aascommon.Concat(
		"([a-zA-Z]{2,3}(-",
		extlang,
		")?|[a-zA-Z]{4}|[a-zA-Z]{5,8})",
	)
	script := "[a-zA-Z]{4}"
	region := "([a-zA-Z]{2}|[0-9]{3})"
	variant := aascommon.Concat(
		"((",
		alphanum,
		"){5,8}|[0-9](",
		alphanum,
		"){3})",
	)
	privateuse := aascommon.Concat(
		"[xX](-(",
		alphanum,
		"){1,8})+",
	)
	langtag := aascommon.Concat(
		language,
		"(-",
		script,
		")?(-",
		region,
		")?(-",
		variant,
		")*(-",
		extension,
		")*(-",
		privateuse,
		")?",
	)
	languageTag := aascommon.Concat(
		"(",
		langtag,
		"|",
		privateuse,
		"|",
		grandfathered,
		")",
	)
	pattern := aascommon.Concat(
		"^",
		languageTag,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesBCP47Re = constructMatchesBCP47()

// Check that text is a valid BCP 47 language tag.
//
// See: https://en.wikipedia.org/wiki/IETF_language_tag
func MatchesBCP47(text string) bool {
	return matchesBCP47Re.MatchString(
		text,
	)
}

// Check that `langStrings` are specified each for a unique language.
func LangStringsHaveUniqueLanguages[L aastypes.IAbstractLangString](
	langStrings []L) bool {
	languageSet := make(map[string]struct{})

	for _, langString := range langStrings {
		language := langString.Language()
		_, has := languageSet[language]
		if has {
			return false
		}

		languageSet[language] = struct{}{}
	}

	return true
}

// Check that there are no duplicate [aastypes.IQualifier.Type]'s in
// the `qualifiers`.
func QualifierTypesAreUnique[Q aastypes.IQualifier](
	qualifiers []Q) bool {
	typeSet := make(map[string]struct{})
	for _, qualifier := range qualifiers {
		t := qualifier.Type()

		_, has := typeSet[t]
		if has {
			return false
		}
		typeSet[t] = struct{}{}
	}
	return true
}

func constructMatchesXMLSerializableString() *regexp.Regexp {
	pattern := "^[\t\n\r -\ud7ff\ue000-\ufffd\U00010000-\U0010ffff]*$"

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXMLSerializableStringRe = constructMatchesXMLSerializableString()

// Check that text conforms to the pattern of the Constraint AASd-130.
//
// Ensures that encoding is possible and interoperability between different
// serializations is possible.
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXMLSerializableString(text string) bool {
	return matchesXMLSerializableStringRe.MatchString(
		text,
	)
}

func constructMatchesXsAnyURI() *regexp.Regexp {
	scheme := "[a-zA-Z][a-zA-Z0-9+\\-.]*"
	ucschar := "[ -\ud7ff\uf900-\ufdcf\ufdf0-\uffef\U00010000-\U0001fffd\U00020000-\U0002fffd\U00030000-\U0003fffd\U00040000-\U0004fffd\U00050000-\U0005fffd\U00060000-\U0006fffd\U00070000-\U0007fffd\U00080000-\U0008fffd\U00090000-\U0009fffd\U000a0000-\U000afffd\U000b0000-\U000bfffd\U000c0000-\U000cfffd\U000d0000-\U000dfffd\U000e1000-\U000efffd]"
	iunreserved := aascommon.Concat(
		"([a-zA-Z0-9\\-._~]|",
		ucschar,
		")",
	)
	pctEncoded := "%[0-9A-Fa-f][0-9A-Fa-f]"
	subDelims := "[!$&'()*+,;=]"
	iuserinfo := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|:)*",
	)
	h16 := "[0-9A-Fa-f]{1,4}"
	decOctet := "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
	ipv4address := aascommon.Concat(
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet,
	)
	ls32 := aascommon.Concat(
		"(",
		h16,
		":",
		h16,
		"|",
		ipv4address,
		")",
	)
	ipv6address := aascommon.Concat(
		"((",
		h16,
		":){6}",
		ls32,
		"|::(",
		h16,
		":){5}",
		ls32,
		"|(",
		h16,
		")?::(",
		h16,
		":){4}",
		ls32,
		"|((",
		h16,
		":)?",
		h16,
		")?::(",
		h16,
		":){3}",
		ls32,
		"|((",
		h16,
		":){2}",
		h16,
		")?::(",
		h16,
		":){2}",
		ls32,
		"|((",
		h16,
		":){3}",
		h16,
		")?::",
		h16,
		":",
		ls32,
		"|((",
		h16,
		":){4}",
		h16,
		")?::",
		ls32,
		"|((",
		h16,
		":){5}",
		h16,
		")?::",
		h16,
		"|((",
		h16,
		":){6}",
		h16,
		")?::)",
	)
	unreserved := "[a-zA-Z0-9\\-._~]"
	ipvfuture := aascommon.Concat(
		"[vV][0-9A-Fa-f]+\\.(",
		unreserved,
		"|",
		subDelims,
		"|:)+",
	)
	ipLiteral := aascommon.Concat(
		"\\[(",
		ipv6address,
		"|",
		ipvfuture,
		")\\]",
	)
	iregName := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		")*",
	)
	ihost := aascommon.Concat(
		"(",
		ipLiteral,
		"|",
		ipv4address,
		"|",
		iregName,
		")",
	)
	port := "[0-9]*"
	iauthority := aascommon.Concat(
		"(",
		iuserinfo,
		"@)?",
		ihost,
		"(:",
		port,
		")?",
	)
	ipchar := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|[:@])",
	)
	isegment := aascommon.Concat(
		"(",
		ipchar,
		")*",
	)
	ipathAbempty := aascommon.Concat(
		"(/",
		isegment,
		")*",
	)
	isegmentNz := aascommon.Concat(
		"(",
		ipchar,
		")+",
	)
	ipathAbsolute := aascommon.Concat(
		"/(",
		isegmentNz,
		"(/",
		isegment,
		")*)?",
	)
	ipathRootless := aascommon.Concat(
		isegmentNz,
		"(/",
		isegment,
		")*",
	)
	ipathEmpty := aascommon.Concat(
		"(",
		ipchar,
		"){0}",
	)
	ihierPart := aascommon.Concat(
		"(//",
		iauthority,
		ipathAbempty,
		"|",
		ipathAbsolute,
		"|",
		ipathRootless,
		"|",
		ipathEmpty,
		")",
	)
	iprivate := "[\ue000-\uf8ff\U000f0000-\U000ffffd\U00100000-\U0010fffd]"
	iquery := aascommon.Concat(
		"(",
		ipchar,
		"|",
		iprivate,
		"|[/?])*",
	)
	ifragment := aascommon.Concat(
		"(",
		ipchar,
		"|[/?])*",
	)
	isegmentNzNc := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|@)+",
	)
	ipathNoscheme := aascommon.Concat(
		isegmentNzNc,
		"(/",
		isegment,
		")*",
	)
	irelativePart := aascommon.Concat(
		"(//",
		iauthority,
		ipathAbempty,
		"|",
		ipathAbsolute,
		"|",
		ipathNoscheme,
		"|",
		ipathEmpty,
		")",
	)
	irelativeRef := aascommon.Concat(
		irelativePart,
		"(\\?",
		iquery,
		")?(#",
		ifragment,
		")?",
	)
	iri := aascommon.Concat(
		scheme,
		":",
		ihierPart,
		"(\\?",
		iquery,
		")?(#",
		ifragment,
		")?",
	)
	iriReference := aascommon.Concat(
		"(",
		iri,
		"|",
		irelativeRef,
		")",
	)
	pattern := aascommon.Concat(
		"^",
		iriReference,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsAnyURIRe = constructMatchesXsAnyURI()

// Check that text conforms to the pattern of an `xs:anyURI`.
//
// See: https://www.w3.org/TR/xmlschema-2/#anyURI and
// https://datatracker.ietf.org/doc/html/rfc3987
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsAnyURI(text string) bool {
	return matchesXsAnyURIRe.MatchString(
		text,
	)
}

func constructMatchesXsBase64Binary() *regexp.Regexp {
	b04Char := "[AQgw]"
	b04 := aascommon.Concat(
		b04Char,
		"\\x20?",
	)
	b16Char := "[AEIMQUYcgkosw048]"
	b16 := aascommon.Concat(
		b16Char,
		"\\x20?",
	)
	b64Char := "[A-Za-z0-9+/]"
	b64 := aascommon.Concat(
		b64Char,
		"\\x20?",
	)
	b64quad := aascommon.Concat(
		"(",
		b64,
		b64,
		b64,
		b64,
		")",
	)
	b64FinalQuad := aascommon.Concat(
		"(",
		b64,
		b64,
		b64,
		b64Char,
		")",
	)
	padded8 := aascommon.Concat(
		b64,
		b04,
		"= ?=",
	)
	padded16 := aascommon.Concat(
		b64,
		b64,
		b16,
		"=",
	)
	b64final := aascommon.Concat(
		"(",
		b64FinalQuad,
		"|",
		padded16,
		"|",
		padded8,
		")",
	)
	base64Binary := aascommon.Concat(
		"(",
		b64quad,
		"*",
		b64final,
		")?",
	)
	pattern := aascommon.Concat(
		"^",
		base64Binary,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsBase64BinaryRe = constructMatchesXsBase64Binary()

// Check that text conforms to the pattern of an `xs:base64Binary`.
//
// See: https://www.w3.org/TR/xmlschema-2/#base64Binary
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsBase64Binary(text string) bool {
	return matchesXsBase64BinaryRe.MatchString(
		text,
	)
}

func constructMatchesXsBoolean() *regexp.Regexp {
	pattern := "^(true|false|1|0)$"

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsBooleanRe = constructMatchesXsBoolean()

// Check that text conforms to the pattern of an `xs:boolean`.
//
// See: https://www.w3.org/TR/xmlschema-2/#boolean
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsBoolean(text string) bool {
	return matchesXsBooleanRe.MatchString(
		text,
	)
}

func constructMatchesXsDate() *regexp.Regexp {
	digit := "[0-9]"
	yearFrag := aascommon.Concat(
		"-?(([1-9]",
		digit,
		digit,
		digit,
		"+)|(0",
		digit,
		digit,
		digit,
		"))",
	)
	monthFrag := "((0[1-9])|(1[0-2]))"
	dayFrag := aascommon.Concat(
		"((0[1-9])|([12]",
		digit,
		")|(3[01]))",
	)
	minuteFrag := aascommon.Concat(
		"[0-5]",
		digit,
	)
	timezoneFrag := aascommon.Concat(
		"(Z|(\\+|-)(0",
		digit,
		"|1[0-3]):",
		minuteFrag,
		"|14:00)",
	)
	dateLexicalRep := aascommon.Concat(
		yearFrag,
		"-",
		monthFrag,
		"-",
		dayFrag,
		timezoneFrag,
		"?",
	)
	pattern := aascommon.Concat(
		"^",
		dateLexicalRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsDateRe = constructMatchesXsDate()

// Check that text conforms to the pattern of an `xs:date`.
//
// See: https://www.w3.org/TR/xmlschema-2/#date
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDate(text string) bool {
	return matchesXsDateRe.MatchString(
		text,
	)
}

func constructMatchesXsDateTime() *regexp.Regexp {
	digit := "[0-9]"
	yearFrag := aascommon.Concat(
		"-?(([1-9]",
		digit,
		digit,
		digit,
		"+)|(0",
		digit,
		digit,
		digit,
		"))",
	)
	monthFrag := "((0[1-9])|(1[0-2]))"
	dayFrag := aascommon.Concat(
		"((0[1-9])|([12]",
		digit,
		")|(3[01]))",
	)
	hourFrag := aascommon.Concat(
		"(([01]",
		digit,
		")|(2[0-3]))",
	)
	minuteFrag := aascommon.Concat(
		"[0-5]",
		digit,
	)
	secondFrag := aascommon.Concat(
		"([0-5]",
		digit,
		")(\\.",
		digit,
		"+)?",
	)
	endOfDayFrag := "24:00:00(\\.0+)?"
	timezoneFrag := aascommon.Concat(
		"(Z|(\\+|-)(0",
		digit,
		"|1[0-3]):",
		minuteFrag,
		"|14:00)",
	)
	dateTimeLexicalRep := aascommon.Concat(
		yearFrag,
		"-",
		monthFrag,
		"-",
		dayFrag,
		"T((",
		hourFrag,
		":",
		minuteFrag,
		":",
		secondFrag,
		")|",
		endOfDayFrag,
		")",
		timezoneFrag,
		"?",
	)
	pattern := aascommon.Concat(
		"^",
		dateTimeLexicalRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsDateTimeRe = constructMatchesXsDateTime()

// Check that text conforms to the pattern of an `xs:dateTime`.
//
// See: https://www.w3.org/TR/xmlschema-2/#dateTime
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDateTime(text string) bool {
	return matchesXsDateTimeRe.MatchString(
		text,
	)
}

// Check that `value` is a valid `xs:dateTime`.
//
// Year 1 BCE is the last leap BCE year.
// See https://www.w3.org/TR/xmlschema-2/#dateTime.
func IsXsDateTime(value string) bool {
	// NOTE (mristin, 2023-05-09):
  	// We can not use date functions from the standard library as it does not
	// handle years BCE (*e.g.*, `-0003-01-02`).

	if !MatchesXsDateTime(value) {
		return false
	}

	date, _, ok := strings.Cut(value, "T")
	if !ok {
		panic(
			fmt.Sprintf(
				"Expected 'T' in the date-time if it matches the expected regex, " +
				"but got: %s",
				value,
			),
		)
	}
	return IsXsDate(date)
}

func constructMatchesXsDecimal() *regexp.Regexp {
	digit := "[0-9]"
	unsignedNoDecimalPtNumeral := aascommon.Concat(
		digit,
		"+",
	)
	noDecimalPtNumeral := aascommon.Concat(
		"(\\+|-)?",
		unsignedNoDecimalPtNumeral,
	)
	fracFrag := aascommon.Concat(
		digit,
		"+",
	)
	unsignedDecimalPtNumeral := aascommon.Concat(
		"(",
		unsignedNoDecimalPtNumeral,
		"\\.",
		fracFrag,
		"|\\.",
		fracFrag,
		")",
	)
	decimalPtNumeral := aascommon.Concat(
		"(\\+|-)?",
		unsignedDecimalPtNumeral,
	)
	decimalLexicalRep := aascommon.Concat(
		"(",
		decimalPtNumeral,
		"|",
		noDecimalPtNumeral,
		")",
	)
	pattern := aascommon.Concat(
		"^",
		decimalLexicalRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsDecimalRe = constructMatchesXsDecimal()

// Check that text conforms to the pattern of an `xs:decimal`.
//
// See: https://www.w3.org/TR/xmlschema-2/#decimal
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDecimal(text string) bool {
	return matchesXsDecimalRe.MatchString(
		text,
	)
}

func constructMatchesXsDouble() *regexp.Regexp {
	doubleRep := "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
	pattern := aascommon.Concat(
		"^",
		doubleRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsDoubleRe = constructMatchesXsDouble()

// Check that text conforms to the pattern of an `xs:double`.
//
// See: https://www.w3.org/TR/xmlschema-2/#double
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDouble(text string) bool {
	return matchesXsDoubleRe.MatchString(
		text,
	)
}

func constructMatchesXsDuration() *regexp.Regexp {
	durationRep := "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))"
	pattern := aascommon.Concat(
		"^",
		durationRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsDurationRe = constructMatchesXsDuration()

// Check that text conforms to the pattern of an `xs:duration`.
//
// See: https://www.w3.org/TR/xmlschema-2/#duration
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDuration(text string) bool {
	return matchesXsDurationRe.MatchString(
		text,
	)
}

func constructMatchesXsFloat() *regexp.Regexp {
	floatRep := "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
	pattern := aascommon.Concat(
		"^",
		floatRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsFloatRe = constructMatchesXsFloat()

// Check that text conforms to the pattern of an `xs:float`.
//
// See: https://www.w3.org/TR/xmlschema-2/#float
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsFloat(text string) bool {
	return matchesXsFloatRe.MatchString(
		text,
	)
}

func constructMatchesXsGDay() *regexp.Regexp {
	gDayLexicalRep := "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gDayLexicalRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsGDayRe = constructMatchesXsGDay()

// Check that text conforms to the pattern of an `xs:gDay`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gDay
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGDay(text string) bool {
	return matchesXsGDayRe.MatchString(
		text,
	)
}

func constructMatchesXsGMonth() *regexp.Regexp {
	gMonthLexicalRep := "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gMonthLexicalRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsGMonthRe = constructMatchesXsGMonth()

// Check that text conforms to the pattern of an `xs:gMonth`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gMonth
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGMonth(text string) bool {
	return matchesXsGMonthRe.MatchString(
		text,
	)
}

func constructMatchesXsGMonthDay() *regexp.Regexp {
	gMonthDayRep := "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gMonthDayRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsGMonthDayRe = constructMatchesXsGMonthDay()

// Check that text conforms to the pattern of an `xs:gMonthDay`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gMonthDay
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGMonthDay(text string) bool {
	return matchesXsGMonthDayRe.MatchString(
		text,
	)
}

func constructMatchesXsGYear() *regexp.Regexp {
	gYearRep := "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gYearRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsGYearRe = constructMatchesXsGYear()

// Check that text conforms to the pattern of an `xs:gYear`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gYear
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGYear(text string) bool {
	return matchesXsGYearRe.MatchString(
		text,
	)
}

func constructMatchesXsGYearMonth() *regexp.Regexp {
	gYearMonthRep := "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gYearMonthRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsGYearMonthRe = constructMatchesXsGYearMonth()

// Check that text conforms to the pattern of an `xs:gYearMonth`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gYearMonth
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGYearMonth(text string) bool {
	return matchesXsGYearMonthRe.MatchString(
		text,
	)
}

func constructMatchesXsHexBinary() *regexp.Regexp {
	hexBinary := "([0-9a-fA-F]{2})*"
	pattern := aascommon.Concat(
		"^",
		hexBinary,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsHexBinaryRe = constructMatchesXsHexBinary()

// Check that text conforms to the pattern of an `xs:hexBinary`.
//
// See: https://www.w3.org/TR/xmlschema-2/#hexBinary
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsHexBinary(text string) bool {
	return matchesXsHexBinaryRe.MatchString(
		text,
	)
}

func constructMatchesXsTime() *regexp.Regexp {
	timeRep := "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		timeRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsTimeRe = constructMatchesXsTime()

// Check that text conforms to the pattern of an `xs:time`.
//
// See: https://www.w3.org/TR/xmlschema-2/#time
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsTime(text string) bool {
	return matchesXsTimeRe.MatchString(
		text,
	)
}

func constructMatchesXsInteger() *regexp.Regexp {
	integerRep := "[-+]?[0-9]+"
	pattern := aascommon.Concat(
		"^",
		integerRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsIntegerRe = constructMatchesXsInteger()

// Check that text conforms to the pattern of an `xs:integer`.
//
// See: https://www.w3.org/TR/xmlschema-2/#integer
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsInteger(text string) bool {
	return matchesXsIntegerRe.MatchString(
		text,
	)
}

func constructMatchesXsLong() *regexp.Regexp {
	longRep := "[-+]?0*[0-9]{1,20}"
	pattern := aascommon.Concat(
		"^",
		longRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsLongRe = constructMatchesXsLong()

// Check that text conforms to the pattern of an `xs:long`.
//
// See: https://www.w3.org/TR/xmlschema-2/#long
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsLong(text string) bool {
	return matchesXsLongRe.MatchString(
		text,
	)
}

func constructMatchesXsInt() *regexp.Regexp {
	intRep := "[-+]?0*[0-9]{1,10}"
	pattern := aascommon.Concat(
		"^",
		intRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsIntRe = constructMatchesXsInt()

// Check that text conforms to the pattern of an `xs:int`.
//
// See: https://www.w3.org/TR/xmlschema-2/#int
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsInt(text string) bool {
	return matchesXsIntRe.MatchString(
		text,
	)
}

func constructMatchesXsShort() *regexp.Regexp {
	shortRep := "[-+]?0*[0-9]{1,5}"
	pattern := aascommon.Concat(
		"^",
		shortRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsShortRe = constructMatchesXsShort()

// Check that text conforms to the pattern of an `xs:short`.
//
// See: https://www.w3.org/TR/xmlschema-2/#short
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsShort(text string) bool {
	return matchesXsShortRe.MatchString(
		text,
	)
}

func constructMatchesXsByte() *regexp.Regexp {
	byteRep := "[-+]?0*[0-9]{1,3}"
	pattern := aascommon.Concat(
		"^",
		byteRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsByteRe = constructMatchesXsByte()

// Check that text conforms to the pattern of an `xs:byte`.
//
// See: https://www.w3.org/TR/xmlschema-2/#byte
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsByte(text string) bool {
	return matchesXsByteRe.MatchString(
		text,
	)
}

func constructMatchesXsNonNegativeInteger() *regexp.Regexp {
	nonNegativeIntegerRep := "(-0|\\+?[0-9]+)"
	pattern := aascommon.Concat(
		"^",
		nonNegativeIntegerRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsNonNegativeIntegerRe = constructMatchesXsNonNegativeInteger()

// Check that text conforms to the pattern of an `xs:nonNegativeInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsNonNegativeInteger(text string) bool {
	return matchesXsNonNegativeIntegerRe.MatchString(
		text,
	)
}

func constructMatchesXsPositiveInteger() *regexp.Regexp {
	positiveIntegerRep := "\\+?0*[1-9][0-9]*"
	pattern := aascommon.Concat(
		"^",
		positiveIntegerRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsPositiveIntegerRe = constructMatchesXsPositiveInteger()

// Check that text conforms to the pattern of an `xs:positiveInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#positiveInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsPositiveInteger(text string) bool {
	return matchesXsPositiveIntegerRe.MatchString(
		text,
	)
}

func constructMatchesXsUnsignedLong() *regexp.Regexp {
	unsignedLongRep := "(-0|\\+?0*[0-9]{1,20})"
	pattern := aascommon.Concat(
		"^",
		unsignedLongRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsUnsignedLongRe = constructMatchesXsUnsignedLong()

// Check that text conforms to the pattern of an `xs:unsignedLong`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedLong
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedLong(text string) bool {
	return matchesXsUnsignedLongRe.MatchString(
		text,
	)
}

func constructMatchesXsUnsignedInt() *regexp.Regexp {
	unsignedIntRep := "(-0|\\+?0*[0-9]{1,10})"
	pattern := aascommon.Concat(
		"^",
		unsignedIntRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsUnsignedIntRe = constructMatchesXsUnsignedInt()

// Check that text conforms to the pattern of an `xs:unsignedInt`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedInt
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedInt(text string) bool {
	return matchesXsUnsignedIntRe.MatchString(
		text,
	)
}

func constructMatchesXsUnsignedShort() *regexp.Regexp {
	unsignedShortRep := "(-0|\\+?0*[0-9]{1,5})"
	pattern := aascommon.Concat(
		"^",
		unsignedShortRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsUnsignedShortRe = constructMatchesXsUnsignedShort()

// Check that text conforms to the pattern of an `xs:unsignedShort`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedShort
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedShort(text string) bool {
	return matchesXsUnsignedShortRe.MatchString(
		text,
	)
}

func constructMatchesXsUnsignedByte() *regexp.Regexp {
	unsignedByteRep := "(-0|\\+?0*[0-9]{1,3})"
	pattern := aascommon.Concat(
		"^",
		unsignedByteRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsUnsignedByteRe = constructMatchesXsUnsignedByte()

// Check that text conforms to the pattern of an `xs:unsignedByte`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedByte
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedByte(text string) bool {
	return matchesXsUnsignedByteRe.MatchString(
		text,
	)
}

func constructMatchesXsNonPositiveInteger() *regexp.Regexp {
	nonPositiveIntegerRep := "(\\+0|0|-[0-9]+)"
	pattern := aascommon.Concat(
		"^",
		nonPositiveIntegerRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsNonPositiveIntegerRe = constructMatchesXsNonPositiveInteger()

// Check that text conforms to the pattern of an `xs:nonPositiveInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsNonPositiveInteger(text string) bool {
	return matchesXsNonPositiveIntegerRe.MatchString(
		text,
	)
}

func constructMatchesXsNegativeInteger() *regexp.Regexp {
	negativeIntegerRep := "(-0*[1-9][0-9]*)"
	pattern := aascommon.Concat(
		"^",
		negativeIntegerRep,
		"$",
	)

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsNegativeIntegerRe = constructMatchesXsNegativeInteger()

// Check that text conforms to the pattern of an `xs:negativeInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#negativeInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsNegativeInteger(text string) bool {
	return matchesXsNegativeIntegerRe.MatchString(
		text,
	)
}

func constructMatchesXsString() *regexp.Regexp {
	pattern := "^[\t\n\r -\ud7ff\ue000-\ufffd\U00010000-\U0010ffff]*$"

	return regexp.MustCompile(
		pattern,
	)
}

var matchesXsStringRe = constructMatchesXsString()

// Check that text conforms to the pattern of an `xs:string`.
//
// See: https://www.w3.org/TR/xmlschema-2/#string
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsString(text string) bool {
	return matchesXsStringRe.MatchString(
		text,
	)
}

var zero *big.Int = big.NewInt(0)
var one *big.Int = big.NewInt(1)
var four *big.Int = big.NewInt(4)
var hundred *big.Int = big.NewInt(100)
var fourHundred *big.Int = big.NewInt(400)

// Check if `year` is a leap year.
func isLeapYear(year *big.Int) bool {
	// We consider the years B.C. to be one-off.
	//
	// See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
	// "'-0001' is the lexical representation of the year 1 Before Common Era
	// (1 BCE, sometimes written "1 BC")."
	//
	// Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.

	if year.Cmp(zero) < 0 {
		// year = -year - 1
		year.Neg(year)
		year.Sub(year, one)
	}

	// See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
	yearMod4 := &big.Int{}
	yearMod4.Mod(year, four)

	if yearMod4.Cmp(zero) != 0 {
		return false
	}

	yearMod100 := &big.Int{}
	yearMod100.Mod(year, hundred)
	if yearMod100.Cmp(zero) != 0 {
		return true
	}

	yearMod400 := &big.Int{}
	yearMod400.Mod(year, fourHundred)
	if yearMod400.Cmp(zero) != 0 {
		return false
	}

	return true
}

var daysInMonth = []int{
	// Month 0 is not defined.
	-1, // 0
	31, // 1
	// Please use isLeapYear if you need to check whether
	// a concrete February has 28 or 29 days.
	29, // 2
	31, // 3
	30, // 4
	31, // 5
	30, // 6
	31, // 7
	31, // 8
	30, // 9
	31, // 10
	30, // 11
	31, // 12
}

var datePrefixRe = regexp.MustCompile("^(-?[0-9]+)-([0-9]{2})-([0-9]{2})")

// Check that `value` is a valid `xs:date`.
//
// The year must fit in the 64-bit range so that we can check whether it is
// a leap year or not.
func IsXsDate(value string) bool {
	if !MatchesXsDate(value) {
		return false
	}

	// NOTE (mristin, 2023-05-10):
	// We can not use the date functions from the standard library as we have
	// to handle years BCE according to the XML date type.

	// NOTE (mristin, 2023-05-12):
    // We need to match the prefix as zone offsets are allowed in the dates. Optimally,
    // we would re-use the pattern matching from `MatchesXsDate`, but this
    // would make the code generation and constraint inference for schemas much more
    // difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code
    // generation.

	match := datePrefixRe.FindStringSubmatch(value)
	if len(match) == 0 {
		panic(
			fmt.Sprintf(
				"Expected value to match %v if we got thus far, " +
				"but it does not: %s",
				datePrefixRe, value,
			),
		)
	}

	yearStr := match[1]
	monthStr := match[2]
	dayStr := match[3]

	year := &big.Int{}
	_, ok := year.SetString(yearStr, 10)
	if !ok {
		panic(
			fmt.Sprintf(
				"Failed to convert the year from %s",
				yearStr,
			),
		)
	}

	month, err := strconv.Atoi(monthStr)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to convert the month from %s: %s",
				monthStr, err.Error(),
			),
		)
	}

	var day int
	day, err = strconv.Atoi(dayStr)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to convert the day from %s: %s",
				dayStr, err.Error(),
			),
		)
	}

	// We do not accept year zero,
	// see the note at: https://www.w3.org/TR/xmlschema-2/#dateTime
	if year.Cmp(zero) == 0 {
		return false
	}

	if day <= 0 {
		return false
	}

	if month <= 0 || month >= 13 {
		return false
	}

	var maxDays int
	if month == 2 {
		if isLeapYear(year) {
			maxDays = 29
		} else {
			maxDays = 28
		}
	} else {
		maxDays = daysInMonth[month]
	}

	if day > maxDays {
		return false
	}

	return true
}

// Check that `value` is a valid `xs:double`.
func IsXsDouble(value string) bool {
	// We need to check explicitly for the regular expression since
	// strconv.ParseFloat is too permissive. For example, it accepts "nan"
	// although only "NaN" is valid.
	// See: https://www.w3.org/TR/xmlschema-2/#double
	if !MatchesXsDouble(value) {
		return false
	}

	_, err := strconv.ParseFloat(value, 64)
	if err != nil {
		if numError, ok := err.(*strconv.NumError); ok {
            if numError.Err == strconv.ErrRange {
                return false
            }
        }

		panic(
			fmt.Sprintf(
				"Failed to parse float from value %s: %s",
				value, err.Error(),
			),
		)
	}

	// NOTE (2023-05-12):
	// We explicitly do not check for loss of precision, as the majority of people will
	// use string representation of the floating point numbers ignoring the precision
	// issues. For example, the closest double-precision number to the number `359.9` is
	// `359.8999999999999772626324556767940521240234375`, but most people will simply
	// give `359.9` as the value.

	return true
}

// Check that `value` is a valid `xs:float`.
func IsXsFloat(value string) bool {
	// We need to check explicitly for the regular expression since
	// strconv.ParseFloat is too permissive. For example, it accepts "nan"
	// although only "NaN" is valid.
	// See: https://www.w3.org/TR/xmlschema-2/#double
	if !MatchesXsDouble(value) {
		return false
	}

	_, err := strconv.ParseFloat(value, 32)
	if err != nil {
        if numError, ok := err.(*strconv.NumError); ok {
            if numError.Err == strconv.ErrRange {
                return false
            }
        }

		panic(
			fmt.Sprintf(
				"Failed to parse float from value %s: %s",
				value, err.Error(),
			),
		)
	}

	// NOTE (2023-05-12):
	// We explicitly do not check for loss of precision, as the majority of people will
	// use string representation of the floating point numbers ignoring the precision
	// issues. For example, `float64(float32(3.2)) == 3.2` is false in Golang, but "3.2"
	// is totally expected as a value.

	return true
}

// Check that `value` is a valid `xs:gMonthDay`.
func IsXsGMonthDay(value string) bool {
	if !MatchesXsGMonthDay(value) {
		return false
	}

	month, err := strconv.Atoi(value[2:4])
	if err != nil {
		panic(
			fmt.Sprintf(
				"Unexpected fail to parse the month %s: %s",
				value[2:4], err.Error(),
			),
		)
	}

	var day int
	day, err = strconv.Atoi(value[5:7])
	if err != nil {
		panic(
			fmt.Sprintf(
				"Unexpected fail to parse the day %s: %s",
				value[5:7], err.Error(),
			),
		)
	}

	maxDays := daysInMonth[month]
	return day <= maxDays
}

// Check that `value` is a valid `xs:long`.
func IsXsLong(value string) bool {
	if !MatchesXsLong(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 64)
	return err == nil
}

// Check that `value` is a valid `xs:int`.
func IsXsInt(value string) bool {
	if !MatchesXsInt(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 32)
	return err == nil
}

// Check that `value` is a valid `xs:short`.
func IsXsShort(value string) bool {
	if !MatchesXsShort(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 16)
	return err == nil
}

// Check that `value` is a valid `xs:byte`.
func IsXsByte(value string) bool {
	if !MatchesXsByte(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 8)
	return err == nil
}

// Check that `value` is a valid `xs:unsignedLong`.
func IsXsUnsignedLong(value string) bool {
	if !MatchesXsUnsignedLong(value) {
		return false
	}

	// See: https://pkg.go.dev/strconv#ParseUint,
	// "A sign prefix is not permitted."
	if value[0] == '+' {
		value = value[1:]
	}

	_, err := strconv.ParseUint(value, 10, 64)
	return err == nil
}

// Check that `value` is a valid `xs:unsignedInt`.
func IsXsUnsignedInt(value string) bool {
	if !MatchesXsUnsignedInt(value) {
		return false
	}

	// See: https://pkg.go.dev/strconv#ParseUint,
	// "A sign prefix is not permitted."
	if value[0] == '+' {
		value = value[1:]
	}

	_, err := strconv.ParseUint(value, 10, 32)
	return err == nil
}

// Check that `value` is a valid `xs:unsignedShort`.
func IsXsUnsignedShort(value string) bool {
	if !MatchesXsUnsignedShort(value) {
		return false
	}

	// See: https://pkg.go.dev/strconv#ParseUint,
	// "A sign prefix is not permitted."
	if value[0] == '+' {
		value = value[1:]
	}

	_, err := strconv.ParseUint(value, 10, 16)
	return err == nil
}

// Check that `value` is a valid `xs:unsignedByte`.
func IsXsUnsignedByte(value string) bool {
	if !MatchesXsUnsignedByte(value) {
		return false
	}

	// See: https://pkg.go.dev/strconv#ParseUint,
	// "A sign prefix is not permitted."
	if value[0] == '+' {
		value = value[1:]
	}

	_, err := strconv.ParseUint(value, 10, 8)
	return err == nil
}

// Check that `value` is consistent with the given `valueType`.
func ValueConsistentWithXSDType(
	value string,
	valueType aastypes.DataTypeDefXSD,
) bool {
	switch valueType {
		case aastypes.DataTypeDefXSDAnyURI:
			return MatchesXsAnyURI(value)
		case aastypes.DataTypeDefXSDBase64Binary:
			return MatchesXsBase64Binary(value)
		case aastypes.DataTypeDefXSDBoolean:
			return MatchesXsBoolean(value)
		case aastypes.DataTypeDefXSDByte:
			return IsXsByte(value)
		case aastypes.DataTypeDefXSDDate:
			return IsXsDate(value)
		case aastypes.DataTypeDefXSDDateTime:
			return IsXsDateTime(value)
		case aastypes.DataTypeDefXSDDecimal:
			return MatchesXsDecimal(value)
		case aastypes.DataTypeDefXSDDouble:
			return IsXsDouble(value)
		case aastypes.DataTypeDefXSDDuration:
			return MatchesXsDuration(value)
		case aastypes.DataTypeDefXSDFloat:
		 	return IsXsFloat(value)
		case aastypes.DataTypeDefXSDGDay:
			return MatchesXsGDay(value)
		case aastypes.DataTypeDefXSDGMonth:
			return MatchesXsGMonth(value)
		case aastypes.DataTypeDefXSDGMonthDay:
			return IsXsGMonthDay(value)
		case aastypes.DataTypeDefXSDGYear:
			return MatchesXsGYear(value)
		case aastypes.DataTypeDefXSDGYearMonth:
			return MatchesXsGYearMonth(value)
		case aastypes.DataTypeDefXSDHexBinary:
			return MatchesXsHexBinary(value)
		case aastypes.DataTypeDefXSDInt:
			return IsXsInt(value)
		case aastypes.DataTypeDefXSDInteger:
			return MatchesXsInteger(value)
		case aastypes.DataTypeDefXSDLong:
			return IsXsLong(value)
		case aastypes.DataTypeDefXSDNegativeInteger:
			return MatchesXsNegativeInteger(value)
		case aastypes.DataTypeDefXSDNonNegativeInteger:
			return MatchesXsNonNegativeInteger(value)
		case aastypes.DataTypeDefXSDNonPositiveInteger:
			return MatchesXsNonPositiveInteger(value)
		case aastypes.DataTypeDefXSDPositiveInteger:
			return MatchesXsPositiveInteger(value)
		case aastypes.DataTypeDefXSDShort:
			return IsXsShort(value)
		case aastypes.DataTypeDefXSDString:
			return MatchesXsString(value)
		case aastypes.DataTypeDefXSDTime:
			return MatchesXsTime(value)
		case aastypes.DataTypeDefXSDUnsignedByte:
			return IsXsUnsignedByte(value)
		case aastypes.DataTypeDefXSDUnsignedInt:
			return IsXsUnsignedInt(value)
		case aastypes.DataTypeDefXSDUnsignedLong:
			return IsXsUnsignedLong(value)
		case aastypes.DataTypeDefXSDUnsignedShort:
			return IsXsUnsignedShort(value)
		default:
			panic(fmt.Sprintf("Unhandled value type: %v", valueType))
	}
}

// Check that the target of the model reference matches the expectedType.
func IsModelReferenceTo(
	reference aastypes.IReference,
	expectedType aastypes.KeyTypes,
) bool {
	return reference.Type() == aastypes.ReferenceTypesModelReference &&
		len(reference.Keys()) != 0 &&
		reference.Keys()[len(reference.Keys()) - 1].Type() == expectedType
}

// Check that the target of the reference matches a [aasconstants.AASReferables].
func IsModelReferenceToReferable(
	reference aastypes.IReference,
) bool {
	return reference.Type() == aastypes.ReferenceTypesModelReference &&
		len(reference.Keys()) != 0 &&
		aascommon.MapContains(
			aasconstants.AASReferables,
			reference.Keys()[len(reference.Keys()) - 1].Type(),
		)
}

// Check that all [aastypes.IReferable.IDShort] are unique among
// `referables`.
func IDShortsAreUnique[R aastypes.IReferable](
	referables []R) bool {
	idShortSet := make(map[string]struct{})

	for _, referable := range referables {
		idShort := referable.IDShort()

		if idShort == nil {
			continue
		}

		_, has := idShortSet[*idShort]
		if has {
			return false
		}

		idShortSet[*idShort] = struct{}{}
	}
	return true
}

// Check that [aastypes.IReferable.IDShort]'s among all the `inputVariables`,
// `outputVariables` and `inoutputVariables` are unique.
func IDShortsOfVariablesAreUnique[O1 aastypes.IOperationVariable,
		O2 aastypes.IOperationVariable,
		O3 aastypes.IOperationVariable] (
	inputVariables []O1,
	outputVariables []O2,
	inoutputVariables []O3) bool {
	idShortSet := make(map[string]struct{})

	var has bool

	if inputVariables != nil {
		for _, variable := range inputVariables {
			idShort := variable.Value().IDShort()

			if idShort != nil {
				_, has = idShortSet[*idShort]
				if has {
					return true
				}

				idShortSet[*idShort] = struct{}{}
			}
		}
	}

	if outputVariables != nil {
		for _, variable := range outputVariables {
			idShort := variable.Value().IDShort()

			if idShort != nil {
				_, has = idShortSet[*idShort]
				if has {
					return true
				}

				idShortSet[*idShort] = struct{}{}
			}
		}
	}

	if inoutputVariables != nil {
		for _, variable := range inoutputVariables {
			idShort := variable.Value().IDShort()

			if idShort != nil {
				_, has = idShortSet[*idShort]
				if has {
					return true
				}

				idShortSet[*idShort] = struct{}{}
			}
		}
	}

	return true
}

// Check that all [aastypes.IExtension.Name] are unique among
// `extensions`.
func ExtensionNamesAreUnique[E aastypes.IExtension](
	extensions []E) bool {
	nameSet := make(map[string]struct{})

	for _, extension := range extensions {
		name := extension.Name()
		_, has := nameSet[name]
		if has {
			return false
		}

		nameSet[name] = struct{}{}
	}
	return true
}

// Check that all `elements` have the identical [aastypes.IHasSemantics.SemanticID].
func SubmodelElementsHaveIdenticalSemanticIDs[S aastypes.ISubmodelElement](
	elements []S) bool {
	var thatSemanticID aastypes.IReference

	for _, element := range elements {
		thisSemanticID := element.SemanticID()

		if thisSemanticID == nil {
			continue
		}

		if thatSemanticID == nil {
			thatSemanticID = thisSemanticID
			continue
		}

		thisKeys := thisSemanticID.Keys()
		thatKeys := thatSemanticID.Keys()

		if len(thisKeys) != len(thatKeys) {
			return false
		}

		for i, thisKey := range thisKeys {
			thatKey := thatKeys[i]

			if thisKey.Value() != thatKey.Value() {
				return false
			}
		}
	}
	return true
}

// Check that `element` is an instance of the interface corresponding to
// `expectedType`.
func SubmodelElementIsOfType(
	element aastypes.ISubmodelElement,
	expectedType aastypes.AASSubmodelElements,
) bool {
	switch expectedType {
	case aastypes.AASSubmodelElementsAnnotatedRelationshipElement:
		return aastypes.IsAnnotatedRelationshipElement(
			element,
		)
	case aastypes.AASSubmodelElementsBasicEventElement:
		return aastypes.IsBasicEventElement(
			element,
		)
	case aastypes.AASSubmodelElementsBlob:
		return aastypes.IsBlob(
			element,
		)
	case aastypes.AASSubmodelElementsCapability:
		return aastypes.IsCapability(
			element,
		)
	case aastypes.AASSubmodelElementsDataElement:
		return aastypes.IsDataElement(
			element,
		)
	case aastypes.AASSubmodelElementsEntity:
		return aastypes.IsEntity(
			element,
		)
	case aastypes.AASSubmodelElementsEventElement:
		return aastypes.IsEventElement(
			element,
		)
	case aastypes.AASSubmodelElementsFile:
		return aastypes.IsFile(
			element,
		)
	case aastypes.AASSubmodelElementsMultiLanguageProperty:
		return aastypes.IsMultiLanguageProperty(
			element,
		)
	case aastypes.AASSubmodelElementsOperation:
		return aastypes.IsOperation(
			element,
		)
	case aastypes.AASSubmodelElementsProperty:
		return aastypes.IsProperty(
			element,
		)
	case aastypes.AASSubmodelElementsRange:
		return aastypes.IsRange(
			element,
		)
	case aastypes.AASSubmodelElementsReferenceElement:
		return aastypes.IsReferenceElement(
			element,
		)
	case aastypes.AASSubmodelElementsRelationshipElement:
		return aastypes.IsRelationshipElement(
			element,
		)
	case aastypes.AASSubmodelElementsSubmodelElement:
		return aastypes.IsSubmodelElement(
			element,
		)
	case aastypes.AASSubmodelElementsSubmodelElementList:
		return aastypes.IsSubmodelElementList(
			element,
		)
	case aastypes.AASSubmodelElementsSubmodelElementCollection:
		return aastypes.IsSubmodelElementCollection(
			element,
		)
	}
	return false
}

// Check that `elements` which are [aastypes.IProperty] or [aastypes.IRange]
// have the given `valueType`.
func PropertiesOrRangesHaveValueType[E aastypes.ISubmodelElement](
	elements []E,
	valueType aastypes.DataTypeDefXSD,
) bool {
	for _, element := range elements {
		switch element.ModelType() {
		case aastypes.ModelTypeProperty:
			prop := any(element).(aastypes.IProperty)
			if prop.ValueType() != valueType {
				return false
			}
		case aastypes.ModelTypeRange:
			rng := any(element).(aastypes.IRange)
			if rng.ValueType() != valueType {
				return false
			}
		// default passes.
		}
	}
	return true
}

// Check that the two references, `that` and `other`, are equal by
// comparing their [aastypes.Reference.Keys] by [aastypes.Key.Value]'s.
func ReferenceKeyValuesEqual(
	that aastypes.IReference,
	other aastypes.IReference) bool {
	thatKeys := that.Keys()
	otherKeys := other.Keys()

	if len(thatKeys) != len(otherKeys) {
		return false
	}

	for i, thatKey := range thatKeys {
		otherKey := otherKeys[i]

		if thatKey.Value() != otherKey.Value() {
			return false
		}
	}

	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined appropriately for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sForPropertyOrValueHaveAppropriateDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		content := eds.DataSpecificationContent()

		ok := aastypes.IsDataSpecificationIEC61360(content)
		if !ok {
			continue
		}
		iec61360 := content.(aastypes.IDataSpecificationIEC61360)

		dt := iec61360.DataType()
		if dt == nil ||
			!aascommon.MapContains(aasconstants.DataTypeIEC61360ForPropertyOrValue, *dt) {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined appropriately for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sForReferenceHaveAppropriateDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		content := eds.DataSpecificationContent()

		ok := aastypes.IsDataSpecificationIEC61360(content)
		if !ok {
			continue
		}
		iec61360 := content.(aastypes.IDataSpecificationIEC61360)

		dt := iec61360.DataType()
		if dt == nil ||
			!aascommon.MapContains(aasconstants.DataTypeIEC61360ForReference, *dt) {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined appropriately for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sForDocumentHaveAppropriateDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		content := eds.DataSpecificationContent()

		ok := aastypes.IsDataSpecificationIEC61360(content)
		if !ok {
			continue
		}
		iec61360 := content.(aastypes.IDataSpecificationIEC61360)

		dt := iec61360.DataType()
		if dt == nil ||
			!aascommon.MapContains(aasconstants.DataTypeIEC61360ForDocument, *dt) {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sHaveDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		content := eds.DataSpecificationContent()

		ok := aastypes.IsDataSpecificationIEC61360(content)
		if !ok {
			continue
		}
		iec61360 := content.(aastypes.IDataSpecificationIEC61360)

		dt := iec61360.DataType()
		if dt == nil {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.Value]
// is defined for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sHaveValue(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		content := eds.DataSpecificationContent()

		ok := aastypes.IsDataSpecificationIEC61360(content)
		if !ok {
			continue
		}
		iec61360 := content.(aastypes.IDataSpecificationIEC61360)

		v := iec61360.Value()
		if v == nil {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.Definition]
// is defined for all data specifications whose content is given as
// IEC 61360 at least in English.
func DataSpecificationIEC61360sHaveDefinitionAtLeastInEnglish(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		content := eds.DataSpecificationContent()

		ok := aastypes.IsDataSpecificationIEC61360(content)
		if !ok {
			continue
		}
		iec61360 := content.(aastypes.IDataSpecificationIEC61360)

		definition := iec61360.Definition()
		if definition == nil {
			return false
		}

		noEnglish := true
		for _, langString := range definition {
			if IsBCP47ForEnglish(langString.Language()) {
				noEnglish = false
				break
			}
		}

		if noEnglish {
			return false
		}
	}
	return true
}

func constructIsBCP47ForEnglish() *regexp.Regexp {
	pattern := "^(en|EN)(-.*)?$"

	return regexp.MustCompile(
		pattern,
	)
}

var isBCP47ForEnglishRe = constructIsBCP47ForEnglish()

// Check that the text corresponds to a BCP47 code for english.
func IsBCP47ForEnglish(text string) bool {
	return isBCP47ForEnglishRe.MatchString(
		text,
	)
}

// Verify `that` instance of [aastypes.IExtension].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyExtension(
	that aastypes.IExtension,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.RefersTo() != nil) ||
		(len(that.RefersTo()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Refers-to must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		ValueConsistentWithXSDType(
			*that.Value(),
			that.ValueTypeOrDefault(),
		)) {
		abort = onError(
			newVerificationError(
				"The value must match the value type.",),
		)
		if abort {
			return
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	abort = VerifyNameType(
		that.Name(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Name",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.ValueType() != nil {
		if
			*that.ValueType() < aastypes.DataTypeDefXSDAnyURI ||
			*that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort {
			err := newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for DataTypeDefXSD: %v",
					that.ValueType(),
				),
			)
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueType",
				},
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyValueDataType(
			*that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.RefersTo() != nil {
		for i, v := range that.RefersTo() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "RefersTo",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IAdministrativeInformation].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAdministrativeInformation(
	that aastypes.IAdministrativeInformation,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Revision() != nil) ||
		(that.Version() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-005: If version is not specified then also " +
				"revision shall be unspecified. This means, a revision " +
				"requires a version. If there is no version there is no " +
				"revision either. Revision is optional.",
			),
		)
		if abort {
			return
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Version() != nil {
		abort = VerifyVersionType(
			*that.Version(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Version",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Revision() != nil {
		abort = VerifyRevisionType(
			*that.Revision(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Revision",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Creator() != nil {
		abort = Verify(
			that.Creator(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Creator",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.TemplateID() != nil {
		abort = VerifyIdentifier(
			*that.TemplateID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "TemplateID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IQualifier].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyQualifier(
	that aastypes.IQualifier,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		ValueConsistentWithXSDType(
			*that.Value(),
			that.ValueType(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-020: The value shall be consistent to " +
				"the data type as defined in value type.",
			),
		)
		if abort {
			return
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Kind() != nil {
		if
			*that.Kind() < aastypes.QualifierKindValueQualifier ||
			*that.Kind() > aastypes.QualifierKindTemplateQualifier {
			err := newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for QualifierKind: %v",
					that.Kind(),
				),
			)
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Kind",
				},
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	abort = VerifyQualifierType(
		that.Type(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Type",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if
		that.ValueType() < aastypes.DataTypeDefXSDAnyURI ||
		that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for DataTypeDefXSD: %v",
				that.ValueType(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.Value() != nil {
		abort = VerifyValueDataType(
			*that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.ValueID() != nil {
		abort = Verify(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IAssetAdministrationShell].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAssetAdministrationShell(
	that aastypes.IAssetAdministrationShell,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Submodels() != nil) ||
		(len(that.Submodels()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Submodels must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DerivedFrom() != nil) ||
		IsModelReferenceTo(
			that.DerivedFrom(),
			aastypes.KeyTypesAssetAdministrationShell,
		)) {
		abort = onError(
			newVerificationError(
				"Derived-from must be a model reference to an asset " +
				"administration shell.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Submodels() != nil) ||
		aascommon.All(
			func(reference aastypes.IReference) bool {
				return IsModelReferenceTo(
						reference,
						aastypes.KeyTypesSubmodel,
					)
			},
			that.Submodels(),
		)) {
		abort = onError(
			newVerificationError(
				"All submodels must be model references to a submodel.",),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Administration() != nil {
		abort = Verify(
			that.Administration(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.ID(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.DerivedFrom() != nil {
		abort = Verify(
			that.DerivedFrom(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DerivedFrom",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.AssetInformation() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: AssetInformation",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.AssetInformation(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetInformation",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Submodels() != nil {
		for i, v := range that.Submodels() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Submodels",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IAssetInformation].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAssetInformation(
	that aastypes.IAssetInformation,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.SpecificAssetIDs() != nil) ||
		aascommon.All(
			func(specificAssetID aastypes.ISpecificAssetID) bool {
				return specificAssetID.Name() != "globalAssetId" ||
					((that.GlobalAssetID() != nil) &&
					specificAssetID.Name() == "globalAssetId" &&
					specificAssetID.Value() == *that.GlobalAssetID())
			},
			that.SpecificAssetIDs(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-116: ``globalAssetId`` is a reserved key. " +
				"If used as value for the name of specific asset ID then " +
				"the value of specific asset ID shall be identical to " +
				"the global asset ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		((that.GlobalAssetID() != nil) ||
		(that.SpecificAssetIDs() != nil)) &&
		(!(that.SpecificAssetIDs() != nil) ||
		(len(that.SpecificAssetIDs()) >= 1))) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-131: Either the global asset ID shall be " +
				"defined or at least one specific asset ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SpecificAssetIDs() != nil) ||
		(len(that.SpecificAssetIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Specific asset IDs must be either not set or have at least " +
				"one item.",
			),
		)
		if abort {
			return
		}
	}

	if
		that.AssetKind() < aastypes.AssetKindType ||
		that.AssetKind() > aastypes.AssetKindNotApplicable {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for AssetKind: %v",
				that.AssetKind(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "AssetKind",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.GlobalAssetID() != nil {
		abort = VerifyIdentifier(
			*that.GlobalAssetID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "GlobalAssetID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SpecificAssetIDs() != nil {
		for i, v := range that.SpecificAssetIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SpecificAssetIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.AssetType() != nil {
		abort = VerifyIdentifier(
			*that.AssetType(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetType",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DefaultThumbnail() != nil {
		abort = Verify(
			that.DefaultThumbnail(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DefaultThumbnail",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IResource].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyResource(
	that aastypes.IResource,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	abort = VerifyPathType(
		that.Path(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Path",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.ContentType() != nil {
		abort = VerifyContentType(
			*that.ContentType(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ContentType",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISpecificAssetID].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySpecificAssetID(
	that aastypes.ISpecificAssetID,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.ExternalSubjectID() != nil) ||
		(that.ExternalSubjectID().Type() == aastypes.ReferenceTypesExternalReference)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-133: External subject ID shall be " +
				"an external reference.",
			),
		)
		if abort {
			return
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	abort = VerifyLabelType(
		that.Name(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Name",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	abort = VerifyIdentifier(
		that.Value(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.ExternalSubjectID() != nil {
		abort = Verify(
			that.ExternalSubjectID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ExternalSubjectID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISubmodel].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySubmodel(
	that aastypes.ISubmodel,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SubmodelElements() != nil) ||
		(len(that.SubmodelElements()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Submodel elements must be either not set or have at least " +
				"one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SubmodelElements() != nil) ||
		aascommon.All(
			func(item aastypes.ISubmodelElement) bool {
				return item.IDShort() != nil
			},
			that.SubmodelElements(),
		)) {
		abort = onError(
			newVerificationError(
				"ID-shorts need to be defined for all the items of submodel " +
				"elements according to AASd-117 (ID-short of Referables not " +
				"being a direct child of a Submodel element list shall be " +
				"specified).",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SubmodelElements() != nil) ||
		IDShortsAreUnique(that.SubmodelElements())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-022: ID-short of non-identifiable " +
				"referables within the same name space shall be unique " +
				"(case-sensitive).",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SubmodelElements() != nil) ||
		(!(that.KindOrDefault() != aastypes.ModellingKindTemplate) ||
		aascommon.All(
			func(submodelElement aastypes.ISubmodelElement) bool {
				return !(submodelElement.Qualifiers() != nil) ||
					aascommon.All(
						func(qualifier aastypes.IQualifier) bool {
							return qualifier.KindOrDefault() != aastypes.QualifierKindTemplateQualifier
						},
						submodelElement.Qualifiers(),
					)
			},
			that.SubmodelElements(),
		))) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-129: If any qualifier kind value of " +
				"a Submodel element qualifier (attribute qualifier inherited " +
				"via Qualifiable) is equal to Template Qualifier then " +
				"the submodel element shall be part of a submodel template, " +
				"i.e. a Submodel with submodel kind (attribute kind " +
				"inherited via Has-Kind) value is equal to Template.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(!aascommon.Some(
			func(qualifier aastypes.IQualifier) bool {
				return qualifier.KindOrDefault() == aastypes.QualifierKindTemplateQualifier
			},
			that.Qualifiers(),
		) ||
		(that.KindOrDefault() == aastypes.ModellingKindTemplate))) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-119: If any qualifier kind value of " +
				"a qualifiable qualifier is equal to template qualifier and " +
				"the qualified element has kind then the qualified element " +
				"shall be of kind template.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Administration() != nil {
		abort = Verify(
			that.Administration(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.ID(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.Kind() != nil {
		if
			*that.Kind() < aastypes.ModellingKindTemplate ||
			*that.Kind() > aastypes.ModellingKindInstance {
			err := newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for ModellingKind: %v",
					that.Kind(),
				),
			)
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Kind",
				},
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SubmodelElements() != nil {
		for i, v := range that.SubmodelElements() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SubmodelElements",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IRelationshipElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyRelationshipElement(
	that aastypes.IRelationshipElement,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.First() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: First",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.First(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "First",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Second() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: Second",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.Second(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Second",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISubmodelElementList].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySubmodelElementList(
	that aastypes.ISubmodelElementList,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		(len(that.Value()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Value must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.Value() != nil) &&
		(that.SemanticIDListElement() != nil)) ||
		aascommon.All(
			func(child aastypes.ISubmodelElement) bool {
				return !(child.SemanticID() != nil) ||
					ReferenceKeyValuesEqual(
						child.SemanticID(),
						that.SemanticIDListElement(),
					)
			},
			that.Value(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-107: If a first level child element has " +
				"a semantic ID it shall be identical to semantic ID list " +
				"element.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		SubmodelElementsHaveIdenticalSemanticIDs(
			that.Value(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-114: If two first level child elements have " +
				"a semantic ID then they shall be identical.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		aascommon.All(
			func(element aastypes.ISubmodelElement) bool {
				return SubmodelElementIsOfType(
						element,
						that.TypeValueListElement(),
					)
			},
			that.Value(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-108: All first level child elements shall " +
				"have the same submodel element type as specified in type " +
				"value list element.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.Value() != nil) &&
		(that.TypeValueListElement() == aastypes.AASSubmodelElementsProperty ||
		that.TypeValueListElement() == aastypes.AASSubmodelElementsRange)) ||
		((that.ValueTypeListElement() != nil) &&
		PropertiesOrRangesHaveValueType(
			that.Value(),
			*that.ValueTypeListElement(),
		))) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-109: If type value list element is equal to " +
				"Property or Range value type list element shall be set and " +
				"all first level child elements shall have the value type as " +
				"specified in value type list element.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		aascommon.All(
			func(element aastypes.ISubmodelElement) bool {
				return element.IDShort() == nil
			},
			that.Value(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-120: ID-short of submodel elements being " +
				"a direct child of a  Submodel element list shall not be " +
				"specified.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticIDListElement() != nil {
		abort = Verify(
			that.SemanticIDListElement(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticIDListElement",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if
		that.TypeValueListElement() < aastypes.AASSubmodelElementsAnnotatedRelationshipElement ||
		that.TypeValueListElement() > aastypes.AASSubmodelElementsSubmodelElementCollection {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for AASSubmodelElements: %v",
				that.TypeValueListElement(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "TypeValueListElement",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.ValueTypeListElement() != nil {
		if
			*that.ValueTypeListElement() < aastypes.DataTypeDefXSDAnyURI ||
			*that.ValueTypeListElement() > aastypes.DataTypeDefXSDUnsignedShort {
			err := newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for DataTypeDefXSD: %v",
					that.ValueTypeListElement(),
				),
			)
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueTypeListElement",
				},
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		for i, v := range that.Value() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Value",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISubmodelElementCollection].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySubmodelElementCollection(
	that aastypes.ISubmodelElementCollection,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		(len(that.Value()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Value must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		aascommon.All(
			func(item aastypes.ISubmodelElement) bool {
				return item.IDShort() != nil
			},
			that.Value(),
		)) {
		abort = onError(
			newVerificationError(
				"ID-shorts need to be defined for all the items of value " +
				"according to AASd-117 (ID-short of Referables not being " +
				"a direct child of a Submodel element list shall be " +
				"specified).",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		IDShortsAreUnique(that.Value())) {
		abort = onError(
			newVerificationError(
				"ID-shorts of the value must be unique.",),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		for i, v := range that.Value() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Value",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IProperty].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyProperty(
	that aastypes.IProperty,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Category() != nil) ||
		aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			*that.Category(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-090: For data elements category shall be " +
				"one of the following values: CONSTANT, PARAMETER or " +
				"VARIABLE.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		ValueConsistentWithXSDType(
			*that.Value(),
			that.ValueType(),
		)) {
		abort = onError(
			newVerificationError(
				"Value must be consistent with the value type.",),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if
		that.ValueType() < aastypes.DataTypeDefXSDAnyURI ||
		that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for DataTypeDefXSD: %v",
				that.ValueType(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.Value() != nil {
		abort = VerifyValueDataType(
			*that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.ValueID() != nil {
		abort = Verify(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IMultiLanguageProperty].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyMultiLanguageProperty(
	that aastypes.IMultiLanguageProperty,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Category() != nil) ||
		aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			*that.Category(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-090: For data elements category shall be " +
				"one of the following values: CONSTANT, PARAMETER or " +
				"VARIABLE.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		LangStringsHaveUniqueLanguages(that.Value())) {
		abort = onError(
			newVerificationError(
				"Value must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Value() != nil) ||
		(len(that.Value()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Value must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		for i, v := range that.Value() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Value",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.ValueID() != nil {
		abort = Verify(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IRange].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyRange(
	that aastypes.IRange,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Category() != nil) ||
		aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			*that.Category(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-090: For data elements category shall be " +
				"one of the following values: CONSTANT, PARAMETER or " +
				"VARIABLE.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Max() != nil) ||
		ValueConsistentWithXSDType(
			*that.Max(),
			that.ValueType(),
		)) {
		abort = onError(
			newVerificationError(
				"Max must be consistent with the value type.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Min() != nil) ||
		ValueConsistentWithXSDType(
			*that.Min(),
			that.ValueType(),
		)) {
		abort = onError(
			newVerificationError(
				"Min must be consistent with the value type.",),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if
		that.ValueType() < aastypes.DataTypeDefXSDAnyURI ||
		that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for DataTypeDefXSD: %v",
				that.ValueType(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.Min() != nil {
		abort = VerifyValueDataType(
			*that.Min(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Min",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Max() != nil {
		abort = VerifyValueDataType(
			*that.Max(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Max",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IReferenceElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyReferenceElement(
	that aastypes.IReferenceElement,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Category() != nil) ||
		aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			*that.Category(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-090: For data elements category shall be " +
				"one of the following values: CONSTANT, PARAMETER or " +
				"VARIABLE.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = Verify(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IBlob].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBlob(
	that aastypes.IBlob,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Category() != nil) ||
		aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			*that.Category(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-090: For data elements category shall be " +
				"one of the following values: CONSTANT, PARAMETER or " +
				"VARIABLE.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyBlobType(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	abort = VerifyContentType(
		that.ContentType(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ContentType",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IFile].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyFile(
	that aastypes.IFile,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Category() != nil) ||
		aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			*that.Category(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-090: For data elements category shall be " +
				"one of the following values: CONSTANT, PARAMETER or " +
				"VARIABLE.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyPathType(
			*that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	abort = VerifyContentType(
		that.ContentType(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ContentType",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IAnnotatedRelationshipElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAnnotatedRelationshipElement(
	that aastypes.IAnnotatedRelationshipElement,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Annotations() != nil) ||
		(len(that.Annotations()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Annotations must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Annotations() != nil) ||
		aascommon.All(
			func(item aastypes.IDataElement) bool {
				return item.IDShort() != nil
			},
			that.Annotations(),
		)) {
		abort = onError(
			newVerificationError(
				"ID-shorts need to be defined for all the items of " +
				"annotations according to AASd-117 (ID-short of Referables " +
				"not being a direct child of a Submodel element list shall " +
				"be specified).",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.First() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: First",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.First(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "First",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Second() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: Second",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.Second(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Second",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Annotations() != nil {
		for i, v := range that.Annotations() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Annotations",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IEntity].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEntity(
	that aastypes.IEntity,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Statements() != nil) ||
		(len(that.Statements()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Statements must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Statements() != nil) ||
		aascommon.All(
			func(item aastypes.ISubmodelElement) bool {
				return item.IDShort() != nil
			},
			that.Statements(),
		)) {
		abort = onError(
			newVerificationError(
				"ID-shorts need to be defined for all the items of " +
				"statements according to AASd-117 (ID-short of Referables " +
				"not being a direct child of a Submodel element list shall " +
				"be specified).",
			),
		)
		if abort {
			return
		}
	}

	if !(
		(that.EntityType() == aastypes.EntityTypeSelfManagedEntity &&
		(((that.GlobalAssetID() != nil) &&
		(that.SpecificAssetIDs() == nil)) ||
		((that.GlobalAssetID() == nil) &&
		(that.SpecificAssetIDs() != nil) &&
		len(that.SpecificAssetIDs()) >= 1))) ||
		(that.EntityType() != aastypes.EntityTypeSelfManagedEntity &&
		(that.GlobalAssetID() == nil) &&
		(that.SpecificAssetIDs() == nil))) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-014: Either the attribute global asset ID " +
				"or specific asset ID must be set if entity type is set to " +
				"self-managed entity. They are not existing otherwise.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SpecificAssetIDs() != nil) ||
		(len(that.SpecificAssetIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Specific asset IDs must be either not set or have at least " +
				"one item.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Statements() != nil {
		for i, v := range that.Statements() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Statements",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if
		that.EntityType() < aastypes.EntityTypeCoManagedEntity ||
		that.EntityType() > aastypes.EntityTypeSelfManagedEntity {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for EntityType: %v",
				that.EntityType(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "EntityType",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.GlobalAssetID() != nil {
		abort = VerifyIdentifier(
			*that.GlobalAssetID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "GlobalAssetID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SpecificAssetIDs() != nil {
		for i, v := range that.SpecificAssetIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SpecificAssetIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IEventPayload].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEventPayload(
	that aastypes.IEventPayload,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		IsModelReferenceTo(
			that.Source(),
			aastypes.KeyTypesEventElement,
		) ||
		IsModelReferenceTo(
			that.Source(),
			aastypes.KeyTypesBasicEventElement,
		)) {
		abort = onError(
			newVerificationError(
				"Source must be a model reference to an Event element.",),
		)
		if abort {
			return
		}
	}

	if !(
		IsModelReferenceToReferable(
			that.ObservableReference(),
		)) {
		abort = onError(
			newVerificationError(
				"Observable reference must be a model reference to " +
				"a referable.",
			),
		)
		if abort {
			return
		}
	}

	if that.Source() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: Source",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.Source(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Source",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SourceSemanticID() != nil {
		abort = Verify(
			that.SourceSemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SourceSemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.ObservableReference() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: ObservableReference",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.ObservableReference(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ObservableReference",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.ObservableSemanticID() != nil {
		abort = Verify(
			that.ObservableSemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ObservableSemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Topic() != nil {
		abort = VerifyMessageTopicType(
			*that.Topic(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Topic",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SubjectID() != nil {
		abort = Verify(
			that.SubjectID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SubjectID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	abort = VerifyDateTimeUTC(
		that.TimeStamp(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "TimeStamp",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.Payload() != nil {
		abort = VerifyBlobType(
			that.Payload(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Payload",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IBasicEventElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBasicEventElement(
	that aastypes.IBasicEventElement,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Direction() == aastypes.DirectionInput) ||
		(that.MaxInterval() == nil)) {
		abort = onError(
			newVerificationError(
				"Max. interval is not applicable for input direction.",),
		)
		if abort {
			return
		}
	}

	if !IsModelReferenceToReferable(that.Observed()) {
		abort = onError(
			newVerificationError(
				"Observed must be a model reference to a referable.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.MessageBroker() != nil) ||
		IsModelReferenceToReferable(that.MessageBroker())) {
		abort = onError(
			newVerificationError(
				"Message broker must be a model reference to a referable.",),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Observed() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: Observed",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.Observed(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Observed",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if
		that.Direction() < aastypes.DirectionInput ||
		that.Direction() > aastypes.DirectionOutput {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for Direction: %v",
				that.Direction(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Direction",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if
		that.State() < aastypes.StateOfEventOn ||
		that.State() > aastypes.StateOfEventOff {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for StateOfEvent: %v",
				that.State(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "State",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.MessageTopic() != nil {
		abort = VerifyMessageTopicType(
			*that.MessageTopic(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MessageTopic",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.MessageBroker() != nil {
		abort = Verify(
			that.MessageBroker(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MessageBroker",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.LastUpdate() != nil {
		abort = VerifyDateTimeUTC(
			*that.LastUpdate(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "LastUpdate",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.MinInterval() != nil {
		abort = VerifyDuration(
			*that.MinInterval(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MinInterval",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.MaxInterval() != nil {
		abort = VerifyDuration(
			*that.MaxInterval(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MaxInterval",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IOperation].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyOperation(
	that aastypes.IOperation,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		IDShortsOfVariablesAreUnique(
			that.InputVariables(),
			that.OutputVariables(),
			that.InoutputVariables(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-134: For an Operation the ID-short of all " +
				"values of input, output and in/output variables.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.InputVariables() != nil) ||
		(len(that.InputVariables()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Input variables must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.OutputVariables() != nil) ||
		(len(that.OutputVariables()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Output variables must be either not set or have at least " +
				"one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.InoutputVariables() != nil) ||
		(len(that.InoutputVariables()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Inoutput variables must be either not set or have at least " +
				"one item.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.InputVariables() != nil {
		for i, v := range that.InputVariables() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "InputVariables",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.OutputVariables() != nil {
		for i, v := range that.OutputVariables() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "OutputVariables",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.InoutputVariables() != nil {
		for i, v := range that.InoutputVariables() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "InoutputVariables",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IOperationVariable].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyOperationVariable(
	that aastypes.IOperationVariable,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(that.Value().IDShort() != nil) {
		abort = onError(
			newVerificationError(
				"Value must have the ID-short specified according to " +
				"Constraint AASd-117 (ID-short of Referables not being " +
				"a direct child of a Submodel element list shall be " +
				"specified).",
			),
		)
		if abort {
			return
		}
	}

	if that.Value() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: Value",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ICapability].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyCapability(
	that aastypes.ICapability,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(len(that.SupplementalSemanticIDs()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Supplemental semantic IDs must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.SupplementalSemanticIDs() != nil) ||
		(that.SemanticID() != nil)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-118: If there are supplemental semantic IDs " +
				"defined then there shall be also a main semantic ID.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		(len(that.Qualifiers()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Qualifiers must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Qualifiers() != nil) ||
		QualifierTypesAreUnique(that.Qualifiers())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-021: Every qualifiable can only have one " +
				"qualifier with the same type.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = Verify(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IConceptDescription].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyConceptDescription(
	that aastypes.IConceptDescription,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil) ||
		(len(that.Extensions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Extensions must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Extensions() != nil) ||
		ExtensionNamesAreUnique(that.Extensions())) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-077: The name of an extension within " +
				"Has-Extensions needs to be unique.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		(len(that.Description()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Description must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Description() != nil) ||
		LangStringsHaveUniqueLanguages(that.Description())) {
		abort = onError(
			newVerificationError(
				"Description must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		(len(that.DisplayName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Display name must be either not set or have at least one " +
				"item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.DisplayName() != nil) ||
		LangStringsHaveUniqueLanguages(that.DisplayName())) {
		abort = onError(
			newVerificationError(
				"Display name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(len(that.EmbeddedDataSpecifications()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Embedded data specifications must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.IsCaseOf() != nil) ||
		(len(that.IsCaseOf()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Is-case-of must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.EmbeddedDataSpecifications() != nil) ||
		(DataSpecificationIEC61360sHaveDefinitionAtLeastInEnglish(
			that.EmbeddedDataSpecifications(),
		) ||
		DataSpecificationIEC61360sHaveValue(
			that.EmbeddedDataSpecifications(),
		))) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-008: For a concept description using " +
				"data specification template IEC 61360, the definition is " +
				"mandatory and shall be defined at least in English. " +
				"Exception: The concept description describes a value.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.Category() != nil) &&
		*that.Category() == "QUALIFIER_TYPE" &&
		(that.EmbeddedDataSpecifications() != nil)) ||
		DataSpecificationIEC61360sHaveDataType(
			that.EmbeddedDataSpecifications(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-007: For a concept description with " +
				"category QUALIFIER_TYPE using data specification IEC 61360, " +
				"the data type of the data specification is mandatory and " +
				"shall be defined.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.Category() != nil) &&
		*that.Category() == "DOCUMENT" &&
		(that.EmbeddedDataSpecifications() != nil)) ||
		DataSpecificationIEC61360sForDocumentHaveAppropriateDataType(
			that.EmbeddedDataSpecifications(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-006: For a concept description with " +
				"category DOCUMENT using data specification IEC 61360, " +
				"the data type of the data specification shall be one of: " +
				"FILE, BLOB, HTML.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.Category() != nil) &&
		*that.Category() == "REFERENCE" &&
		(that.EmbeddedDataSpecifications() != nil)) ||
		DataSpecificationIEC61360sForReferenceHaveAppropriateDataType(
			that.EmbeddedDataSpecifications(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-005: For a concept description with " +
				"category REFERENCE using data specification IEC 61360, " +
				"the data type of the data specification shall be one of: " +
				"STRING, IRI, IRDI.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.Category() != nil) &&
		(*that.Category() == "PROPERTY" ||
		*that.Category() == "VALUE") &&
		(that.EmbeddedDataSpecifications() != nil)) ||
		DataSpecificationIEC61360sForPropertyOrValueHaveAppropriateDataType(
			that.EmbeddedDataSpecifications(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-004: For a concept description with " +
				"category PROPERTY or VALUE using data specification IEC " +
				"61360, the data type of the data specification is mandatory " +
				"and shall be one of: DATE, STRING, STRING_TRANSLATABLE, " +
				"INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, " +
				"REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, " +
				"RATIONAL_MEASURE, TIME, TIMESTAMP.",
			),
		)
		if abort {
			return
		}
	}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			*that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			*that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Administration() != nil {
		abort = Verify(
			that.Administration(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.ID(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.IsCaseOf() != nil {
		for i, v := range that.IsCaseOf() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "IsCaseOf",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IReference].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyReference(
	that aastypes.IReference,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.Keys()) >= 1) {
		abort = onError(
			newVerificationError(
				"Keys must contain at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(len(that.Keys()) >= 1) ||
		aascommon.MapContains(
			aasconstants.GloballyIdentifiables,
			that.Keys()[0].Type(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-121: For References the value of type of " +
				"the first key of keys shall be one of Globally " +
				"Identifiables.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesExternalReference &&
		len(that.Keys()) >= 1) ||
		aascommon.MapContains(
			aasconstants.GenericGloballyIdentifiables,
			that.Keys()[0].Type(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-122: For external references the value of " +
				"type of the first key of keys shall be one of Generic " +
				"Globally Identifiables.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesModelReference &&
		len(that.Keys()) >= 1) ||
		aascommon.MapContains(
			aasconstants.AASIdentifiables,
			that.Keys()[0].Type(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-123: For model references the value of type " +
				"of the first key of keys shall be one of AAS identifiables.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesExternalReference &&
		len(that.Keys()) >= 1) ||
		(aascommon.MapContains(
			aasconstants.GenericGloballyIdentifiables,
			that.Keys()[len(that.Keys()) - 1].Type(),
		) ||
		aascommon.MapContains(
			aasconstants.GenericFragmentKeys,
			that.Keys()[len(that.Keys()) - 1].Type(),
		))) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-124: For external references the last key " +
				"of keys shall be either one of Generic Globally " +
				"Identifiables or one of Generic Fragment Keys.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesModelReference &&
		len(that.Keys()) > 1) ||
		aascommon.AllRange(
			func(i int) bool {
				return aascommon.MapContains(
						aasconstants.FragmentKeys,
						that.Keys()[i].Type(),
					)
			},
			1,
			len(that.Keys()),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-125: For model references with more than " +
				"one key in keys the value of type of each of the keys " +
				"following the first key of keys shall be one of Fragment " +
				"Keys.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesModelReference &&
		len(that.Keys()) > 1) ||
		aascommon.AllRange(
			func(i int) bool {
				return !aascommon.MapContains(
						aasconstants.GenericFragmentKeys,
						that.Keys()[i].Type(),
					)
			},
			0,
			len(that.Keys()) - 1,
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-126: For model references with more than " +
				"one key in keys the value of type of the last key in " +
				"the reference key chain may be one of Generic Fragment Keys " +
				"or no key at all shall have a value out of Generic Fragment " +
				"Keys.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesModelReference &&
		len(that.Keys()) > 1 &&
		that.Keys()[len(that.Keys()) - 1].Type() == aastypes.KeyTypesFragmentReference) ||
		(that.Keys()[len(that.Keys()) - 2].Type() == aastypes.KeyTypesFile ||
		that.Keys()[len(that.Keys()) - 2].Type() == aastypes.KeyTypesBlob)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-127: For model references, with more than " +
				"one key in keys a key with type Fragment Reference shall be " +
				"preceded by a key with type File or Blob.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Type() == aastypes.ReferenceTypesModelReference &&
		len(that.Keys()) > 2) ||
		aascommon.AllRange(
			func(i int) bool {
				return !(that.Keys()[i].Type() == aastypes.KeyTypesSubmodelElementList) ||
					MatchesXsPositiveInteger(that.Keys()[i + 1].Value())
			},
			0,
			len(that.Keys()) - 1,
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-128: For model references, the value of " +
				"a key preceded by a key with type Submodel element list is " +
				"an integer number denoting the position in the array of " +
				"the submodel element list.",
			),
		)
		if abort {
			return
		}
	}

	if
		that.Type() < aastypes.ReferenceTypesExternalReference ||
		that.Type() > aastypes.ReferenceTypesModelReference {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for ReferenceTypes: %v",
				that.Type(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Type",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.ReferredSemanticID() != nil {
		abort = Verify(
			that.ReferredSemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ReferredSemanticID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Keys() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: Keys",
			),
		)
		if abort {
			return
		}
	} else {
		for i, v := range that.Keys() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Keys",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IKey].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyKey(
	that aastypes.IKey,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if
		that.Type() < aastypes.KeyTypesAnnotatedRelationshipElement ||
		that.Type() > aastypes.KeyTypesSubmodelElementList {
		err := newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for KeyTypes: %v",
				that.Type(),
			),
		)
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Type",
			},
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.Value(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringNameType].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringNameType(
	that aastypes.ILangStringNameType,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 128) {
		abort = onError(
			newVerificationError(
				"String shall have a maximum length of 128 characters.",),
		)
		if abort {
			return
		}
	}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringTextType].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringTextType(
	that aastypes.ILangStringTextType,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 1023) {
		abort = onError(
			newVerificationError(
				"String shall have a maximum length of 1023 characters.",),
		)
		if abort {
			return
		}
	}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IEnvironment].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEnvironment(
	that aastypes.IEnvironment,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!(that.ConceptDescriptions() != nil) ||
		(len(that.ConceptDescriptions()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Concept descriptions must be either not set or have at " +
				"least one item.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Submodels() != nil) ||
		(len(that.Submodels()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Submodels must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.AssetAdministrationShells() != nil) ||
		(len(that.AssetAdministrationShells()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Asset administration shells must be either not set or have " +
				"at least one item.",
			),
		)
		if abort {
			return
		}
	}

	if that.AssetAdministrationShells() != nil {
		for i, v := range that.AssetAdministrationShells() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "AssetAdministrationShells",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Submodels() != nil {
		for i, v := range that.Submodels() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Submodels",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.ConceptDescriptions() != nil {
		for i, v := range that.ConceptDescriptions() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "ConceptDescriptions",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IEmbeddedDataSpecification].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEmbeddedDataSpecification(
	that aastypes.IEmbeddedDataSpecification,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if that.DataSpecification() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: DataSpecification",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.DataSpecification(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DataSpecification",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DataSpecificationContent() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: DataSpecificationContent",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.DataSpecificationContent(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DataSpecificationContent",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ILevelType].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLevelType(
	that aastypes.ILevelType,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	// No verification has been defined for ILevelType.

	return
}

// Verify `that` instance of [aastypes.IValueReferencePair].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueReferencePair(
	that aastypes.IValueReferencePair,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	abort = VerifyValueTypeIEC61360(
		that.Value(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	if that.ValueID() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: ValueID",
			),
		)
		if abort {
			return
		}
	} else {
		abort = Verify(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IValueList].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueList(
	that aastypes.IValueList,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.ValueReferencePairs()) >= 1) {
		abort = onError(
			newVerificationError(
				"Value reference pair types must contain at least one item.",),
		)
		if abort {
			return
		}
	}

	if that.ValueReferencePairs() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: ValueReferencePairs",
			),
		)
		if abort {
			return
		}
	} else {
		for i, v := range that.ValueReferencePairs() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "ValueReferencePairs",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringPreferredNameTypeIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringPreferredNameTypeIEC61360(
	that aastypes.ILangStringPreferredNameTypeIEC61360,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 255) {
		abort = onError(
			newVerificationError(
				"String shall have a maximum length of 255 characters.",),
		)
		if abort {
			return
		}
	}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringShortNameTypeIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringShortNameTypeIEC61360(
	that aastypes.ILangStringShortNameTypeIEC61360,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 18) {
		abort = onError(
			newVerificationError(
				"String shall have a maximum length of 18 characters.",),
		)
		if abort {
			return
		}
	}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringDefinitionTypeIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringDefinitionTypeIEC61360(
	that aastypes.ILangStringDefinitionTypeIEC61360,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 1023) {
		abort = onError(
			newVerificationError(
				"String shall have a maximum length of 1023 characters.",),
		)
		if abort {
			return
		}
	}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text",
				},
			)
			return onError(err)
		},
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IDataSpecificationIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyDataSpecificationIEC61360(
	that aastypes.IDataSpecificationIEC61360,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !(
		!((that.Value() != nil) &&
		(that.ValueList() != nil))) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-010: If value is not empty then value " +
				"list shall be empty and vice versa.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!((that.DataType() != nil) &&
		aascommon.MapContains(
			aasconstants.IEC61360DataTypesWithUnit,
			*that.DataType(),
		)) ||
		((that.Unit() != nil) ||
		(that.UnitID() != nil))) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-3a-009: If data type is a an integer, real " +
				"or rational with a measure or currency, unit or unit ID " +
				"shall be defined.",
			),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Definition() != nil) ||
		(len(that.Definition()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Definition must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.Definition() != nil) ||
		LangStringsHaveUniqueLanguages(that.Definition())) {
		abort = onError(
			newVerificationError(
				"Definition must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.ShortName() != nil) ||
		(len(that.ShortName()) >= 1)) {
		abort = onError(
			newVerificationError(
				"Short name must be either not set or have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		!(that.ShortName() != nil) ||
		LangStringsHaveUniqueLanguages(that.ShortName())) {
		abort = onError(
			newVerificationError(
				"Short name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(len(that.PreferredName()) >= 1) {
		abort = onError(
			newVerificationError(
				"Preferred name must have at least one item.",),
		)
		if abort {
			return
		}
	}

	if !(
		LangStringsHaveUniqueLanguages(that.PreferredName())) {
		abort = onError(
			newVerificationError(
				"Preferred name must specify unique languages.",),
		)
		if abort {
			return
		}
	}

	if !(
		aascommon.Some(
			func(langString aastypes.ILangStringPreferredNameTypeIEC61360) bool {
				return IsBCP47ForEnglish(langString.Language())
			},
			that.PreferredName(),
		)) {
		abort = onError(
			newVerificationError(
				"Constraint AASc-002: preferred name shall be provided at " +
				"least in English.",
			),
		)
		if abort {
			return
		}
	}

	if that.PreferredName() == nil {
		abort = onError(
			newVerificationError(
				"Required property not set: PreferredName",
			),
		)
		if abort {
			return
		}
	} else {
		for i, v := range that.PreferredName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "PreferredName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.ShortName() != nil {
		for i, v := range that.ShortName() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "ShortName",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.Unit() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			*that.Unit(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Unit",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.UnitID() != nil {
		abort = Verify(
			that.UnitID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "UnitID",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.SourceOfDefinition() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			*that.SourceOfDefinition(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SourceOfDefinition",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Symbol() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			*that.Symbol(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Symbol",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.DataType() != nil {
		if
			*that.DataType() < aastypes.DataTypeIEC61360Date ||
			*that.DataType() > aastypes.DataTypeIEC61360Blob {
			err := newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for DataTypeIEC61360: %v",
					that.DataType(),
				),
			)
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DataType",
				},
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.Definition() != nil {
		for i, v := range that.Definition() {
			abort = Verify(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i,
						},
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Definition",
						},
					)

					return onError(err)
				},
			)
			if abort {
				return
			}
		}
	}

	if that.ValueFormat() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			*that.ValueFormat(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueFormat",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.ValueList() != nil {
		abort = Verify(
			that.ValueList(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueList",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.Value() != nil {
		abort = VerifyValueTypeIEC61360(
			*that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	if that.LevelType() != nil {
		abort = Verify(
			that.LevelType(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "LevelType",
					},
				)
				return onError(err)
			},
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyNonEmptyXMLSerializableString(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyDateTimeUTC(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXsDateTimeUTC(that) {
		abort = onError(
			newVerificationError(
				"The value must match the pattern of xs:dateTime with " +
				"the time zone fixed to UTC.",
			),
		)
		if abort {
			return
		}
	}

	if !IsXsDateTimeUTC(that) {
		abort = onError(
			newVerificationError(
				"The value must represent a valid xs:dateTime with the time " +
				"zone fixed to UTC.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyDuration(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXsDuration(that) {
		abort = onError(
			newVerificationError(
				"The value must match the pattern of xs:duration.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBlobType(
	that []byte,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	// There is no verification specified.

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyIdentifier(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 2000) {
		abort = onError(
			newVerificationError(
				"Identifier shall have a maximum length of 2000 characters.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueTypeIEC61360(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 2000) {
		abort = onError(
			newVerificationError(
				"Value type IEC 61360 shall have a maximum length of 2000 " +
				"characters.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyNameType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 128) {
		abort = onError(
			newVerificationError(
				"Name type shall have a maximum length of 128 characters.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyVersionType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !MatchesVersionType(that) {
		abort = onError(
			newVerificationError(
				"Version type shall match the version pattern.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 4) {
		abort = onError(
			newVerificationError(
				"Version type shall have a maximum length of 4 characters.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyRevisionType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !MatchesRevisionType(that) {
		abort = onError(
			newVerificationError(
				"Revision type shall match the revision pattern.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 4) {
		abort = onError(
			newVerificationError(
				"Revision type shall have a maximum length of 4 characters.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLabelType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 64) {
		abort = onError(
			newVerificationError(
				"Label type shall have a maximum length of 64 characters.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyMessageTopicType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 255) {
		abort = onError(
			newVerificationError(
				"Message topic type shall have a maximum length of 255 " +
				"characters.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBCP47LanguageTag(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesBCP47(that) {
		abort = onError(
			newVerificationError(
				"The value must represent a value language tag conformant to " +
				"BCP 47.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyContentType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 100) {
		abort = onError(
			newVerificationError(
				"Content type shall have a maximum length of 100 characters.",),
		)
		if abort {
			return
		}
	}

	if !MatchesMIMEType(that) {
		abort = onError(
			newVerificationError(
				"The value must represent a valid content MIME type " +
				"according to RFC 2046.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyPathType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 2000) {
		abort = onError(
			newVerificationError(
				"Identifier shall have a maximum length of 2000 characters.",),
		)
		if abort {
			return
		}
	}

	if !MatchesRFC8089Path(that) {
		abort = onError(
			newVerificationError(
				"The value must represent a valid file URI scheme according " +
				"to RFC 8089.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyQualifierType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 128) {
		abort = onError(
			newVerificationError(
				"Name type shall have a maximum length of 128 characters.",),
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueDataType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	// There is no verification specified.

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyIDShortType(
	that string,
	onError func(*VerificationError) bool,
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		abort = onError(
			newVerificationError(
				"Constraint AASd-130: An attribute with data type 'string' " +
				"shall consist of these characters only: " +
				"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.",
			),
		)
		if abort {
			return
		}
	}

	if !(len(that) >= 1) {
		abort = onError(
			newVerificationError(
				"The value must not be empty.",),
		)
		if abort {
			return
		}
	}

	if !(len(that) <= 128) {
		abort = onError(
			newVerificationError(
				"Name type shall have a maximum length of 128 characters.",),
		)
		if abort {
			return
		}
	}

	if !MatchesIDShort(that) {
		abort = onError(
			newVerificationError(
				"ID-short of Referables shall only feature letters, digits, " +
				"underscore (``_``); starting mandatory with a letter. " +
				"*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``.",
			),
		)
		if abort {
			return
		}
	}

	return
}

// Verify ``that`` instance.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func Verify(
	that aastypes.IClass,
	onError func(*VerificationError) bool,
) (abort bool) {
	modelType := that.ModelType()
	switch modelType {
	case aastypes.ModelTypeExtension:
		abort = VerifyExtension(
			that.(aastypes.IExtension),
			onError,
		)
	case aastypes.ModelTypeAdministrativeInformation:
		abort = VerifyAdministrativeInformation(
			that.(aastypes.IAdministrativeInformation),
			onError,
		)
	case aastypes.ModelTypeQualifier:
		abort = VerifyQualifier(
			that.(aastypes.IQualifier),
			onError,
		)
	case aastypes.ModelTypeAssetAdministrationShell:
		abort = VerifyAssetAdministrationShell(
			that.(aastypes.IAssetAdministrationShell),
			onError,
		)
	case aastypes.ModelTypeAssetInformation:
		abort = VerifyAssetInformation(
			that.(aastypes.IAssetInformation),
			onError,
		)
	case aastypes.ModelTypeResource:
		abort = VerifyResource(
			that.(aastypes.IResource),
			onError,
		)
	case aastypes.ModelTypeSpecificAssetID:
		abort = VerifySpecificAssetID(
			that.(aastypes.ISpecificAssetID),
			onError,
		)
	case aastypes.ModelTypeSubmodel:
		abort = VerifySubmodel(
			that.(aastypes.ISubmodel),
			onError,
		)
	case aastypes.ModelTypeRelationshipElement:
		abort = VerifyRelationshipElement(
			that.(aastypes.IRelationshipElement),
			onError,
		)
	case aastypes.ModelTypeSubmodelElementList:
		abort = VerifySubmodelElementList(
			that.(aastypes.ISubmodelElementList),
			onError,
		)
	case aastypes.ModelTypeSubmodelElementCollection:
		abort = VerifySubmodelElementCollection(
			that.(aastypes.ISubmodelElementCollection),
			onError,
		)
	case aastypes.ModelTypeProperty:
		abort = VerifyProperty(
			that.(aastypes.IProperty),
			onError,
		)
	case aastypes.ModelTypeMultiLanguageProperty:
		abort = VerifyMultiLanguageProperty(
			that.(aastypes.IMultiLanguageProperty),
			onError,
		)
	case aastypes.ModelTypeRange:
		abort = VerifyRange(
			that.(aastypes.IRange),
			onError,
		)
	case aastypes.ModelTypeReferenceElement:
		abort = VerifyReferenceElement(
			that.(aastypes.IReferenceElement),
			onError,
		)
	case aastypes.ModelTypeBlob:
		abort = VerifyBlob(
			that.(aastypes.IBlob),
			onError,
		)
	case aastypes.ModelTypeFile:
		abort = VerifyFile(
			that.(aastypes.IFile),
			onError,
		)
	case aastypes.ModelTypeAnnotatedRelationshipElement:
		abort = VerifyAnnotatedRelationshipElement(
			that.(aastypes.IAnnotatedRelationshipElement),
			onError,
		)
	case aastypes.ModelTypeEntity:
		abort = VerifyEntity(
			that.(aastypes.IEntity),
			onError,
		)
	case aastypes.ModelTypeEventPayload:
		abort = VerifyEventPayload(
			that.(aastypes.IEventPayload),
			onError,
		)
	case aastypes.ModelTypeBasicEventElement:
		abort = VerifyBasicEventElement(
			that.(aastypes.IBasicEventElement),
			onError,
		)
	case aastypes.ModelTypeOperation:
		abort = VerifyOperation(
			that.(aastypes.IOperation),
			onError,
		)
	case aastypes.ModelTypeOperationVariable:
		abort = VerifyOperationVariable(
			that.(aastypes.IOperationVariable),
			onError,
		)
	case aastypes.ModelTypeCapability:
		abort = VerifyCapability(
			that.(aastypes.ICapability),
			onError,
		)
	case aastypes.ModelTypeConceptDescription:
		abort = VerifyConceptDescription(
			that.(aastypes.IConceptDescription),
			onError,
		)
	case aastypes.ModelTypeReference:
		abort = VerifyReference(
			that.(aastypes.IReference),
			onError,
		)
	case aastypes.ModelTypeKey:
		abort = VerifyKey(
			that.(aastypes.IKey),
			onError,
		)
	case aastypes.ModelTypeLangStringNameType:
		abort = VerifyLangStringNameType(
			that.(aastypes.ILangStringNameType),
			onError,
		)
	case aastypes.ModelTypeLangStringTextType:
		abort = VerifyLangStringTextType(
			that.(aastypes.ILangStringTextType),
			onError,
		)
	case aastypes.ModelTypeEnvironment:
		abort = VerifyEnvironment(
			that.(aastypes.IEnvironment),
			onError,
		)
	case aastypes.ModelTypeEmbeddedDataSpecification:
		abort = VerifyEmbeddedDataSpecification(
			that.(aastypes.IEmbeddedDataSpecification),
			onError,
		)
	case aastypes.ModelTypeLevelType:
		abort = VerifyLevelType(
			that.(aastypes.ILevelType),
			onError,
		)
	case aastypes.ModelTypeValueReferencePair:
		abort = VerifyValueReferencePair(
			that.(aastypes.IValueReferencePair),
			onError,
		)
	case aastypes.ModelTypeValueList:
		abort = VerifyValueList(
			that.(aastypes.IValueList),
			onError,
		)
	case aastypes.ModelTypeLangStringPreferredNameTypeIEC61360:
		abort = VerifyLangStringPreferredNameTypeIEC61360(
			that.(aastypes.ILangStringPreferredNameTypeIEC61360),
			onError,
		)
	case aastypes.ModelTypeLangStringShortNameTypeIEC61360:
		abort = VerifyLangStringShortNameTypeIEC61360(
			that.(aastypes.ILangStringShortNameTypeIEC61360),
			onError,
		)
	case aastypes.ModelTypeLangStringDefinitionTypeIEC61360:
		abort = VerifyLangStringDefinitionTypeIEC61360(
			that.(aastypes.ILangStringDefinitionTypeIEC61360),
			onError,
		)
	case aastypes.ModelTypeDataSpecificationIEC61360:
		abort = VerifyDataSpecificationIEC61360(
			that.(aastypes.IDataSpecificationIEC61360),
			onError,
		)
	default:
		abort = onError(
			newVerificationError(
				fmt.Sprintf(
					"Unexpected model type literal: %v",
					modelType,
				),
			),
		)
	}
	return
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
