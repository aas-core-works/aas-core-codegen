// Package reporting provides structures and functions for reporting of errors.
package reporting

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	"fmt"
	"strings"
	"strconv"
)

type NameSegment struct{
	Name string
}

type IndexSegment struct{
	Index int
}

type Path struct{
	// A segments is expected to be either a name segment or an index segment.
	segments []interface{}
	start int
}

// Prepend the segment to the path.
//
// Grow segments exponentially if there is no place.
func (p *Path) prepend(segment interface{}) {
	// See: https://en.wikipedia.org/wiki/Amortized_analysis#Dynamic_array
	if len(p.segments) == 0 {
		p.segments = make([]interface{}, 1)
		p.segments[0] = segment
		p.start = 0
	} else if p.start > 0 {
		p.start--
		p.segments[p.start] = segment
	} else {
		s := make([]interface{}, len(p.segments) * 2)
		copy(s[len(p.segments):], p.segments)
		p.start = len(p.segments) - 1
		p.segments = s
		p.segments[p.start] = segment
	}
}

// Prepend the name segment to the path.
func (p *Path) PrependName(segment *NameSegment) {
	p.prepend(segment)
}

// Prepend the index segment to the path.
func (p *Path) PrependIndex(segment *IndexSegment) {
	p.prepend(segment)
}

// Apply the `callback` on each segment.
//
// The segment object is either a [NameSegment] or a [IndexSegment].
func (p *Path) OverSegments(callback func(interface{})) {
	start := p.start
	for i := start; i < len(p.segments); i++ {
		callback(p.segments[i])
	}
}

// Translate the path to a JSON path.
//
// The name segments are expected to denote the names of the properties
// in JSON property names, not Golang property names.
func ToJSONPath(p *Path) string {
	var b strings.Builder
	i := 0
	p.OverSegments(func(s interface{}) {
		switch v := s.(type) {
		case *NameSegment:
			if i == 0 {
				b.WriteString(v.Name)
			} else {
				b.WriteString(".")
				b.WriteString(v.Name)
			}
		case *IndexSegment:
			b.WriteString("[")
			b.WriteString(strconv.Itoa(v.Index))
			b.WriteString("]")
		default:
			panic(
				fmt.Sprintf(
					"Unexpected segment of type %T: %v",
					s, s,
				),
			)
		}

		i++
	})
	return b.String()
}

// Translate the path to a Golang access path.
//
// The name segments are expected to denote the names of the properties
// in Golang, not JSON property names.
func ToGolangPath(p *Path) string {
	// NOTE(mristin):
	// We re-use JSON path formatting as implementation, but introduce
	// a separate function to signal to the reader in which form
	// the name segments are expected (Golang property names instead
	// of JSON property names).
	return ToJSONPath(p)
}

var replacerForXPath = strings.NewReplacer(
	"/", "&#47;",
	"<", "&lt;",
	">", "&gt;",
	"\"", "&quot;",
	"'", "&apos;",
)

// Escape special characters for XPath.
func escapeForXPath(
	text string,
) string {
	return replacerForXPath.Replace(text)
}

// Generate a relative XPath based on the path segments.
//
// Leave out the leading slash (`/`). This is helpful if we
// want to embed the error report in a larger document with a prefix
// *etc.*
func ToRelativeXPath(
	p *Path,
) string {
	i := 0
	var b strings.Builder
	p.OverSegments(func(s interface{}) {
		if i > 0 {
			b.WriteString("/")
		}

		switch v := s.(type) {
			case *NameSegment:
				b.WriteString(escapeForXPath(v.Name))
			case *IndexSegment:
				b.WriteString(fmt.Sprintf("*[%d]", v.Index))
						
			default:
				panic(fmt.Sprintf("Unexpected segment of type %T: %v", s, s))
		}
		
		i++
	})
	return b.String()
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
