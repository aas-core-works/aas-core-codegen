/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

using EnumMemberAttribute = System.Runtime.Serialization.EnumMemberAttribute;
using System.Collections.Generic;  // can't alias

namespace AasCore.Aas3
{

    /// <summary>
    /// Represent a general class of an AAS model.
    /// </summary>
    public interface IClass
    {
        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce();

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend();

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor);

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context);
    }

    /// <summary>
    /// Element that can have a semantic definition.
    /// </summary>
    public interface IHasSemantics : IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }
    }

    /// <summary>
    /// Single extension of an element.
    /// </summary>
    public class Extension :
            IHasSemantics,
            IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Name of the extension.
        /// </summary>
        /// <remarks>
        /// Constraint AASd-077: The name of an extension within HasExtensions needs to be
        /// unique.
        /// </remarks>
        public string Name { get; set; }

        /// <summary>
        /// Type of the value of the extension.
        /// </summary>
        /// <remarks>
        /// Default: xsd:string
        /// </remarks>
        public DataTypeDef? ValueType { get; set; }

        /// <summary>
        /// Value of the extension
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to an element the extension refers to.
        /// </summary>
        public IReference? RefersTo { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (RefersTo != null)
            {
                yield return RefersTo;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (RefersTo != null)
            {
                yield return RefersTo;

                // Recurse
                foreach (var anItem in RefersTo.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Extension(
            string name,
            IReference? semanticId = null,
            DataTypeDef? valueType = null,
            string? value = null,
            IReference? refersTo = null)
        {
            SemanticId = semanticId;
            Name = name;
            ValueType = valueType;
            Value = value;
            RefersTo = refersTo;
        }
    }

    /// <summary>
    /// Element that can be extended by proprietary extensions.
    /// </summary>
    /// <remarks>
    /// Note: Extensions are proprietary, i.e. they do not support global interoperability.
    /// </remarks>
    public interface IHasExtensions : IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }
    }

    /// <summary>
    /// An element that is referable by its <see cref="IReferable.IdShort" />.
    /// </summary>
    /// <remarks>
    /// This identifier is not globally unique.
    /// This identifier is unique within the name space of the element.
    /// </remarks>
    public interface IReferable :
            IHasExtensions,
            IClass
    {
        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }
    }

    /// <summary>
    /// An element that has a globally unique identifier.
    /// </summary>
    public interface IIdentifiable :
            IReferable,
            IClass
    {
        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }
    }

    /// <summary>
    /// Enumeration for denoting whether an element is a template or an instance.
    /// </summary>
    public enum ModelingKind
    {
        /// <summary>
        /// Software element which specifies the common attributes shared by all instances of
        /// the template.
        /// </summary>
        /// <remarks>
        /// [SOURCE: IEC TR 62390:2005-01, 3.1.25] modified
        /// </remarks>
        [EnumMember(Value = "TEMPLATE")]
        Template,

        /// <summary>
        /// Concrete, clearly identifiable component of a certain template.
        /// </summary>
        /// <remarks>
        /// <para>It becomes an individual entity of a  template,  for example a
        /// device model, by defining specific property values.</para>
        /// <para>In an object oriented view,  an instance denotes an object of a
        /// template (class).</para>
        /// <para>[SOURCE: IEC 62890:2016, 3.1.16 65/617/CDV]  modified</para>
        /// </remarks>
        [EnumMember(Value = "INSTANCE")]
        Instance
    }

    /// <summary>
    /// An element with a kind is an element that can either represent a template or an
    /// instance.
    /// </summary>
    /// <remarks>
    /// Default for an element is that it is representing an instance.
    /// </remarks>
    public interface IHasKind : IClass
    {
        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }
    }

    /// <summary>
    /// Element that can be extended by using data specification templates.
    /// </summary>
    /// <remarks>
    /// A data specification template defines a named set of additional attributes an
    /// element may or shall have. The data specifications used are explicitly specified
    /// with their global ID.
    /// </remarks>
    public interface IHasDataSpecification : IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }
    }

    /// <summary>
    /// Administrative meta-information for an element like version information.
    /// </summary>
    public class AdministrativeInformation :
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// Version of the element.
        /// </summary>
        public string? Version { get; set; }

        /// <summary>
        /// Revision of the element.
        /// </summary>
        public string? Revision { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AdministrativeInformation(
            string? version = null,
            string? revision = null,
            List<IReference>? dataSpecifications = null)
        {
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            Version = version;
            Revision = revision;
        }
    }

    /// <summary>
    /// A constraint is used to further qualify or restrict an element.
    /// </summary>
    public interface IConstraint : IClass
    {

    }

    /// <summary>
    /// The value of a qualifiable element may be further qualified by one or more
    /// qualifiers or complex formulas.
    /// </summary>
    public interface IQualifiable : IClass
    {
        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }
    }

    /// <summary>
    /// A qualifier is a type-value-pair that makes additional statements w.r.t.  the value
    /// of the element.
    /// </summary>
    public class Qualifier :
            IConstraint,
            IHasSemantics,
            IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// The qualifier type describes the type of the qualifier that is applied to
        /// the element.
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Data type of the qualifier value.
        /// </summary>
        public DataTypeDef ValueType { get; set; }

        /// <summary>
        /// The qualifier value is the value of the qualifier.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        public IReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Qualifier(
            string type,
            DataTypeDef valueType,
            string? value = null,
            IReference? valueId = null,
            IReference? semanticId = null)
        {
            SemanticId = semanticId;
            Type = type;
            ValueType = valueType;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A formula is used to describe constraints by a logical expression.
    /// </summary>
    public class Formula :
            IConstraint,
            IClass
    {
        /// <summary>
        /// A formula may depend on referable or even external global elements that are used in
        /// the logical expression.
        /// </summary>
        /// <remarks>
        /// The value of the referenced elements needs to be accessible so that it can be
        /// evaluated in the formula to true or false in the corresponding logical expression
        /// it is used in.
        /// </remarks>
        public List<IReference> DependsOn { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DependsOn)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DependsOn)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Formula(List<IReference>? dependsOn)
        {
            DependsOn = (dependsOn != null)
                ? dependsOn
                : new List<IReference>();
        }
    }

    /// <summary>
    /// Structure a digital representation of an asset.
    /// </summary>
    public class AssetAdministrationShell :
            IIdentifiable,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The reference to the AAS the AAS was derived from.
        /// </summary>
        public IReference? DerivedFrom { get; set; }

        /// <summary>
        /// Meta-information about the asset the AAS is representing.
        /// </summary>
        public AssetInformation AssetInformation { get; set; }

        /// <summary>
        /// References to submodels of the AAS.
        /// </summary>
        /// <remarks>
        /// A submodel is a description of an aspect of the asset the AAS is representing.
        /// The asset of an AAS is typically described by one or more submodels. Temporarily
        /// no submodel might be assigned to the AAS.
        /// </remarks>
        public List<IReference> Submodels { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;
            }

            yield return AssetInformation;

            foreach (var anItem in Submodels)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;

                // Recurse
                foreach (var anItem in DerivedFrom.Descend())
                {
                    yield return anItem;
                }
            }

            yield return AssetInformation;

            // Recurse
            foreach (var anItem in AssetInformation.Descend())
            {
                yield return anItem;
            }

            foreach (var anItem in Submodels)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AssetAdministrationShell(
            string id,
            string idShort,
            AssetInformation assetInformation,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            AdministrativeInformation? administration = null,
            List<IReference>? dataSpecifications = null,
            IReference? derivedFrom = null,
            List<IReference>? submodels = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Id = id;
            Administration = administration;
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            DerivedFrom = derivedFrom;
            AssetInformation = assetInformation;
            Submodels = (submodels != null)
                ? submodels
                : new List<IReference>();
        }
    }

    /// <summary>
    /// Identifying meta data of the asset that is represented by an AAS.
    /// </summary>
    /// <remarks>
    /// The asset may either represent an asset type or an asset instance. The asset has
    /// a globally unique identifier plus – if needed – additional domain-specific
    /// (proprietary) identifiers. However, to support the corner case of very first
    /// phase of lifecycle where a stabilised/constant global asset identifier does not
    /// already exist, the corresponding attribute <see cref="AssetInformation.GlobalAssetId" /> is optional.
    /// </remarks>
    public class AssetInformation : IClass
    {
        /// <summary>
        /// Denotes whether the Asset is of kind "Type" or "Instance".
        /// </summary>
        public AssetKind AssetKind { get; set; }

        /// <summary>
        /// Reference to either an Asset object or a global reference to the asset the AAS is
        /// representing.
        /// </summary>
        /// <remarks>
        /// This attribute is required as soon as the AAS is exchanged via partners in the life
        /// cycle of the asset. In a first phase of the life cycle the asset might not yet have
        /// a global ID but already an internal identifier. The internal identifier would be
        /// modelled via <see cref="AssetInformation.SpecificAssetId" />.
        /// </remarks>
        public IReference? GlobalAssetId { get; set; }

        /// <summary>
        /// Additional domain-specific, typically proprietary, Identifier for the asset.
        /// </summary>
        /// <remarks>
        /// For example, serial number.
        /// </remarks>
        public IdentifierKeyValuePair? SpecificAssetId { get; set; }

        /// <summary>
        /// Thumbnail of the asset represented by the asset administration shell.
        /// </summary>
        /// <remarks>
        /// Used as default.
        /// </remarks>
        public File? DefaultThumbnail { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;

                // Recurse
                foreach (var anItem in GlobalAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;

                // Recurse
                foreach (var anItem in SpecificAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;

                // Recurse
                foreach (var anItem in DefaultThumbnail.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AssetInformation(
            AssetKind assetKind,
            IReference? globalAssetId = null,
            IdentifierKeyValuePair? specificAssetId = null,
            File? defaultThumbnail = null)
        {
            AssetKind = assetKind;
            GlobalAssetId = globalAssetId;
            SpecificAssetId = specificAssetId;
            DefaultThumbnail = defaultThumbnail;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an element is a type or an instance.
    /// </summary>
    public enum AssetKind
    {
        /// <summary>
        /// hardware or software element which specifies the common attributes shared by all
        /// instances of the type
        /// </summary>
        /// <remarks>
        /// [SOURCE: IEC TR 62390:2005-01, 3.1.25]
        /// </remarks>
        [EnumMember(Value = "Type")]
        Type,

        /// <summary>
        /// concrete, clearly identifiable component of a certain type
        /// </summary>
        /// <remarks>
        /// <para>It becomes an individual entity of a type, for example a device, by defining
        /// specific property values.</para>
        /// <para>In an object oriented view, an instance denotes an object of a class
        /// (of a type).</para>
        /// <para>[SOURCE: IEC 62890:2016, 3.1.16] 65/617/CDV</para>
        /// </remarks>
        [EnumMember(Value = "Instance")]
        Instance
    }

    /// <summary>
    /// An IdentifierKeyValuePair describes a generic identifier as key-value pair.
    /// </summary>
    public class IdentifierKeyValuePair :
            IHasSemantics,
            IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Key of the identifier
        /// </summary>
        /// <remarks>
        /// Constraint AASd-116: “globalAssetId” (case-insensitive) is a reserved key. If used
        /// as value for IdentifierKeyValuePair/key IdentifierKeyValuePair/value shall be
        /// identical to AssetInformation/globalAssetId.
        /// </remarks>
        public string Key { get; set; }

        /// <summary>
        /// The value of the identifier with the corresponding key.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// The (external) subject the key belongs to or has meaning to.
        /// </summary>
        public IReference? ExternalSubjectId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (ExternalSubjectId != null)
            {
                yield return ExternalSubjectId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (ExternalSubjectId != null)
            {
                yield return ExternalSubjectId;

                // Recurse
                foreach (var anItem in ExternalSubjectId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public IdentifierKeyValuePair(
            string key,
            string value,
            IReference? externalSubjectId = null,
            IReference? semanticId = null)
        {
            SemanticId = semanticId;
            Key = key;
            Value = value;
            ExternalSubjectId = externalSubjectId;
        }
    }

    /// <summary>
    /// A submodel defines a specific aspect of the asset represented by the AAS.
    /// </summary>
    /// <remarks>
    /// A submodel is used to structure the digital representation and technical
    /// functionality of an Administration Shell into distinguishable parts. Each submodel
    /// refers to a well-defined domain or subject matter. Submodels can become
    /// standardized and, thus, become submodels templates.
    /// </remarks>
    public class Submodel :
            IIdentifiable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// A submodel consists of zero or more submodel elements.
        /// </summary>
        public List<ISubmodelElement> SubmodelElements { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            foreach (var anItem in SubmodelElements)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in SubmodelElements)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Submodel(
            string id,
            string idShort,
            List<ISubmodelElement>? submodelElements = null,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            AdministrativeInformation? administration = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Id = id;
            Administration = administration;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            SubmodelElements = (submodelElements != null)
                ? submodelElements
                : new List<ISubmodelElement>();
        }
    }

    /// <summary>
    /// A submodel element is an element suitable for the description and differentiation of
    /// assets.
    /// </summary>
    /// <remarks>
    /// It is recommended to add a semantic ID to a submodel element.
    /// </remarks>
    public interface ISubmodelElement :
            IReferable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification,
            IClass
    {

    }

    /// <summary>
    /// A relationship element is used to define a relationship between two referable
    /// elements.
    /// </summary>
    /// <remarks>
    /// Constraint AASd-055: If the semanticId of a RelationshipElement or an
    /// AnnotatedRelationshipElement submodel element references a ConceptDescription then
    /// the ConceptDescription/category shall be one of following values: RELATIONSHIP.
    /// </remarks>
    public interface IRelationshipElement :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }
    }

    /// <summary>
    /// A submodel element list is an ordered collection of submodel elements.
    /// </summary>
    /// <remarks>
    /// Constraint AASd-093: If the semanticId of a SubmodelElementList references
    /// a ConceptDescription then the ConceptDescription/category shall be COLLECTION.
    /// </remarks>
    public class SubmodelElementList :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// The submodel element type of the submodel elements contained in the list.
        /// </summary>
        /// <remarks>
        /// Constraint AASd-108: All first level child elements in a SubmodelElementList shall
        /// have the same submodel element type as specified in
        /// SubmodelElementList/submodelElementTypeValues.
        /// </remarks>
        public SubmodelElements SubmodelElementTypeValues { get; set; }

        /// <summary>
        /// Submodel element contained in the struct.
        /// The list is ordered.
        /// </summary>
        public List<ISubmodelElement> Values { get; set; }

        /// <summary>
        /// Semantic Id the submodel elements contained in the list match to.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-107: If a first level child element in a SubmodelElementList has
        /// a semanticId it shall be identical to SubmodelElementList/semanticIdValues.</para>
        /// <para>Constraint AASd-114: If two first level child elements in a SubmodelElementList have
        /// a semanticId then they shall be identical.</para>
        /// <para>Constraint AASd-115: If a first level child element in a SubmodelElementList does
        /// not specify a semanticId then the value is assumed to be identical to
        /// SubmodelElementList/semanticIdValues.</para>
        /// </remarks>
        public IReference? SemanticIdValues { get; set; }

        /// <summary>
        /// The value type of the submodel element contained in the list.
        /// </summary>
        /// <remarks>
        /// Constraint AASd-109: If SubmodelElementList/submodelElementTypeValues equal to
        /// Property or Range SubmodelElementList/valueTypeValues shall be set and all first
        /// level child elements in the SubmodelElementList shall have the the value type
        /// as specified
        /// </remarks>
        public DataTypeDef? ValueTypeValues { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            foreach (var anItem in Values)
            {
                yield return anItem;
            }

            if (SemanticIdValues != null)
            {
                yield return SemanticIdValues;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Values)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (SemanticIdValues != null)
            {
                yield return SemanticIdValues;

                // Recurse
                foreach (var anItem in SemanticIdValues.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public SubmodelElementList(
            SubmodelElements submodelElementTypeValues,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            List<ISubmodelElement>? values = null,
            IReference? semanticIdValues = null,
            DataTypeDef? valueTypeValues = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            SubmodelElementTypeValues = submodelElementTypeValues;
            Values = (values != null)
                ? values
                : new List<ISubmodelElement>();
            SemanticIdValues = semanticIdValues;
            ValueTypeValues = valueTypeValues;
        }
    }

    /// <summary>
    /// A submodel element struct is is a logical encapsulation of multiple values. It has
    /// a number of of submodel elements.
    /// </summary>
    /// <remarks>
    /// Constraint AASd-092: If the semanticId of a SubmodelElementStruct references
    /// a ConceptDescription then the ConceptDescription/category shall be ENTITY.
    /// </remarks>
    public class SubmodelElementStruct :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Submodel element contained in the struct.
        /// </summary>
        public List<ISubmodelElement> Values { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            foreach (var anItem in Values)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Values)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public SubmodelElementStruct(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            List<ISubmodelElement>? values = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            Values = (values != null)
                ? values
                : new List<ISubmodelElement>();
        }
    }

    /// <summary>
    /// A data element is a submodel element that is not further composed out of
    /// other submodel elements.
    /// </summary>
    /// <remarks>
    /// <para>A data element is a submodel element that has a value. The type of value differs
    /// for different subtypes of data elements.</para>
    /// <para>Constraint AASd-090: For data elements DataElement/category shall be one of the
    /// following values: CONSTANT, PARAMETER or VARIABLE.
    /// Exception: File and Blob data elements.</para>
    /// </remarks>
    public interface IDataElement :
            ISubmodelElement,
            IClass
    {

    }

    /// <summary>
    /// A property is a data element that has a single value.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-007: If both, the Property/value and the Property/valueId are
    /// present then the value of Property/value needs to be identical to the value of
    /// the referenced coded value in Property/valueId.</para>
    /// <para>Constraint AASd-052a: If the semanticId of a Property references a
    /// ConceptDescription then the ConceptDescription/category shall be one of
    /// following values: VALUE, PROPERTY.</para>
    /// <para>Constraint AASd-065: If the semanticId of a Property or MultiLanguageProperty
    /// references a ConceptDescription with the category VALUE then the value of the
    /// property is identical to DataSpecificationIEC61360/value and the valueId of the
    /// property is identical to DataSpecificationIEC61360/valueId.</para>
    /// <para>Constraint AASd-066: If the semanticId of a Property or MultiLanguageProperty
    /// references a ConceptDescription with the category PROPERTY and
    /// DataSpecificationIEC61360/valueList is defined the value and valueId of the
    /// property is identical to one of the value reference pair types references in the
    /// value list, i.e. ValueReferencePairType/value or ValueReferencePairType/valueId,
    /// resp.</para>
    /// </remarks>
    public class Property :
            IDataElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Data type of the value
        /// </summary>
        public DataTypeDef ValueType { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        /// <remarks>
        /// See Constraint AASd-065
        /// See Constraint AASd-007
        /// </remarks>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique id of a coded value.
        /// </summary>
        /// <remarks>
        /// See Constraint AASd-065
        /// See Constraint AASd-007
        /// </remarks>
        public IReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Property(
            string idShort,
            DataTypeDef valueType,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            string? value = null,
            IReference? valueId = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            ValueType = valueType;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A property is a data element that has a multi-language value.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-052b: If the semanticId of a MultiLanguageProperty references
    /// a ConceptDescription then the ConceptDescription/category shall be one of
    /// following values: PROPERTY.</para>
    /// <para>Constraint AASd-012: If both, the MultiLanguageProperty/value and the
    /// MultiLanguageProperty/valueId are present then for each string in a specific
    /// language the meaning must be the same as specified in
    /// MultiLanguageProperty/valueId.</para>
    /// <para>Constraint AASd-067: If the semanticId of a MultiLanguageProperty references a
    /// ConceptDescription then DataSpecificationIEC61360/dataType shall be
    /// STRING_TRANSLATABLE.</para>
    /// <para>See Constraint AASd-065</para>
    /// <para>See Constraint AASd-066</para>
    /// </remarks>
    public class MultiLanguageProperty :
            IDataElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// See Constraint AASd-012
        /// See Constraint AASd-065
        /// </summary>
        public LangStringSet? Value { get; set; }

        /// <summary>
        /// Reference to the global unique id of a coded value.
        /// See Constraint AASd-012
        /// See Constraint AASd-065
        /// </summary>
        public IReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            if (Value != null)
            {
                yield return Value;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public MultiLanguageProperty(
            string? idShort = null,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            LangStringSet? value = null,
            IReference? valueId = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A range data element is a data element that defines a range with min and max.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-053: If the semanticId of a Range submodel element references a
    /// ConceptDescription then the ConceptDescription/category shall be one of following
    /// values: PROPERTY.</para>
    /// <para>Constraint AASd-068: If the semanticId of a Range submodel element references a
    /// ConceptDescription then DataSpecificationIEC61360/dataType shall be a numerical
    /// one, i.e. REAL_* or RATIONAL_*.</para>
    /// <para>Constraint AASd-069: If the semanticId of a Range references a ConceptDescription
    /// then DataSpecificationIEC61360/levelType shall be identical to the set {Min, Max}.</para>
    /// </remarks>
    public class Range :
            IDataElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Data type of the min und max
        /// </summary>
        public DataTypeDef ValueType { get; set; }

        /// <summary>
        /// The minimum value of the range.
        /// If the min value is missing, then the value is assumed to be negative infinite.
        /// </summary>
        public string? Min { get; set; }

        /// <summary>
        /// The maximum value of the range.
        /// If the max value is missing,  then the value is assumed to be positive infinite.
        /// </summary>
        public string? Max { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Range(
            string idShort,
            DataTypeDef valueType,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            string? min = null,
            string? max = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            ValueType = valueType;
            Min = min;
            Max = max;
        }
    }

    /// <summary>
    /// A reference element is a data element that defines a logical reference to another
    /// element within the same or another AAS or a reference to an external object or
    /// entity.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-054: If the semanticId of a ReferenceElement submodel element
    /// references a ConceptDescription then the ConceptDescription/category shall be one
    /// of following values: REFERENCE.</para>
    /// <para>Constraint AASd-082: If the semanticId of a ReferenceElement references a
    /// ConceptDescription then DataSpecificationIEC61360/dataType shall be one of: STRING,
    /// IRI, IRDI.</para>
    /// </remarks>
    public class ReferenceElement :
            IDataElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Reference to any other referable element of the same of any other AAS or a
        /// reference to an external object or entity.
        /// </summary>
        public IReference? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            if (Value != null)
            {
                yield return Value;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ReferenceElement(
            string idShort,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            IReference? value = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            Value = value;
        }
    }

    /// <summary>
    /// A BLOB is a data element that represents a file that is contained with its source
    /// code in the value attribute.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-057: The semanticId of a File or Blob submodel element shall only
    /// reference a ConceptDescription with the category DOCUMENT.</para>
    /// <para>Constraint AASd-083: If the semanticId of a Blob references a ConceptDescription
    /// then DataSpecificationIEC61360/dataType shall be one of: BLOB, HTML.</para>
    /// </remarks>
    public class Blob :
            IDataElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Mime type of the content of the BLOB.
        /// The mime type states which file extensions the file can have.
        /// Valid values are e.g. “application/json”, “application/xls”, ”image/jpg”
        /// The allowed values are defined as in RFC2046.
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// The value of the BLOB instance of a blob data element.
        /// </summary>
        /// <remarks>
        /// In contrast to the file property the file content is stored directly as value
        /// in the Blob data element.
        /// </remarks>
        public byte[]? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Blob(
            string idShort,
            string mimeType,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            byte[]? value = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            MimeType = mimeType;
            Value = value;
        }
    }

    /// <summary>
    /// A File is a data element that represents an address to a file.
    /// The value is an URI that can represent an absolute or relative path.
    /// </summary>
    /// <remarks>
    /// <para>See Constraint AASd-057</para>
    /// <para>Constraint AASd-079: If the semanticId of a File references a
    /// ConceptDescription then DataSpecificationIEC61360/dataType shall be one of: FILE.</para>
    /// </remarks>
    public class File :
            IDataElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// MIME type of the content of the BLOB.
        /// The MIME type states which file extensions the file can have.
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// Path and name of the referenced file (with file extension).
        /// The path can be absolute or relative.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public File(
            string idShort,
            string mimeType,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            string? value = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            MimeType = mimeType;
            Value = value;
        }
    }

    /// <summary>
    /// An annotated relationship element is a relationship element that can be annotated
    /// with additional data elements.
    /// </summary>
    /// <remarks>
    /// See Constraint AASd-055
    /// </remarks>
    public class AnnotatedRelationshipElement :
            IRelationshipElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }

        /// <summary>
        /// A reference to a data element that represents an annotation that holds for
        /// the relationship between the two elements.
        /// </summary>
        public List<IDataElement> Annotation { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            yield return First;

            yield return Second;

            foreach (var anItem in Annotation)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            yield return First;

            // Recurse
            foreach (var anItem in First.Descend())
            {
                yield return anItem;
            }

            yield return Second;

            // Recurse
            foreach (var anItem in Second.Descend())
            {
                yield return anItem;
            }

            foreach (var anItem in Annotation)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AnnotatedRelationshipElement(
            IReference first,
            IReference second,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            List<IDataElement>? annotation = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            First = first;
            Second = second;
            Annotation = (annotation != null)
                ? annotation
                : new List<IDataElement>();
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an entity is a self-managed entity or a co-managed
    /// entity.
    /// </summary>
    public enum EntityType
    {
        /// <summary>
        /// For co-managed entities there is no separate AAS. Co-managed entities need to be
        /// part of a self-managed entity.
        /// </summary>
        [EnumMember(Value = "COMANAGEDENTITY")]
        CoManagedEntity,

        /// <summary>
        /// Self-Managed Entities have their own AAS but can be part of the bill of material of
        /// a composite self-managed entity. The asset of an I4.0 Component is a self-managed
        /// entity per definition."
        /// </summary>
        [EnumMember(Value = "SELFMANAGEDENTITY")]
        SelfManagedEntity
    }

    /// <summary>
    /// An entity is a submodel element that is used to model entities.
    /// </summary>
    /// <remarks>
    /// Constraint AASd-056: If the semanticId of a Entity submodel element
    /// references a ConceptDescription then the ConceptDescription/category shall
    /// be one of following values: ENTITY. The ConceptDescription describes the elements
    /// assigned to the entity via Entity/statement.
    /// </remarks>
    public class Entity :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Describes whether the entity is a co- managed entity or a self-managed entity.
        /// </summary>
        public EntityType EntityType { get; set; }

        /// <summary>
        /// Describes statements applicable to the entity by a set of submodel elements,
        /// typically with a qualified value.
        /// </summary>
        public List<ISubmodelElement> Statements { get; set; }

        /// <summary>
        /// Reference to the asset the entity is representing.
        /// </summary>
        /// <remarks>
        /// Constraint AASd-014: Either the attribute globalAssetId or specificAssetId of an
        /// Entity must be set if Entity/entityType is set to “SelfManagedEntity”. They are
        /// not existing otherwise.
        /// </remarks>
        public IReference? GlobalAssetId { get; set; }

        /// <summary>
        /// Reference to an identifier key value pair representing a specific identifier
        /// of the asset represented by the asset administration shell.
        /// </summary>
        /// <remarks>
        /// See Constraint AASd-014
        /// </remarks>
        public IdentifierKeyValuePair? SpecificAssetId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            foreach (var anItem in Statements)
            {
                yield return anItem;
            }

            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Statements)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;

                // Recurse
                foreach (var anItem in GlobalAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;

                // Recurse
                foreach (var anItem in SpecificAssetId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Entity(
            EntityType entityType,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            List<ISubmodelElement>? statements = null,
            IReference? globalAssetId = null,
            IdentifierKeyValuePair? specificAssetId = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            Statements = (statements != null)
                ? statements
                : new List<ISubmodelElement>();
            EntityType = entityType;
            GlobalAssetId = globalAssetId;
            SpecificAssetId = specificAssetId;
        }
    }

    /// <summary>
    /// An event.
    /// </summary>
    /// <remarks>
    /// Constraint AASd-061: If the semanticId of a Event submodel element references a
    /// ConceptDescription then the category of the ConceptDescription shall be one of
    /// the following: EVENT.
    /// </remarks>
    public interface IEvent :
            ISubmodelElement,
            IClass
    {

    }

    /// <summary>
    /// A basic event.
    /// </summary>
    public class BasicEvent :
            IEvent,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Reference to a referable, e.g. a data element or a submodel, that is being
        /// observed.
        /// </summary>
        public IReference Observed { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            yield return Observed;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            yield return Observed;

            // Recurse
            foreach (var anItem in Observed.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public BasicEvent(
            IReference observed,
            string idShort,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            Observed = observed;
        }
    }

    /// <summary>
    /// An operation is a submodel element with input and output variables.
    /// </summary>
    /// <remarks>
    /// Constraint AASd-060: If the semanticId of a Operation submodel element
    /// references a ConceptDescription then the category of the ConceptDescription
    /// shall be one of the following values: FUNCTION.
    /// </remarks>
    public class Operation :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Input parameter of the operation.
        /// </summary>
        public List<OperationVariable> InputVariables { get; set; }

        /// <summary>
        /// Output parameter of the operation.
        /// </summary>
        public List<OperationVariable> OutputVariables { get; set; }

        /// <summary>
        /// Parameter that is input and output of the operation.
        /// </summary>
        public List<OperationVariable> InoutputVariables { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }

            foreach (var anItem in InputVariables)
            {
                yield return anItem;
            }

            foreach (var anItem in OutputVariables)
            {
                yield return anItem;
            }

            foreach (var anItem in InoutputVariables)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in InputVariables)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in OutputVariables)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in InoutputVariables)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Operation(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null,
            List<OperationVariable>? inputVariables = null,
            List<OperationVariable>? outputVariables = null,
            List<OperationVariable>? inoutputVariables = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            InputVariables = (inputVariables != null)
                ? inputVariables
                : new List<OperationVariable>();
            OutputVariables = (outputVariables != null)
                ? outputVariables
                : new List<OperationVariable>();
            InoutputVariables = (inoutputVariables != null)
                ? inoutputVariables
                : new List<OperationVariable>();
        }
    }

    /// <summary>
    /// An operation variable is a submodel element that is used as input or output variable
    /// of an operation.
    /// </summary>
    public class OperationVariable : IClass
    {
        /// <summary>
        /// Describes the needed argument for an operation via a submodel element
        /// </summary>
        public ISubmodelElement Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Value;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Value;

            // Recurse
            foreach (var anItem in Value.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public OperationVariable(ISubmodelElement value)
        {
            Value = value;
        }
    }

    /// <summary>
    /// A capability is the implementation-independent description of the potential of an
    /// asset to achieve a certain effect in the physical or virtual world.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-058: If the semanticId of a Capability submodel element references
    /// a ConceptDescription then the ConceptDescription/category shall be CAPABILITY.</para>
    /// <para>The semanticId of a capability is typically an ontology. Thus, reasoning on
    /// capabilities is enabled.</para>
    /// </remarks>
    public class Capability :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        public List<IConstraint> Qualifiers { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Qualifiers)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Capability(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            ModelingKind? kind = null,
            IReference? semanticId = null,
            List<IConstraint>? qualifiers = null,
            List<IReference>? dataSpecifications = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = (qualifiers != null)
                ? qualifiers
                : new List<IConstraint>();
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
        }
    }

    /// <summary>
    /// The semantics of a property or other elements that may have a semantic description
    /// is defined by a concept description. The description of the concept should follow a
    /// standardized schema (realized as data specification template).
    /// </summary>
    /// <remarks>
    /// Constraint AASd-051: A ConceptDescription shall have one of the following categories
    /// VALUE, PROPERTY, REFERENCE, DOCUMENT, CAPABILITY, RELATIONSHIP, COLLECTION, FUNCTION
    /// , EVENT, ENTITY, APPLICATION_CLASS, QUALIFIER, VIEW. Default: PROPERTY.
    /// </remarks>
    public class ConceptDescription :
            IIdentifiable,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// Reference to an external definition the concept is compatible to or was derived from
        /// </summary>
        /// <remarks>
        /// Compare to is-case-of relationship in ISO 13584-32 &amp; IEC EN 61360"
        /// </remarks>
        public List<IReference> IsCaseOf { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            foreach (var anItem in IsCaseOf)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in IsCaseOf)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ConceptDescription(
            string id,
            string idShort,
            List<Extension>? extensions = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            AdministrativeInformation? administration = null,
            List<IReference>? isCaseOf = null,
            List<IReference>? dataSpecifications = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Id = id;
            Administration = administration;
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            IsCaseOf = (isCaseOf != null)
                ? isCaseOf
                : new List<IReference>();
        }
    }

    /// <summary>
    /// A view is a collection of referable elements w.r.t. to a specific viewpoint of one
    /// or more stakeholders.
    /// </summary>
    /// <remarks>
    /// <para>Constraint AASd-064: If the semanticId of a View references a ConceptDescription
    /// then the category of the ConceptDescription shall be VIEW.</para>
    /// <para>Views are a projection of submodel elements for a given perspective.
    /// They are not equivalent to submodels.</para>
    /// </remarks>
    public class View :
            IReferable,
            IHasSemantics,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<IReference> DataSpecifications { get; set; }

        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension> Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-002: idShort of Referables shall only feature letters, digits,
        /// underscore ("_"); starting mandatory with a letter. I.e. <c>[a-zA-Z][a-zA-Z0-9_]+</c>
        /// Exception: In case of direct submodel elements within a SubmodelElementList the
        /// idShort shall feature a sequence of digits representing an integer. I.e. <c>[0]</c> or
        /// <c>[1-9][0-9]+</c>.</para>
        /// <para>Constraint AASd-117: For all Referables which are not Identifiables the idShort is
        /// mandatory.</para>
        /// <para>Constraint AASd-003: idShort shall be matched case-sensitive.</para>
        /// <para>Constraint AASd-022: idShort of non-identifiable referables shall be unique in its
        /// namespace.</para>
        /// <para>Constraint AASd-027: idShort of Referables shall have a maximum length of 128
        /// characters.</para>
        /// <para>In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the idShort is typically
        /// identical to the short name in English.</para>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// <para>If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:</para>
        /// <para><ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description-the idShort of the element</li>
        /// </ul></para>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages. If no description is defined,
        /// then the definition of the concept description that defines the semantics
        /// of the element is used. Additional information can be provided,
        /// <em>e.g.</em>, if the element is qualified and which qualifier types can be expected
        /// in which context or which additional data specification templates are provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Reference to a referable element that is contained in the view.
        /// </summary>
        public List<IReference> ContainedElements { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            foreach (var anItem in ContainedElements)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in DataSpecifications)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Extensions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in ContainedElements)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public View(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            IReference? semanticId = null,
            List<IReference>? dataSpecifications = null,
            List<IReference>? containedElements = null)
        {
            Extensions = (extensions != null)
                ? extensions
                : new List<Extension>();
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            DataSpecifications = (dataSpecifications != null)
                ? dataSpecifications
                : new List<IReference>();
            ContainedElements = (containedElements != null)
                ? containedElements
                : new List<IReference>();
        }
    }

    /// <summary>
    /// Reference to either a model element of the same or another AAs or to an external
    /// entity.
    /// </summary>
    public interface IReference : IClass
    {

    }

    /// <summary>
    /// Reference to an external entity.
    /// </summary>
    public class GlobalReference :
            IReference,
            IClass
    {
        /// <summary>
        /// Unique reference. The reference can be a concatenation of different identifiers,
        /// for example to an IRDI path etc.
        /// </summary>
        public List<string> Values { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public GlobalReference(List<string> values)
        {
            Values = values;
        }
    }

    /// <summary>
    /// Reference to a model element of the same or another AAS.
    /// A model reference is an ordered list of keys, each key referencing an element.
    /// The complete list of keys may for example be concatenated to a path that then gives
    /// unique access to an element.
    /// </summary>
    public class ModelReference :
            IReference,
            IClass
    {
        /// <summary>
        /// Unique references in their name space.
        /// </summary>
        public List<Key> Keys { get; set; }

        /// <summary>
        /// SemanticId of the referenced model element.
        /// </summary>
        public IReference? ReferredSemanticId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in Keys)
            {
                yield return anItem;
            }

            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in Keys)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;

                // Recurse
                foreach (var anItem in ReferredSemanticId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ModelReference(
            List<Key> keys,
            IReference? referredSemanticId = null)
        {
            Keys = keys;
            ReferredSemanticId = referredSemanticId;
        }
    }

    /// <summary>
    /// A key is a reference to an element by its id.
    /// </summary>
    public class Key : IClass
    {
        public KeyElements Type { get; set; }

        public string Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Key(
            KeyElements type,
            string value)
        {
            Type = type;
            Value = value;
        }
    }

    /// <summary>
    /// Enumeration of all identifiable elements within an asset administration shell.
    /// </summary>
    public enum IdentifiableElements
    {
        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        [EnumMember(Value = "Submodel")]
        Submodel
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell
    /// </summary>
    public enum ReferableElements
    {
        [EnumMember(Value = "AccessPermissionRule")]
        AccessPermissionRule,

        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "Asset")]
        Asset,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEvent")]
        BasicEvent,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="ReferableElements.DataElement" />
        /// the reference may be a Property, a File <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// Event is abstract.
        /// </remarks>
        [EnumMember(Value = "Event")]
        Event,

        [EnumMember(Value = "File")]
        File,

        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        [EnumMember(Value = "Range")]
        Range,

        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="ReferableElements.SubmodelElement" />
        /// the reference may be a Property, a SubmodelElementCollection,
        /// an Operation <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementStruct")]
        SubmodelElementStruct
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum KeyElements
    {
        /// <summary>
        /// unique reference to an element within a file.
        /// </summary>
        /// <remarks>
        /// The file itself is assumed to be part of an asset administration shell.
        /// </remarks>
        [EnumMember(Value = "FragmentReference")]
        FragmentReference,

        [EnumMember(Value = "AccessPermissionRule")]
        AccessPermissionRule,

        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "Asset")]
        Asset,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEvent")]
        BasicEvent,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="KeyElements.DataElement" />
        /// the reference may be a Property, a File <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// Event is abstract.
        /// </remarks>
        [EnumMember(Value = "Event")]
        Event,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        [EnumMember(Value = "GlobalReference")]
        GlobalReference,

        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="KeyElements.SubmodelElement" />
        /// the reference may be a Property, a SubmodelElementCollection`,
        /// an Operation <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementStruct")]
        SubmodelElementStruct
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell.
    /// </summary>
    public enum SubmodelElements
    {
        /// <summary>
        /// Annotated relationship element
        /// </summary>
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        /// <summary>
        /// Asset
        /// </summary>
        [EnumMember(Value = "Asset")]
        Asset,

        /// <summary>
        /// Asset Administration Shell
        /// </summary>
        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        /// <summary>
        /// Basic Event
        /// </summary>
        [EnumMember(Value = "BasicEvent")]
        BasicEvent,

        /// <summary>
        /// Blob
        /// </summary>
        [EnumMember(Value = "Blob")]
        Blob,

        /// <summary>
        /// Capability
        /// </summary>
        [EnumMember(Value = "Capability")]
        Capability,

        /// <summary>
        /// Concept Description
        /// </summary>
        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data Element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses “DataElement” the reference may
        /// be a Property, a File etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        /// <summary>
        /// Entity
        /// </summary>
        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event
        /// </summary>
        /// <remarks>
        /// Event is abstract
        /// </remarks>
        [EnumMember(Value = "Event")]
        Event,

        /// <summary>
        /// File
        /// </summary>
        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        /// <summary>
        /// Operation
        /// </summary>
        [EnumMember(Value = "Operation")]
        Operation,

        /// <summary>
        /// Property
        /// </summary>
        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        /// <summary>
        /// Submodel
        /// </summary>
        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, i.e. if a key uses “SubmodelElement”
        /// the reference may be a Property, a SubmodelElementList,
        /// an Operation etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementStruct")]
        SubmodelElementStruct
    }

    public enum BuildInListTypes
    {
        [EnumMember(Value = "ENTITIES")]
        Entities,

        [EnumMember(Value = "IDREFS")]
        IdRefs,

        [EnumMember(Value = "NMTOKENS")]
        NMTokens
    }

    public enum DecimalBuildInTypes
    {
        [EnumMember(Value = "integer")]
        Integer,

        [EnumMember(Value = "long")]
        Long,

        [EnumMember(Value = "int")]
        Int,

        [EnumMember(Value = "short")]
        Short,

        [EnumMember(Value = "byte")]
        Byte,

        [EnumMember(Value = "NonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "unsignedInteger")]
        UnsignedInteger,

        [EnumMember(Value = "unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "unsignedShort")]
        UnsignedShort,

        [EnumMember(Value = "unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "negativeInteger")]
        NegativeInteger
    }

    public enum DurationBuildInTypes
    {
        [EnumMember(Value = "dayTimeDuration")]
        DayTimeDuration,

        [EnumMember(Value = "yearMonthDuration")]
        YearMonthDuration
    }

    public enum PrimitiveTypes
    {
        [EnumMember(Value = "anyURI")]
        AnyUri,

        [EnumMember(Value = "base64Binary")]
        Base64Binary,

        [EnumMember(Value = "boolean")]
        Boolean,

        [EnumMember(Value = "date")]
        Date,

        [EnumMember(Value = "dateTime")]
        DateTime,

        [EnumMember(Value = "decimal")]
        Decimal,

        [EnumMember(Value = "double")]
        Double,

        [EnumMember(Value = "duration")]
        Duration,

        [EnumMember(Value = "float")]
        Float,

        [EnumMember(Value = "gDay")]
        GDay,

        [EnumMember(Value = "gMonth")]
        GMonth,

        [EnumMember(Value = "gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "heyBinary")]
        HeyBinary,

        [EnumMember(Value = "NOTATION")]
        Notation,

        [EnumMember(Value = "QName")]
        QName,

        [EnumMember(Value = "string")]
        String,

        [EnumMember(Value = "time")]
        Time
    }

    public enum StringBuildInTypes
    {
        [EnumMember(Value = "normalizedString")]
        NormalizedString,

        [EnumMember(Value = "token")]
        Token,

        [EnumMember(Value = "Language")]
        Language,

        [EnumMember(Value = "NCName")]
        NCName,

        [EnumMember(Value = "ENTITY")]
        Entity,

        [EnumMember(Value = "ID")]
        Id,

        [EnumMember(Value = "IDREF")]
        Idref
    }

    /// <summary>
    /// Enumeration listing all xsd anySimpleTypes
    /// </summary>
    public enum DataTypeDef
    {
        [EnumMember(Value = "ENTITIES")]
        Entities,

        [EnumMember(Value = "IDREFS")]
        IdRefs,

        [EnumMember(Value = "NMTOKENS")]
        NMTokens,

        [EnumMember(Value = "integer")]
        Integer,

        [EnumMember(Value = "long")]
        Long,

        [EnumMember(Value = "int")]
        Int,

        [EnumMember(Value = "short")]
        Short,

        [EnumMember(Value = "byte")]
        Byte,

        [EnumMember(Value = "NonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "unsignedInteger")]
        UnsignedInteger,

        [EnumMember(Value = "unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "unsignedShort")]
        UnsignedShort,

        [EnumMember(Value = "unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "negativeInteger")]
        NegativeInteger,

        [EnumMember(Value = "dayTimeDuration")]
        DayTimeDuration,

        [EnumMember(Value = "yearMonthDuration")]
        YearMonthDuration,

        [EnumMember(Value = "anyURI")]
        AnyUri,

        [EnumMember(Value = "base64Binary")]
        Base64Binary,

        [EnumMember(Value = "boolean")]
        Boolean,

        [EnumMember(Value = "date")]
        Date,

        [EnumMember(Value = "dateTime")]
        DateTime,

        [EnumMember(Value = "decimal")]
        Decimal,

        [EnumMember(Value = "double")]
        Double,

        [EnumMember(Value = "duration")]
        Duration,

        [EnumMember(Value = "float")]
        Float,

        [EnumMember(Value = "gDay")]
        GDay,

        [EnumMember(Value = "gMonth")]
        GMonth,

        [EnumMember(Value = "gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "heyBinary")]
        HeyBinary,

        [EnumMember(Value = "NOTATION")]
        Notation,

        [EnumMember(Value = "QName")]
        QName,

        [EnumMember(Value = "string")]
        String,

        [EnumMember(Value = "time")]
        Time,

        [EnumMember(Value = "normalizedString")]
        NormalizedString,

        [EnumMember(Value = "token")]
        Token,

        [EnumMember(Value = "Language")]
        Language,

        [EnumMember(Value = "NCName")]
        NCName,

        [EnumMember(Value = "ENTITY")]
        Entity,

        [EnumMember(Value = "ID")]
        Id,

        [EnumMember(Value = "IDREF")]
        Idref
    }

    public class LangStringSet : IClass {
        public IEnumerable<IClass> DescendOnce()
        {
            throw new System.NotImplementedException("TODO");
        }

        public IEnumerable<IClass> Descend()
        {
            throw new System.NotImplementedException("TODO");
        }

        public void Accept(Visitation.IVisitor visitor)
        {
            throw new System.NotImplementedException("TODO");
        }

        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            throw new System.NotImplementedException("TODO");
        }

        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            throw new System.NotImplementedException("TODO");
        }

        public T Transform<C, T>(Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            throw new System.NotImplementedException("TODO");
        }
    }

    /// <summary>
    /// Missing summary.
    /// </summary>
    /// <remarks>
    /// The Data Specification Templates do not belong to the meta-model of the Asset
    /// Administration Shell. In serializations that choose specific templates
    /// the corresponding data specification content may be directly incorporated.
    /// </remarks>
    public interface IDataSpecificationContent : IClass
    {

    }

    public enum DataTypeIec61360
    {
        /// <summary>
        /// values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
        /// Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
        /// 31 May 1999.
        /// </summary>
        [EnumMember(Value = "DATE")]
        Date,

        /// <summary>
        /// values consisting of sequence of characters but cannot be translated into other
        /// languages
        /// </summary>
        [EnumMember(Value = "STRING")]
        String,

        /// <summary>
        /// values containing string but shall be represented as different string in different
        /// languages
        /// </summary>
        [EnumMember(Value = "STRING_TRANSLATABLE")]
        StringTranslatable,

        /// <summary>
        /// values containing values that are measure of type INTEGER. In addition such a value
        /// comes with a physical unit.
        /// </summary>
        [EnumMember(Value = "INTEGER_MEASURE")]
        IntegerMeasure,

        /// <summary>
        /// values containing values of type INTEGER but are no currencies or measures
        /// </summary>
        [EnumMember(Value = "INTEGER_COUNT")]
        IntegerCount,

        /// <summary>
        /// values containing values of type INTEGER that are currencies
        /// </summary>
        [EnumMember(Value = "INTEGER_CURRENCY")]
        IntegerCurrency,

        /// <summary>
        /// values containing values that are measures of type REAL. In addition such a value
        /// comes with a physical unit.
        /// </summary>
        [EnumMember(Value = "REAL_MEASURE")]
        RealMeasure,

        /// <summary>
        /// values containing numbers that can be written as a terminating or non-terminating
        /// decimal; a rational or irrational number but are no currencies or measures
        /// </summary>
        [EnumMember(Value = "REAL_COUNT")]
        RealCount,

        /// <summary>
        /// values containing values of type REAL that are currencies
        /// </summary>
        [EnumMember(Value = "REAL_CURRENCY")]
        RealCurrency,

        /// <summary>
        /// values representing truth of logic or Boolean algebra (TRUE, FALSE)
        /// </summary>
        [EnumMember(Value = "BOOLEAN")]
        Boolean,

        /// <summary>
        /// values containing values of type STRING conformant to Rfc 3987
        /// </summary>
        /// <remarks>
        /// In IEC61360-1 (2017) only URI is supported. An Iri type allows in particular to
        /// express a URL or an URI
        /// </remarks>
        [EnumMember(Value = "IRI")]
        Iri,

        /// <summary>
        /// values conforming to ISO/IEC 11179 series global identifier sequences IRDI can be
        /// used instead of the more specific data types ICID or ISO29002_IRDI. ICID values are
        /// value conformant to an IRDI, where the delimiter between RAI and ID is “#” while the
        /// delimiter between DI and VI is confined to “##” ISO29002_IRDI values are values
        /// containing a global identifier that identifies an administrated item in a registry.
        /// The structure of this identifier complies with identifier syntax defined in ISO/TS
        /// 29002-5. The identifier shall fulfill the requirements specified in ISO/TS 29002-5
        /// for an "international registration data identifier" (IRDI).
        /// </summary>
        [EnumMember(Value = "IRDI")]
        Irdi,

        /// <summary>
        /// values containing values of type rational
        /// </summary>
        [EnumMember(Value = "RATIONAL")]
        Rational,

        /// <summary>
        /// values containing values of type rational.
        /// In addition such a value comes with a physical unit.
        /// </summary>
        [EnumMember(Value = "RATIONAL_MEASURE")]
        RationalMeasure,

        /// <summary>
        /// values containing a time, conformant to ISO 8601:2004 but restricted to
        /// what is allowed in the corresponding type in xml.
        /// Format hh:mm (ECLASS) Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME]
        /// representation of: 1.20 p.m. for Eastern Standard Time,
        /// which is 5 hours behind Coordinated Universal Time (UTC).
        /// </summary>
        [EnumMember(Value = "TIME")]
        Time,

        /// <summary>
        /// values containing a time, conformant to ISO 8601:2004 but restricted to
        /// what is allowed in the corresponding type in xml. Format yyyy-mm-dd hh:mm (ECLASS)
        /// </summary>
        [EnumMember(Value = "TIMESTAMP")]
        Timestamp,

        /// <summary>
        /// values containing an address to a file. The values are of type URI and can represent
        /// an absolute or relative path. IEC61360 does not support the file type.
        /// </summary>
        [EnumMember(Value = "FILE")]
        File,

        /// <summary>
        /// Values containing string with any sequence of characters, using the syntax of HTML5
        /// (see W3C Recommendation 28:2014)
        /// </summary>
        [EnumMember(Value = "HTML")]
        Html,

        /// <summary>
        /// values containing the content of a file. Values may be binaries.
        /// HTML conformant to HTML5 is a special blob. In IEC61360 binary is for a sequence of
        /// bits, each bit being represented by “0” and “1” only. A binary is a blob but a blob
        /// may also contain other source code.
        /// </summary>
        [EnumMember(Value = "BLOB")]
        Blob
    }

    public enum LevelType
    {
        [EnumMember(Value = "Min")]
        Min,

        [EnumMember(Value = "Max")]
        Max,

        [EnumMember(Value = "Nom")]
        Nom,

        [EnumMember(Value = "Type")]
        Type
    }

    /// <summary>
    /// A value reference pair within a value list. Each value has a global unique id
    /// defining its semantic.
    /// </summary>
    public class ValueReferencePair : IClass
    {
        /// <summary>
        /// The value of the referenced concept definition of the value in valueId.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Global unique id of the value.
        /// </summary>
        /// <remarks>
        /// Constraint AASd-078: If the valueId of a ValueReferencePair references a
        /// ConceptDescription then the ConceptDescription/category shall be one of following
        /// values: VALUE.
        /// </remarks>
        public IReference ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return ValueId;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return ValueId;

            // Recurse
            foreach (var anItem in ValueId.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ValueReferencePair(
            string value,
            IReference valueId)
        {
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A set of value reference pairs.
    /// </summary>
    public class ValueList : IClass
    {
        /// <summary>
        /// A pair of a value together with its global unique id.
        /// </summary>
        public List<ValueReferencePair> ValueReferencePairs { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in ValueReferencePairs)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in ValueReferencePairs)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ValueList(List<ValueReferencePair>? valueReferencePairs = null)
        {
            ValueReferencePairs = (valueReferencePairs != null)
                ? valueReferencePairs
                : new List<ValueReferencePair>();
        }
    }

    /// <summary>
    /// Content of data specification template for concept descriptions conformant to
    /// IEC 61360.
    /// </summary>
    public class DataSpecificationIec61360 :
            IDataSpecificationContent,
            IClass
    {
        /// <summary>
        /// Preferred name
        /// Constraint AASd-076: For all ConceptDescriptions using data specification template
        /// IEC61360
        /// (http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0)
        /// at least a preferred name in English shall be defined.
        /// </summary>
        public LangStringSet? PreferredName { get; set; }

        /// <summary>
        /// Short name
        /// </summary>
        public LangStringSet? ShortName { get; set; }

        /// <summary>
        /// Unit
        /// </summary>
        public string? Unit { get; set; }

        /// <summary>
        /// Unique unit id
        /// </summary>
        public IReference? UnitId { get; set; }

        /// <summary>
        /// Source of definition
        /// </summary>
        public string? SourceOfDefinition { get; set; }

        /// <summary>
        /// Symbol
        /// </summary>
        public string? Symbol { get; set; }

        /// <summary>
        /// Data Type
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-070: For a ConceptDescription with category PROPERTY or VALUE using
        /// data specification template IEC61360
        /// (http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0) -
        /// DataSpecificationIEC61360/dataType is mandatory and shall be defined.</para>
        /// <para>Constraint AASd-071: For a ConceptDescription with category REFERENCE using data
        /// specification template IEC61360
        /// (http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0) -
        /// DataSpecificationIEC61360/dataType is STRING by default.</para>
        /// <para>Constraint AASd-072: For a ConceptDescription with category DOCUMENT using data
        /// specification template IEC61360
        /// (http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0) -
        /// DataSpecificationIEC61360/dataType shall be one of the following values: STRING or
        /// URL.</para>
        /// <para>Constraint AASd-073: For a ConceptDescription with category QUALIFIER using data
        /// specification template IEC61360
        /// (http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0) -
        /// DataSpecificationIEC61360/dataType is mandatory and shall be defined.</para>
        /// <para>Constraint AASd-103: If DataSpecificationIEC61360/-dataType one of: INTEGER_MEASURE,
        /// REAL_MEASURE, RATIONAL_MEASURE, INTEGER_CURRENCY, REAL_CURRENCY, then
        /// DataSpecificationIEC61360/unit or DataSpecificationIEC61360/unitId shall be defined.</para>
        /// </remarks>
        public DataTypeIec61360? DataType { get; set; }

        /// <summary>
        /// Definition in different languages
        /// </summary>
        /// <remarks>
        /// Constraint AASd-074: For all ConceptDescriptions except for ConceptDescriptions of
        /// category VALUE using data specification template IEC61360
        /// (http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0) -
        /// DataSpecificationIEC61360/definition is mandatory and shall be defined at least in
        /// English.
        /// </remarks>
        public LangStringSet? Definition { get; set; }

        /// <summary>
        /// Value Format
        /// </summary>
        public string? ValueFormat { get; set; }

        /// <summary>
        /// List of allowed values
        /// </summary>
        /// <remarks>
        /// See Constraint AASd-102
        /// </remarks>
        public ValueList? ValueList { get; set; }

        /// <summary>
        /// Value
        /// </summary>
        /// <remarks>
        /// <para>Constraint AASd-101: If DataSpecificationIEC61360/category equal to VALUE then
        /// DataSpecificationIEC61360/value shall be set.</para>
        /// <para>Constraint AASd-102: If DataSpecificationIEC61360/value or
        /// DataSpecificationIEC61360/valueId is not empty then
        /// DataSpecificationIEC61360/valueList shall be empty and vice versa.</para>
        /// </remarks>
        public string? Value { get; set; }

        /// <summary>
        /// Unique value id
        /// </summary>
        /// <remarks>
        /// See Constraint AASd-102
        /// </remarks>
        public IReference? ValueId { get; set; }

        /// <summary>
        /// Set of levels.
        /// </summary>
        public LevelType? LevelType { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (PreferredName != null)
            {
                yield return PreferredName;
            }

            if (ShortName != null)
            {
                yield return ShortName;
            }

            if (UnitId != null)
            {
                yield return UnitId;
            }

            if (Definition != null)
            {
                yield return Definition;
            }

            if (ValueList != null)
            {
                yield return ValueList;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (PreferredName != null)
            {
                yield return PreferredName;

                // Recurse
                foreach (var anItem in PreferredName.Descend())
                {
                    yield return anItem;
                }
            }

            if (ShortName != null)
            {
                yield return ShortName;

                // Recurse
                foreach (var anItem in ShortName.Descend())
                {
                    yield return anItem;
                }
            }

            if (UnitId != null)
            {
                yield return UnitId;

                // Recurse
                foreach (var anItem in UnitId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Definition != null)
            {
                yield return Definition;

                // Recurse
                foreach (var anItem in Definition.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueList != null)
            {
                yield return ValueList;

                // Recurse
                foreach (var anItem in ValueList.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public DataSpecificationIec61360(
            LangStringSet? preferredName = null,
            LangStringSet? shortName = null,
            string? unit = null,
            IReference? unitId = null,
            string? sourceOfDefinition = null,
            string? symbol = null,
            DataTypeIec61360? dataType = null,
            LangStringSet? definition = null,
            string? valueFormat = null,
            ValueList? valueList = null,
            string? value = null,
            IReference? valueId = null,
            LevelType? levelType = null)
        {
            PreferredName = preferredName;
            ShortName = shortName;
            Unit = unit;
            UnitId = unitId;
            SourceOfDefinition = sourceOfDefinition;
            Symbol = symbol;
            DataType = dataType;
            Definition = definition;
            ValueFormat = valueFormat;
            ValueList = valueList;
            Value = value;
            ValueId = valueId;
            LevelType = levelType;
        }
    }

    /// <summary>
    /// TODO
    /// </summary>
    public class DataSpecificationPhysicalUnit :
            IDataSpecificationContent,
            IClass
    {
        /// <summary>
        /// Unit Name
        /// </summary>
        public string? UnitName { get; set; }

        /// <summary>
        /// Unit Symbol
        /// </summary>
        public string? UnitSymbol { get; set; }

        /// <summary>
        /// Definition
        /// </summary>
        public LangStringSet? Definition { get; set; }

        /// <summary>
        /// SI Notation
        /// </summary>
        public string? SiNotation { get; set; }

        /// <summary>
        /// DIN Notation
        /// </summary>
        public string? DinNotation { get; set; }

        /// <summary>
        /// ECE Name
        /// </summary>
        public string? EceName { get; set; }

        /// <summary>
        /// ECE Code
        /// </summary>
        public string? EceCode { get; set; }

        /// <summary>
        /// NIST Name
        /// </summary>
        public string? NistName { get; set; }

        /// <summary>
        /// Source Of Definition
        /// </summary>
        public string? SourceOfDefinition { get; set; }

        /// <summary>
        /// Conversion Factor
        /// </summary>
        public string? ConversionFactor { get; set; }

        /// <summary>
        /// Registration Authority ID
        /// </summary>
        public string? RegistrationAuthorityId { get; set; }

        /// <summary>
        /// Supplier
        /// </summary>
        public string? Supplier { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Definition != null)
            {
                yield return Definition;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Definition != null)
            {
                yield return Definition;

                // Recurse
                foreach (var anItem in Definition.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public DataSpecificationPhysicalUnit(
            string? unitName = null,
            string? unitSymbol = null,
            LangStringSet? definition = null,
            string? siNotation = null,
            string? dinNotation = null,
            string? eceName = null,
            string? eceCode = null,
            string? nistName = null,
            string? sourceOfDefinition = null,
            string? conversionFactor = null,
            string? registrationAuthorityId = null,
            string? supplier = null)
        {
            UnitName = unitName;
            UnitSymbol = unitSymbol;
            Definition = definition;
            SiNotation = siNotation;
            DinNotation = dinNotation;
            EceName = eceName;
            EceCode = eceCode;
            NistName = nistName;
            SourceOfDefinition = sourceOfDefinition;
            ConversionFactor = conversionFactor;
            RegistrationAuthorityId = registrationAuthorityId;
            Supplier = supplier;
        }
    }

    /// <summary>
    /// Model the environment as the entry point for referencing and serialization.
    /// </summary>
    public class Environment : IClass
    {
        public List<AssetAdministrationShell> AssetAdministrationShells { get; set; }

        public List<Submodel> Submodels { get; set; }

        public List<ConceptDescription> ConceptDescriptions { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in AssetAdministrationShells)
            {
                yield return anItem;
            }

            foreach (var anItem in Submodels)
            {
                yield return anItem;
            }

            foreach (var anItem in ConceptDescriptions)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in AssetAdministrationShells)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in Submodels)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            foreach (var anItem in ConceptDescriptions)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Environment(
            List<AssetAdministrationShell>? assetAdministrationShells = null,
            List<Submodel>? submodels = null,
            List<ConceptDescription>? conceptDescriptions = null)
        {
            AssetAdministrationShells = (assetAdministrationShells != null)
                ? assetAdministrationShells
                : new List<AssetAdministrationShell>();
            Submodels = (submodels != null)
                ? submodels
                : new List<Submodel>();
            ConceptDescriptions = (conceptDescriptions != null)
                ? conceptDescriptions
                : new List<ConceptDescription>();
        }
    }

}  // namespace AasCore.Aas3

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
