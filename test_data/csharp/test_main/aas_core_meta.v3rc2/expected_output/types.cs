/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

using EnumMemberAttribute = System.Runtime.Serialization.EnumMemberAttribute;
using System.Collections.Generic;  // can't alias

namespace AasCore.Aas3
{

    /// <summary>
    /// Represent a general class of an AAS model.
    /// </summary>
    public interface IClass
    {
        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce();

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend();

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor);

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context);
    }

    /// <summary>
    /// Resource represents an address to a file (a locator). The value is an URI that
    /// can represent an absolute or relative path
    /// </summary>
    public class Resource : IClass
    {
        /// <summary>
        /// Path and name of the resource (with file extension).
        /// The path can be absolute or relative.
        /// </summary>
        public AssetKind Path { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// The content type states which file extensions the file can have.
        /// </summary>
        public string? ContentType { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Resource(
            AssetKind path,
            string? contentType = null)
        {
            Path = path;
            ContentType = contentType;
        }
    }

    /// <summary>
    /// Element that can have a semantic definition.
    /// </summary>
    public interface IHasSemantics : IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }
    }

    /// <summary>
    /// Single extension of an element.
    /// </summary>
    public class Extension :
            IHasSemantics,
            IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Name of the extension.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-077:
        ///     The name of an extension within <see cref="IHasExtensions" /> needs to be unique.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string Name { get; set; }

        /// <summary>
        /// Type of the value of the extension.
        /// </summary>
        /// <remarks>
        /// Default: xsd:string
        /// </remarks>
        public DataTypeDefXsd? ValueType { get; set; }

        /// <summary>
        /// Value of the extension
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to an element the extension refers to.
        /// </summary>
        public ModelReference? RefersTo { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (RefersTo != null)
            {
                yield return RefersTo;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (RefersTo != null)
            {
                yield return RefersTo;

                // Recurse
                foreach (var anItem in RefersTo.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Extension(
            string name,
            GlobalReference? semanticId = null,
            DataTypeDefXsd? valueType = null,
            string? value = null,
            ModelReference? refersTo = null)
        {
            SemanticId = semanticId;
            Name = name;
            ValueType = valueType;
            Value = value;
            RefersTo = refersTo;
        }
    }

    /// <summary>
    /// Element that can be extended by proprietary extensions.
    /// </summary>
    /// <remarks>
    /// Note: Extensions are proprietary, i.e. they do not support global interoperability.
    /// </remarks>
    public interface IHasExtensions : IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }
    }

    /// <summary>
    /// An element that is referable by its <see cref="IReferable.IdShort" />.
    /// </summary>
    /// <remarks>
    /// This identifier is not globally unique.
    /// This identifier is unique within the name space of the element.
    /// </remarks>
    public interface IReferable :
            IHasExtensions,
            IClass
    {
        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }
    }

    /// <summary>
    /// An element that has a globally unique identifier.
    /// </summary>
    public interface IIdentifiable :
            IReferable,
            IClass
    {
        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }
    }

    /// <summary>
    /// Enumeration for denoting whether an element is a template or an instance.
    /// </summary>
    public enum ModelingKind
    {
        /// <summary>
        /// Software element which specifies the common attributes shared by all instances of
        /// the template.
        /// </summary>
        /// <remarks>
        /// [SOURCE: IEC TR 62390:2005-01, 3.1.25] modified
        /// </remarks>
        [EnumMember(Value = "TEMPLATE")]
        Template,

        /// <summary>
        /// Concrete, clearly identifiable component of a certain template.
        /// </summary>
        /// <remarks>
        /// It becomes an individual entity of a  template,  for example a
        /// device model, by defining specific property values.
        ///
        /// In an object oriented view,  an instance denotes an object of a
        /// template (class).
        ///
        /// [SOURCE: IEC 62890:2016, 3.1.16 65/617/CDV]  modified
        /// </remarks>
        [EnumMember(Value = "INSTANCE")]
        Instance
    }

    /// <summary>
    /// An element with a kind is an element that can either represent a template or an
    /// instance.
    /// </summary>
    /// <remarks>
    /// Default for an element is that it is representing an instance.
    /// </remarks>
    public interface IHasKind : IClass
    {
        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }
    }

    /// <summary>
    /// Element that can be extended by using data specification templates.
    /// </summary>
    /// <remarks>
    /// A data specification template defines a named set of additional attributes an
    /// element may or shall have. The data specifications used are explicitly specified
    /// with their global ID.
    /// </remarks>
    public interface IHasDataSpecification : IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }
    }

    /// <summary>
    /// Administrative meta-information for an element like version
    /// information.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-005:
    ///     If <see cref="AdministrativeInformation.Version" /> is not specified than also <see cref="AdministrativeInformation.Revision" /> shall be
    ///     unspecified. This means, a revision requires a version. If there is no version
    ///     there is no revision neither. Revision is optional.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class AdministrativeInformation :
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Version of the element.
        /// </summary>
        public string? Version { get; set; }

        /// <summary>
        /// Revision of the element.
        /// </summary>
        public string? Revision { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AdministrativeInformation(
            List<GlobalReference>? dataSpecifications = null,
            string? version = null,
            string? revision = null)
        {
            DataSpecifications = dataSpecifications;
            Version = version;
            Revision = revision;
        }
    }

    /// <summary>
    /// The value of a qualifiable element may be further qualified by one or more
    /// qualifiers or complex formulas.
    /// </summary>
    public interface IQualifiable : IClass
    {
        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }
    }

    /// <summary>
    /// A qualifier is a type-value-pair that makes additional statements w.r.t.  the value
    /// of the element.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-006:
    ///     If both the <see cref="Qualifier.Value" /> and the <see cref="Qualifier.ValueId" /> of
    ///     a <see cref="Qualifier" /> are present then the <see cref="Qualifier.Value" /> needs
    ///     to be identical to the value of the referenced coded value
    ///     in <see cref="Qualifier.ValueId" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-020:
    ///     The value of <see cref="Qualifier.Value" /> shall be consistent to the data type as
    ///     defined in <see cref="Qualifier.ValueType" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Qualifier :
            IHasSemantics,
            IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// The qualifier type describes the type of the qualifier that is applied to
        /// the element.
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Data type of the qualifier value.
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The qualifier value is the value of the qualifier.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        public GlobalReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Qualifier(
            string type,
            DataTypeDefXsd valueType,
            GlobalReference? semanticId = null,
            string? value = null,
            GlobalReference? valueId = null)
        {
            SemanticId = semanticId;
            Type = type;
            ValueType = valueType;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// An asset administration shell.
    /// </summary>
    public class AssetAdministrationShell :
            IIdentifiable,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Meta-information about the asset the AAS is representing.
        /// </summary>
        public AssetInformation AssetInformation { get; set; }

        /// <summary>
        /// References to submodels of the AAS.
        /// </summary>
        /// <remarks>
        /// A submodel is a description of an aspect of the asset the AAS is representing.
        /// The asset of an AAS is typically described by one or more submodels.
        /// Temporarily no submodel might be assigned to the AAS.
        /// </remarks>
        public List<ModelReference>? Submodels { get; set; }

        /// <summary>
        /// The reference to the AAS the AAS was derived from.
        /// </summary>
        public ModelReference? DerivedFrom { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return AssetInformation;

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return AssetInformation;

            // Recurse
            foreach (var anItem in AssetInformation.Descend())
            {
                yield return anItem;
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;

                // Recurse
                foreach (var anItem in DerivedFrom.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AssetAdministrationShell(
            string id,
            AssetInformation assetInformation,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            AdministrativeInformation? administration = null,
            List<GlobalReference>? dataSpecifications = null,
            List<ModelReference>? submodels = null,
            ModelReference? derivedFrom = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Id = id;
            Administration = administration;
            DataSpecifications = dataSpecifications;
            DerivedFrom = derivedFrom;
            AssetInformation = assetInformation;
            Submodels = submodels;
        }
    }

    /// <summary>
    /// In <see cref="AssetInformation" /> identifying meta data of the asset that is
    /// represented by an AAS is defined.
    /// </summary>
    /// <remarks>
    /// The asset may either represent an asset type or an asset instance.
    /// The asset has a globally unique identifier plus – if needed – additional domain
    /// specific (proprietary) identifiers. However, to support the corner case of very
    /// first phase of lifecycle where a stabilised/constant global asset identifier does
    /// not already exist, the corresponding attribute
    /// <see cref="AssetInformation.GlobalAssetId" /> is optional.
    /// </remarks>
    public class AssetInformation : IClass
    {
        /// <summary>
        /// Denotes whether the Asset is of kind "Type" or "Instance".
        /// </summary>
        public AssetKind AssetKind { get; set; }

        /// <summary>
        /// Reference to either an Asset object or a global reference to the asset the AAS is
        /// representing.
        /// </summary>
        /// <remarks>
        /// This attribute is required as soon as the AAS is exchanged via partners in the life
        /// cycle of the asset. In a first phase of the life cycle the asset might not yet have
        /// a global ID but already an internal identifier. The internal identifier would be
        /// modelled via <see cref="AssetInformation.SpecificAssetId" />.
        /// </remarks>
        public GlobalReference? GlobalAssetId { get; set; }

        /// <summary>
        /// Additional domain-specific, typically proprietary, Identifier for the asset.
        /// </summary>
        /// <remarks>
        /// For example, serial number.
        /// </remarks>
        public IdentifierKeyValuePair? SpecificAssetId { get; set; }

        /// <summary>
        /// Thumbnail of the asset represented by the asset administration shell.
        /// </summary>
        /// <remarks>
        /// Used as default.
        /// </remarks>
        public Resource? DefaultThumbnail { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;

                // Recurse
                foreach (var anItem in GlobalAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;

                // Recurse
                foreach (var anItem in SpecificAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;

                // Recurse
                foreach (var anItem in DefaultThumbnail.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AssetInformation(
            AssetKind assetKind,
            GlobalReference? globalAssetId = null,
            IdentifierKeyValuePair? specificAssetId = null,
            Resource? defaultThumbnail = null)
        {
            AssetKind = assetKind;
            GlobalAssetId = globalAssetId;
            SpecificAssetId = specificAssetId;
            DefaultThumbnail = defaultThumbnail;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an element is a type or an instance.
    /// </summary>
    public enum AssetKind
    {
        /// <summary>
        /// hardware or software element which specifies the common attributes shared by all
        /// instances of the type
        /// </summary>
        /// <remarks>
        /// [SOURCE: IEC TR 62390:2005-01, 3.1.25]
        /// </remarks>
        [EnumMember(Value = "Type")]
        Type,

        /// <summary>
        /// concrete, clearly identifiable component of a certain type
        /// </summary>
        /// <remarks>
        /// It becomes an individual entity of a type, for example a device, by defining
        /// specific property values.
        ///
        /// In an object oriented view, an instance denotes an object of a class
        /// (of a type).
        ///
        /// [SOURCE: IEC 62890:2016, 3.1.16] 65/617/CDV
        /// </remarks>
        [EnumMember(Value = "Instance")]
        Instance
    }

    /// <summary>
    /// An <see cref="IdentifierKeyValuePair" /> describes a generic identifier as
    /// key-value pair.
    /// </summary>
    public class IdentifierKeyValuePair :
            IHasSemantics,
            IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Key of the identifier
        /// </summary>
        public string Key { get; set; }

        /// <summary>
        /// The value of the identifier with the corresponding key.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// The (external) subject the key belongs to or has meaning to.
        /// </summary>
        public GlobalReference? ExternalSubjectId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (ExternalSubjectId != null)
            {
                yield return ExternalSubjectId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (ExternalSubjectId != null)
            {
                yield return ExternalSubjectId;

                // Recurse
                foreach (var anItem in ExternalSubjectId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public IdentifierKeyValuePair(
            string key,
            string value,
            GlobalReference? semanticId = null,
            GlobalReference? externalSubjectId = null)
        {
            SemanticId = semanticId;
            Key = key;
            Value = value;
            ExternalSubjectId = externalSubjectId;
        }
    }

    /// <summary>
    /// A submodel defines a specific aspect of the asset represented by the AAS.
    /// </summary>
    /// <remarks>
    /// A submodel is used to structure the digital representation and technical
    /// functionality of an Administration Shell into distinguishable parts. Each submodel
    /// refers to a well-defined domain or subject matter. Submodels can become
    /// standardized and, thus, become submodels templates.
    /// </remarks>
    public class Submodel :
            IIdentifiable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// A submodel consists of zero or more submodel elements.
        /// </summary>
        public List<ISubmodelElement>? SubmodelElements { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (SubmodelElements != null)
            {
                foreach (var anItem in SubmodelElements)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SubmodelElements != null)
            {
                foreach (var anItem in SubmodelElements)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Submodel(
            string id,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            AdministrativeInformation? administration = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            List<ISubmodelElement>? submodelElements = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Id = id;
            Administration = administration;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            SubmodelElements = submodelElements;
        }
    }

    /// <summary>
    /// A submodel element is an element suitable for the description and differentiation of
    /// assets.
    /// </summary>
    /// <remarks>
    /// It is recommended to add a semantic ID to a submodel element.
    /// </remarks>
    public interface ISubmodelElement :
            IReferable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification,
            IClass
    {

    }

    /// <summary>
    /// A relationship element is used to define a relationship between two elements
    /// being either referable (model reference) or external (global reference).
    /// </summary>
    public interface IRelationshipElement :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }
    }

    /// <summary>
    /// A submodel element list is an ordered collection of submodel elements.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-107:
    ///     If a first level child element in a <see cref="SubmodelElementList" /> has
    ///     a <see cref="ISubmodelElement.SemanticId" /> it
    ///     shall be identical to <see cref="SubmodelElementList.SemanticIdListElement" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-114:
    ///     If two first level child elements in a <see cref="SubmodelElementList" /> have
    ///     a <see cref="ISubmodelElement.SemanticId" /> then they shall be identical.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-115:
    ///     If a first level child element in a <see cref="SubmodelElementList" /> does not
    ///     specify a <see cref="ISubmodelElement.SemanticId" /> then the value is assumed to be
    ///     identical to <see cref="SubmodelElementList.SemanticIdListElement" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-108:
    ///     All first level child elements in a <see cref="SubmodelElementList" /> shall have
    ///     the same submodel element type as specified in <see cref="SubmodelElementList.TypeValueListElement" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-109:
    ///     If <see cref="SubmodelElementList.TypeValueListElement" /> is equal to
    ///     <see cref="SubmodelElementElements.Property" /> or
    ///     <see cref="SubmodelElementElements.Range" />
    ///     <see cref="SubmodelElementList.ValueTypeListElement" /> shall be set and all first
    ///     level child elements in the <see cref="SubmodelElementList" /> shall have
    ///     the value type as specified in <see cref="SubmodelElementList.ValueTypeListElement" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class SubmodelElementList :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// The submodel element type of the submodel elements contained in the list.
        /// </summary>
        public SubmodelElementElements TypeValueListElement { get; set; }

        /// <summary>
        /// Defines whether order in list is relevant. If <see cref="SubmodelElementList.OrderRelevant" /> = <c>False</c>
        /// then the list is representing a set or a bag.
        /// </summary>
        /// <remarks>
        /// Default: <c>True</c>
        /// </remarks>
        public bool? OrderRelevant { get; set; }

        /// <summary>
        /// Submodel element contained in the list.
        /// The list is ordered.
        /// </summary>
        public List<ISubmodelElement>? Value { get; set; }

        /// <summary>
        /// The submodel element type of the submodel elements contained in the list.
        /// </summary>
        public GlobalReference? SemanticIdListElement { get; set; }

        /// <summary>
        /// The value type of the submodel element contained in the list.
        /// </summary>
        public DataTypeDefXsd? ValueTypeListElement { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }

            if (SemanticIdListElement != null)
            {
                yield return SemanticIdListElement;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticIdListElement != null)
            {
                yield return SemanticIdListElement;

                // Recurse
                foreach (var anItem in SemanticIdListElement.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public SubmodelElementList(
            SubmodelElementElements typeValueListElement,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            bool? orderRelevant = null,
            List<ISubmodelElement>? value = null,
            GlobalReference? semanticIdListElement = null,
            DataTypeDefXsd? valueTypeListElement = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            TypeValueListElement = typeValueListElement;
            OrderRelevant = orderRelevant;
            Value = value;
            SemanticIdListElement = semanticIdListElement;
            ValueTypeListElement = valueTypeListElement;
        }
    }

    /// <summary>
    /// A submodel element struct is is a logical encapsulation of multiple values. It has
    /// a number of of submodel elements.
    /// </summary>
    public class SubmodelElementStruct :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Submodel element contained in the struct.
        /// </summary>
        public List<ISubmodelElement>? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public SubmodelElementStruct(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            List<ISubmodelElement>? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Value = value;
        }
    }

    /// <summary>
    /// A data element is a submodel element that is not further composed out of
    /// other submodel elements.
    /// </summary>
    /// <remarks>
    /// A data element is a submodel element that has a value. The type of value differs
    /// for different subtypes of data elements.
    ///
    /// A controlled value is a value whose meaning is given in an external source
    /// (see “ISO/TS 29002-10:2009(E)”).
    ///
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-090:
    ///     For data elements <see cref="IDataElement.Category" /> shall be one of the following
    ///     values: <c>CONSTANT</c>, <c>PARAMETER</c> or <c>VARIABLE</c>.
    ///     </li>
    /// </ul>
    /// </remarks>
    public interface IDataElement :
            ISubmodelElement,
            IClass
    {

    }

    /// <summary>
    /// A property is a data element that has a single value.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-007:
    ///     If both, the <see cref="Property.Value" /> and the <see cref="Property.ValueId" /> are
    ///     present then the value of <see cref="Property.Value" /> needs to be identical to
    ///     the value of the referenced coded value in <see cref="Property.ValueId" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Property :
            IDataElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Data type of the value
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        public GlobalReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Property(
            DataTypeDefXsd valueType,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            string? value = null,
            GlobalReference? valueId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ValueType = valueType;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A property is a data element that has a multi-language value.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-012:
    ///     If both the <see cref="MultiLanguageProperty.Value" /> and the <see cref="MultiLanguageProperty.ValueId" /> are present then for each
    ///     string in a specific language the meaning must be the same as specified in
    ///     <see cref="MultiLanguageProperty.ValueId" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class MultiLanguageProperty :
            IDataElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public LangStringSet? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        public GlobalReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                yield return Value;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public MultiLanguageProperty(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            LangStringSet? value = null,
            GlobalReference? valueId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A range data element is a data element that defines a range with min and max.
    /// </summary>
    public class Range :
            IDataElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Data type of the min und max
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The minimum value of the range.
        /// If the min value is missing, then the value is assumed to be negative infinite.
        /// </summary>
        public string? Min { get; set; }

        /// <summary>
        /// The maximum value of the range.
        /// If the max value is missing,  then the value is assumed to be positive infinite.
        /// </summary>
        public string? Max { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Range(
            DataTypeDefXsd valueType,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            string? min = null,
            string? max = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ValueType = valueType;
            Min = min;
            Max = max;
        }
    }

    /// <summary>
    /// A reference element is a data element that defines a logical reference to another
    /// element within the same or another AAS or a reference to an external object or
    /// entity.
    /// </summary>
    public class ReferenceElement :
            IDataElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Global reference to an external object or entity or a logical reference to
        /// another element within the same or another AAS (i.e. a model reference to
        /// a Referable).
        /// </summary>
        public IReference? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                yield return Value;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ReferenceElement(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            IReference? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Value = value;
        }
    }

    /// <summary>
    /// A <see cref="Blob" /> is a data element that represents a file that is contained with its
    /// source code in the value attribute.
    /// </summary>
    public class Blob :
            IDataElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// MIME type of the content of the <see cref="Blob" />.
        /// </summary>
        /// <remarks>
        /// The MIME type states which file extensions the file can have.
        /// Valid values are e.g. <c>application/json</c>, <c>application/xls</c>, <c>image/jpg</c>.
        /// The allowed values are defined as in RFC2046.
        /// </remarks>
        public string MimeType { get; set; }

        /// <summary>
        /// The value of the <see cref="Blob" /> instance of a blob data element.
        /// </summary>
        /// <remarks>
        /// In contrast to the file property the file content is stored directly as value
        /// in the <see cref="Blob" /> data element.
        /// </remarks>
        public byte[]? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Blob(
            string mimeType,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            byte[]? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            MimeType = mimeType;
            Value = value;
        }
    }

    /// <summary>
    /// A File is a data element that represents an address to a file.
    /// </summary>
    /// <remarks>
    /// The value is an URI that can represent an absolute or relative path.
    /// </remarks>
    public class File :
            IDataElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string ContentType { get; set; }

        /// <summary>
        /// Path and name of the referenced file (with file extension).
        /// The path can be absolute or relative.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public File(
            string contentType,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            string? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ContentType = contentType;
            Value = value;
        }
    }

    /// <summary>
    /// An annotated relationship element is a relationship element that can be annotated
    /// with additional data elements.
    /// </summary>
    public class AnnotatedRelationshipElement :
            IRelationshipElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }

        /// <summary>
        /// A data element that represents an annotation that holds for the relationship
        /// between the two elements
        /// </summary>
        public List<IDataElement>? Annotation { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return First;

            yield return Second;

            if (Annotation != null)
            {
                foreach (var anItem in Annotation)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return First;

            // Recurse
            foreach (var anItem in First.Descend())
            {
                yield return anItem;
            }

            yield return Second;

            // Recurse
            foreach (var anItem in Second.Descend())
            {
                yield return anItem;
            }

            if (Annotation != null)
            {
                foreach (var anItem in Annotation)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public AnnotatedRelationshipElement(
            IReference first,
            IReference second,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            List<IDataElement>? annotation = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            First = first;
            Second = second;
            Annotation = annotation;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an entity is a self-managed entity or a co-managed
    /// entity.
    /// </summary>
    public enum EntityType
    {
        /// <summary>
        /// For co-managed entities there is no separate AAS. Co-managed entities need to be
        /// part of a self-managed entity.
        /// </summary>
        [EnumMember(Value = "COMANAGEDENTITY")]
        CoManagedEntity,

        /// <summary>
        /// Self-Managed Entities have their own AAS but can be part of the bill of material of
        /// a composite self-managed entity. The asset of an I4.0 Component is a self-managed
        /// entity per definition."
        /// </summary>
        [EnumMember(Value = "SELFMANAGEDENTITY")]
        SelfManagedEntity
    }

    /// <summary>
    /// An entity is a submodel element that is used to model entities.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-014:
    ///     Either the attribute <see cref="Entity.GlobalAssetId" /> or <see cref="Entity.SpecificAssetId" />
    ///     of an <see cref="Entity" /> must be set if <see cref="Entity.EntityType" /> is set to
    ///     <c>SelfManagedEntity</c>. They are not existing otherwise.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Entity :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Describes whether the entity is a co- managed entity or a self-managed entity.
        /// </summary>
        public EntityType EntityType { get; set; }

        /// <summary>
        /// Describes statements applicable to the entity by a set of submodel elements,
        /// typically with a qualified value.
        /// </summary>
        public List<ISubmodelElement>? Statements { get; set; }

        /// <summary>
        /// Reference to the asset the entity is representing.
        /// </summary>
        public IReference? GlobalAssetId { get; set; }

        /// <summary>
        /// Reference to an identifier key value pair representing a specific identifier
        /// of the asset represented by the asset administration shell.
        /// </summary>
        public IdentifierKeyValuePair? SpecificAssetId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Statements != null)
            {
                foreach (var anItem in Statements)
                {
                    yield return anItem;
                }
            }

            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Statements != null)
            {
                foreach (var anItem in Statements)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;

                // Recurse
                foreach (var anItem in GlobalAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;

                // Recurse
                foreach (var anItem in SpecificAssetId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Entity(
            EntityType entityType,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            List<ISubmodelElement>? statements = null,
            IReference? globalAssetId = null,
            IdentifierKeyValuePair? specificAssetId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Statements = statements;
            EntityType = entityType;
            GlobalAssetId = globalAssetId;
            SpecificAssetId = specificAssetId;
        }
    }

    /// <summary>
    /// Direction
    /// </summary>
    public enum Direction
    {
        /// <summary>
        /// Input direction.
        /// </summary>
        [EnumMember(Value = "INPUT")]
        Input,

        /// <summary>
        /// Output direction
        /// </summary>
        [EnumMember(Value = "OUTPUT")]
        Output
    }

    /// <summary>
    /// State of an event
    /// </summary>
    public enum StateOfEvent
    {
        /// <summary>
        /// Event is on
        /// </summary>
        [EnumMember(Value = "ON")]
        On,

        /// <summary>
        /// Event is off.
        /// </summary>
        [EnumMember(Value = "OFF")]
        Off
    }

    /// <summary>
    /// Defines the necessary information of an event instance sent out or received.
    /// </summary>
    /// <remarks>
    /// The payload is not part of the information model as exchanged via
    /// the AASX package format but used in re-active Asset Administration Shells.
    /// </remarks>
    public class EventPayload : IClass
    {
        /// <summary>
        /// Reference to the source event element, including identification of
        /// <see cref="AssetAdministrationShell" />, <see cref="Submodel" />,
        /// <see cref="ISubmodelElement" />'s.
        /// </summary>
        public ModelReference Source { get; set; }

        /// <summary>
        /// <see cref="IHasSemantics.SemanticId" /> of the source event element, if available
        /// </summary>
        public GlobalReference? SourceSemanticId { get; set; }

        /// <summary>
        /// Reference to the referable, which defines the scope of the event.
        /// </summary>
        /// <remarks>
        /// Can be <see cref="AssetAdministrationShell" />, <see cref="Submodel" /> or
        /// <see cref="ISubmodelElement" />.
        /// </remarks>
        public ModelReference ObservableReference { get; set; }

        /// <summary>
        /// <see cref="IHasSemantics.SemanticId" /> of the referable which defines the scope of
        /// the event, if available.
        /// </summary>
        public GlobalReference? ObservableSemanticId { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to
        /// the respective communication channel.
        /// </summary>
        public string? Topic { get; set; }

        /// <summary>
        /// Subject, who/which initiated the creation.
        /// </summary>
        public GlobalReference? SubjectId { get; set; }

        /// <summary>
        /// Timestamp in UTC, when this event was triggered.
        /// </summary>
        public string TimeStamp { get; set; }

        /// <summary>
        /// Event specific payload.
        /// </summary>
        public string? Payload { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Source;

            if (SourceSemanticId != null)
            {
                yield return SourceSemanticId;
            }

            yield return ObservableReference;

            if (ObservableSemanticId != null)
            {
                yield return ObservableSemanticId;
            }

            if (SubjectId != null)
            {
                yield return SubjectId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Source;

            // Recurse
            foreach (var anItem in Source.Descend())
            {
                yield return anItem;
            }

            if (SourceSemanticId != null)
            {
                yield return SourceSemanticId;

                // Recurse
                foreach (var anItem in SourceSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            yield return ObservableReference;

            // Recurse
            foreach (var anItem in ObservableReference.Descend())
            {
                yield return anItem;
            }

            if (ObservableSemanticId != null)
            {
                yield return ObservableSemanticId;

                // Recurse
                foreach (var anItem in ObservableSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SubjectId != null)
            {
                yield return SubjectId;

                // Recurse
                foreach (var anItem in SubjectId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public EventPayload(
            ModelReference source,
            ModelReference observableReference,
            string timeStamp,
            GlobalReference? sourceSemanticId = null,
            GlobalReference? observableSemanticId = null,
            string? topic = null,
            GlobalReference? subjectId = null,
            string? payload = null)
        {
            Source = source;
            ObservableReference = observableReference;
            TimeStamp = timeStamp;
            SourceSemanticId = sourceSemanticId;
            ObservableSemanticId = observableSemanticId;
            Topic = topic;
            SubjectId = subjectId;
            Payload = payload;
        }
    }

    /// <summary>
    /// An event element.
    /// </summary>
    public interface IEventElement :
            ISubmodelElement,
            IClass
    {

    }

    /// <summary>
    /// A basic event element.
    /// </summary>
    public class BasicEventElement :
            IEventElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to the <see cref="IReferable" />, which defines the scope of the event.
        /// Can be <see cref="AssetAdministrationShell" />, <see cref="Submodel" />, or
        /// <see cref="ISubmodelElement" />. Reference to a referable, e.g. a data element or
        /// a submodel, that is being observed.
        /// </summary>
        public ModelReference Observed { get; set; }

        /// <summary>
        /// Direction of event.
        /// Can be <c>{ Input, Output }</c>.
        /// </summary>
        public Direction Direction { get; set; }

        /// <summary>
        /// State of event.
        /// Can be <c>{ On, Off }</c>.
        /// </summary>
        public StateOfEvent State { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to the
        /// respective communication channel.
        /// </summary>
        public string? MessageTopic { get; set; }

        /// <summary>
        /// Information, which outer message infrastructure shall handle messages for
        /// the <see cref="IEventElement" />.
        /// </summary>
        /// <remarks>
        /// Refers to a <see cref="Submodel" />, <see cref="SubmodelElementList" />,
        /// <see cref="SubmodelElementStruct" /> or <see cref="Entity" />, which contains
        /// <see cref="IDataElement" />'s describing the proprietary specification for
        /// the message broker.
        ///
        /// For different message infrastructure, e.g. OPC UA or MQTT or AMQP, these
        /// proprietary specification could be standardized by having respective Submodels.
        /// </remarks>
        public ModelReference? MessageBroker { get; set; }

        /// <summary>
        /// Timestamp in UTC, when the last event was received (input direction) or sent
        /// (output direction).
        /// </summary>
        public string? LastUpdate { get; set; }

        /// <summary>
        /// For input direction, reports on the maximum frequency, the software entity behind
        /// the respective Referable can handle input events. For output events, specifies
        /// the maximum frequency of outputting this event to an outer infrastructure.
        /// Might be not specified, that is, there is no minimum interval.
        /// </summary>
        public string? MinInterval { get; set; }

        /// <summary>
        /// For input direction: not applicable.
        /// For output direction: maximum interval in time, the respective Referable shall send
        /// an update of the status of the event, even if no other trigger condition for
        /// the event was not met. Might be not specified, that is, there is no maximum interval.
        /// </summary>
        public string? MaxInterval { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return Observed;

            if (MessageBroker != null)
            {
                yield return MessageBroker;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return Observed;

            // Recurse
            foreach (var anItem in Observed.Descend())
            {
                yield return anItem;
            }

            if (MessageBroker != null)
            {
                yield return MessageBroker;

                // Recurse
                foreach (var anItem in MessageBroker.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public BasicEventElement(
            ModelReference observed,
            Direction direction,
            StateOfEvent state,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            string? messageTopic = null,
            ModelReference? messageBroker = null,
            string? lastUpdate = null,
            string? minInterval = null,
            string? maxInterval = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Observed = observed;
            Direction = direction;
            State = state;
            MessageTopic = messageTopic;
            MessageBroker = messageBroker;
            LastUpdate = lastUpdate;
            MinInterval = minInterval;
            MaxInterval = maxInterval;
        }
    }

    /// <summary>
    /// An operation is a submodel element with input and output variables.
    /// </summary>
    public class Operation :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Input parameter of the operation.
        /// </summary>
        public List<OperationVariable>? InputVariables { get; set; }

        /// <summary>
        /// Output parameter of the operation.
        /// </summary>
        public List<OperationVariable>? OutputVariables { get; set; }

        /// <summary>
        /// Parameter that is input and output of the operation.
        /// </summary>
        public List<OperationVariable>? InoutputVariables { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (InputVariables != null)
            {
                foreach (var anItem in InputVariables)
                {
                    yield return anItem;
                }
            }

            if (OutputVariables != null)
            {
                foreach (var anItem in OutputVariables)
                {
                    yield return anItem;
                }
            }

            if (InoutputVariables != null)
            {
                foreach (var anItem in InoutputVariables)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (InputVariables != null)
            {
                foreach (var anItem in InputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (OutputVariables != null)
            {
                foreach (var anItem in OutputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (InoutputVariables != null)
            {
                foreach (var anItem in InoutputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Operation(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null,
            List<OperationVariable>? inputVariables = null,
            List<OperationVariable>? outputVariables = null,
            List<OperationVariable>? inoutputVariables = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            InputVariables = inputVariables;
            OutputVariables = outputVariables;
            InoutputVariables = inoutputVariables;
        }
    }

    /// <summary>
    /// An operation variable is a submodel element that is used as input or output variable
    /// of an operation.
    /// </summary>
    /// <remarks>
    /// <see cref="OperationVariable" /> is introduced as separate class to enable future
    /// extensions, e.g. for adding a default value, cardinality (option/mandatory).
    /// </remarks>
    public class OperationVariable : IClass
    {
        /// <summary>
        /// Describes the needed argument for an operation via a submodel element
        /// </summary>
        public ISubmodelElement Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Value;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Value;

            // Recurse
            foreach (var anItem in Value.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public OperationVariable(ISubmodelElement value)
        {
            Value = value;
        }
    }

    /// <summary>
    /// A capability is the implementation-independent description of the potential of an
    /// asset to achieve a certain effect in the physical or virtual world.
    /// </summary>
    /// <remarks>
    /// The <see cref="Capability.SemanticId" /> of a capability is typically an ontology.
    /// Thus, reasoning on capabilities is enabled.
    /// </remarks>
    public class Capability :
            ISubmodelElement,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default Value = Instance
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element.
        /// </summary>
        public GlobalReference? SemanticId { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Capability(
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            GlobalReference? semanticId = null,
            List<Qualifier>? qualifiers = null,
            List<GlobalReference>? dataSpecifications = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = ModelingKind.Instance;
            SemanticId = semanticId;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
        }
    }

    /// <summary>
    /// The semantics of a property or other elements that may have a semantic description
    /// is defined by a concept description. The description of the concept should follow a
    /// standardized schema (realized as data specification template).
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-051:
    ///     A <see cref="ConceptDescription" /> shall have one of the following categories
    ///     <c>VALUE</c>, <c>PROPERTY</c>, <c>REFERENCE</c>, <c>DOCUMENT</c>, <c>CAPABILITY</c>,
    ///     <c>RELATIONSHIP</c>, <c>COLLECTION</c>, <c>FUNCTION</c>, <c>EVENT</c>, <c>ENTITY</c>,
    ///     <c>APPLICATION_CLASS</c>, <c>QUALIFIER</c>, <c>VIEW</c>.
    ///
    ///     Default: <c>PROPERTY</c>.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class ConceptDescription :
            IIdentifiable,
            IHasDataSpecification,
            IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of
        /// the element within its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="IHasSemantics" />) conformant to IEC61360 the <see cref="IReferable.IdShort" />
        /// is typically identical to the short name in English.
        ///
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-027:
        ///     <see cref="IReferable.IdShort" /> of <see cref="IReferable" />'s shall have a maximum length
        ///     of 128 characters.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="IHasSemantics" />) of an element. The category
        /// <em>e.g.</em> could denote that the element is a measurement value whereas the
        /// semantic definition of the element would
        /// denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, <em>e.g.</em>, if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        public List<GlobalReference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to an external definition the concept is compatible to or was derived from
        /// </summary>
        /// <remarks>
        /// Compare to is-case-of relationship in ISO 13584-32 &amp; IEC EN 61360"
        /// </remarks>
        public List<GlobalReference>? IsCaseOf { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (IsCaseOf != null)
            {
                foreach (var anItem in IsCaseOf)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (IsCaseOf != null)
            {
                foreach (var anItem in IsCaseOf)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ConceptDescription(
            string id,
            List<Extension>? extensions = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            string? category = null,
            LangStringSet? description = null,
            string? checksum = null,
            AdministrativeInformation? administration = null,
            List<GlobalReference>? dataSpecifications = null,
            List<GlobalReference>? isCaseOf = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Id = id;
            Administration = administration;
            DataSpecifications = dataSpecifications;
            IsCaseOf = isCaseOf;
        }
    }

    /// <summary>
    /// Reference to either a model element of the same or another AAs or to an external
    /// entity.
    /// </summary>
    public interface IReference : IClass
    {

    }

    /// <summary>
    /// Reference to an external entity.
    /// </summary>
    public class GlobalReference :
            IReference,
            IClass
    {
        /// <summary>
        /// Unique identifier
        /// </summary>
        /// <remarks>
        /// The identifier can be a concatenation of different identifiers, for example
        /// representing an IRDI path etc.
        /// </remarks>
        public string Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public GlobalReference(string value)
        {
            Value = value;
        }
    }

    /// <summary>
    /// Reference to a model element of the same or another AAS.
    /// </summary>
    /// <remarks>
    /// A model reference is an ordered list of keys, each key referencing an element.
    /// The complete list of keys may for example be concatenated to a path that then gives
    /// unique access to an element.
    /// </remarks>
    public class ModelReference :
            IReference,
            IClass
    {
        /// <summary>
        /// Unique references in their name space.
        /// </summary>
        public List<Key> Keys { get; set; }

        /// <summary>
        /// <see cref="IHasSemantics.SemanticId" /> of the referenced model element.
        /// </summary>
        public GlobalReference? ReferredSemanticId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in Keys)
            {
                yield return anItem;
            }

            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in Keys)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;

                // Recurse
                foreach (var anItem in ReferredSemanticId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public ModelReference(
            List<Key> keys,
            GlobalReference? referredSemanticId = null)
        {
            Keys = keys;
            ReferredSemanticId = referredSemanticId;
        }
    }

    /// <summary>
    /// A key is a reference to an element by its ID.
    /// </summary>
    public class Key : IClass
    {
        /// <summary>
        /// Denote which kind of entity is referenced.
        /// </summary>
        /// <remarks>
        /// In case type = FragmentReference the key represents a bookmark or a similar local
        /// identifier within its parent element as specified by the key that precedes this key.
        ///
        /// In all other cases the key references a model element of the same or of another AAS.
        /// The name of the model element is explicitly listed.
        /// </remarks>
        public KeyElements Type { get; set; }

        /// <summary>
        /// The key value, for example an IRDI or an URI
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Key(
            KeyElements type,
            string value)
        {
            Type = type;
            Value = value;
        }
    }

    /// <summary>
    /// Enumeration of all identifiable elements within an asset administration shell.
    /// </summary>
    public enum IdentifiableElements
    {
        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        [EnumMember(Value = "Submodel")]
        Submodel
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell.
    /// </summary>
    public enum SubmodelElementElements
    {
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        /// <summary>
        /// Data Element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="SubmodelElementElements.DataElement" />
        /// the reference may be a <see cref="Property" />, a <see cref="File" /> etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event element
        /// </summary>
        /// <remarks>
        /// <see cref="IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, i.e. if a key uses
        /// <see cref="SubmodelElementElements.SubmodelElement" /> the reference may be a <see cref="Property" />,
        /// a <see cref="SubmodelElementList" />, an <see cref="Operation" /> etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementStruct")]
        SubmodelElementStruct
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell
    /// </summary>
    public enum ReferableElements
    {
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="ReferableElements.DataElement" />
        /// the reference may be a <see cref="Property" />, a <see cref="File" /> <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// <see cref="IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="ReferableElements.SubmodelElement" />
        /// the reference may be a <see cref="Property" />, an <see cref="Operation" /> <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementStruct")]
        SubmodelElementStruct
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum KeyElements
    {
        /// <summary>
        /// Bookmark or a similar local identifier of a subordinate part of
        /// a primary resource
        /// </summary>
        [EnumMember(Value = "FragmentReference")]
        FragmentReference,

        [EnumMember(Value = "GlobalReference")]
        GlobalReference,

        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="KeyElements.DataElement" />
        /// the reference may be a Property, a File <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// <see cref="IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="KeyElements.SubmodelElement" />
        /// the reference may be a <see cref="Property" />, an <see cref="Operation" /> <em>etc.</em>
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementStruct")]
        SubmodelElementStruct
    }

    /// <summary>
    /// Enumeration listing all xsd anySimpleTypes
    /// </summary>
    public enum DataTypeDefXsd
    {
        [EnumMember(Value = "xs:anyURI")]
        AnyUri,

        [EnumMember(Value = "xs:base64Binary")]
        Base64Binary,

        [EnumMember(Value = "xs:boolean")]
        Boolean,

        [EnumMember(Value = "xs:date")]
        Date,

        [EnumMember(Value = "xs:dateTime")]
        DateTime,

        [EnumMember(Value = "xs:dateTimeStamp")]
        DateTimeStamp,

        [EnumMember(Value = "xs:decimal")]
        Decimal,

        [EnumMember(Value = "xs:double")]
        Double,

        [EnumMember(Value = "xs:duration")]
        Duration,

        [EnumMember(Value = "xs:float")]
        Float,

        [EnumMember(Value = "xs:gDay")]
        GDay,

        [EnumMember(Value = "xs:gMonth")]
        GMonth,

        [EnumMember(Value = "xs:gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "xs:gYear")]
        GYear,

        [EnumMember(Value = "xs:gYearMonth")]
        GYearMonth,

        [EnumMember(Value = "xs:hexBinary")]
        HexBinary,

        [EnumMember(Value = "xs:string")]
        String,

        [EnumMember(Value = "xs:time")]
        Time,

        [EnumMember(Value = "xs:dayTimeDuration")]
        DayTimeDuration,

        [EnumMember(Value = "xs:yearMonthDuration")]
        YearMonthDuration,

        [EnumMember(Value = "xs:integer")]
        Integer,

        [EnumMember(Value = "xs:long")]
        Long,

        [EnumMember(Value = "xs:int")]
        Int,

        [EnumMember(Value = "xs:short")]
        Short,

        [EnumMember(Value = "xs:byte")]
        Byte,

        [EnumMember(Value = "xs:NonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "xs:positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "xs:unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "xs:unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "xs:unsignedShort")]
        UnsignedShort,

        [EnumMember(Value = "xs:unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "xs:nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "xs:negativeInteger")]
        NegativeInteger
    }

    /// <summary>
    /// Enumeration listing all RDF types
    /// </summary>
    public enum DataTypeDefRdf
    {
        /// <summary>
        /// String with a language tag
        /// </summary>
        /// <remarks>
        /// RDF requires IETF BCP 47  language tags, i.e. simple two-letter language tags
        /// for Locales like “de” conformant to ISO 639-1 are allowed as well as language
        /// tags plus extension like “de-DE” for country code, dialect etc. like in “en-US”
        /// or “en-GB” for English (United Kingdom) and English (United States).
        /// IETF language tags are referencing ISO 639, ISO 3166 and ISO 15924.
        /// </remarks>
        [EnumMember(Value = "rdf:langString")]
        LangString
    }

    /// <summary>
    /// string with values of enumerations <see cref="DataTypeDefXsd" />,
    /// <see cref="DataTypeDefRdf" />
    /// </summary>
    public enum DataTypeDef
    {
        [EnumMember(Value = "xs:anyURI")]
        AnyUri,

        [EnumMember(Value = "xs:base64Binary")]
        Base64Binary,

        [EnumMember(Value = "xs:boolean")]
        Boolean,

        [EnumMember(Value = "xs:date")]
        Date,

        [EnumMember(Value = "xs:dateTime")]
        DateTime,

        [EnumMember(Value = "xs:dateTimeStamp")]
        DateTimeStamp,

        [EnumMember(Value = "xs:decimal")]
        Decimal,

        [EnumMember(Value = "xs:double")]
        Double,

        [EnumMember(Value = "xs:duration")]
        Duration,

        [EnumMember(Value = "xs:float")]
        Float,

        [EnumMember(Value = "xs:gDay")]
        GDay,

        [EnumMember(Value = "xs:gMonth")]
        GMonth,

        [EnumMember(Value = "xs:gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "xs:gYear")]
        GYear,

        [EnumMember(Value = "xs:gYearMonth")]
        GYearMonth,

        [EnumMember(Value = "xs:hexBinary")]
        HexBinary,

        [EnumMember(Value = "xs:string")]
        String,

        [EnumMember(Value = "xs:time")]
        Time,

        [EnumMember(Value = "xs:dayTimeDuration")]
        DayTimeDuration,

        [EnumMember(Value = "xs:yearMonthDuration")]
        YearMonthDuration,

        [EnumMember(Value = "xs:integer")]
        Integer,

        [EnumMember(Value = "xs:long")]
        Long,

        [EnumMember(Value = "xs:int")]
        Int,

        [EnumMember(Value = "xs:short")]
        Short,

        [EnumMember(Value = "xs:byte")]
        Byte,

        [EnumMember(Value = "xs:NonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "xs:positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "xs:unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "xs:unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "xs:unsignedShort")]
        UnsignedShort,

        [EnumMember(Value = "xs:unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "xs:nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "xs:negativeInteger")]
        NegativeInteger,

        [EnumMember(Value = "rdf:langString")]
        LangString
    }

    /// <summary>
    /// Strings with language tags
    /// </summary>
    public class LangString : IClass
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="LangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public LangString(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// Array of elements of type langString
    /// </summary>
    /// <remarks>
    /// langString is a RDF data type.
    ///
    /// A langString is a string value tagged with a language code.
    /// It depends on the serialization rules for a technology how
    /// this is realized.
    /// </remarks>
    public class LangStringSet : IClass
    {
        /// <summary>
        /// Strings in different languages
        /// </summary>
        public List<LangString> LangStrings { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in LangStrings)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in LangStrings)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public LangStringSet(List<LangString> langStrings)
        {
            LangStrings = langStrings;
        }
    }

    /// <summary>
    /// Container for the sets of different identifiables.
    /// </summary>
    /// <remarks>
    /// w.r.t. file exchange: There is exactly one environment independent on how many
    /// files the contained elements are split. If the file is split then there
    /// shall be no element with the same identifier in two different files.
    /// </remarks>
    public class Environment : IClass
    {
        /// <summary>
        /// Asset administration shell
        /// </summary>
        public List<AssetAdministrationShell>? AssetAdministrationShells { get; set; }

        /// <summary>
        /// Submodel
        /// </summary>
        public List<Submodel>? Submodels { get; set; }

        /// <summary>
        /// Concept description
        /// </summary>
        public List<ConceptDescription>? ConceptDescriptions { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (AssetAdministrationShells != null)
            {
                foreach (var anItem in AssetAdministrationShells)
                {
                    yield return anItem;
                }
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;
                }
            }

            if (ConceptDescriptions != null)
            {
                foreach (var anItem in ConceptDescriptions)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (AssetAdministrationShells != null)
            {
                foreach (var anItem in AssetAdministrationShells)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ConceptDescriptions != null)
            {
                foreach (var anItem in ConceptDescriptions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<C>(Visitation.IVisitorWithContext<C> visitor, C context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<C, T>(
            Visitation.ITransformerWithContext<C, T> transformer, C context)
        {
            return transformer.Transform(this, context);
        }

        public Environment(
            List<AssetAdministrationShell>? assetAdministrationShells = null,
            List<Submodel>? submodels = null,
            List<ConceptDescription>? conceptDescriptions = null)
        {
            AssetAdministrationShells = assetAdministrationShells;
            Submodels = submodels;
            ConceptDescriptions = conceptDescriptions;
        }
    }

}  // namespace AasCore.Aas3

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
