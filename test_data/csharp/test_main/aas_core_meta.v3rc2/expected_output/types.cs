/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

using EnumMemberAttribute = System.Runtime.Serialization.EnumMemberAttribute;
using System.Collections.Generic;  // can't alias

using Aas = AasCore.Aas3_0_RC02;

namespace AasCore.Aas3_0_RC02
{

    /// <summary>
    /// Represent a general class of an AAS model.
    /// </summary>
    public interface IClass
    {
        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce();

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend();

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor);

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context);
    }

    /// <summary>
    /// Element that can have a semantic definition plus some supplemental semantic
    /// definitions.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-118:
    ///     If there are ID <see cref="Aas.IHasSemantics.SupplementalSemanticIds" /> defined
    ///     then there shall be also a main semantic ID <see cref="Aas.IHasSemantics.SemanticId" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public interface IHasSemantics : IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }
    }

    /// <summary>
    /// Single extension of an element.
    /// </summary>
    public class Extension : IHasSemantics
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Name of the extension.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-077:
        ///     The name of an extension within <see cref="Aas.IHasExtensions" /> needs to be unique.
        ///     </li>
        /// </ul>
        /// </remarks>
        public string Name { get; set; }

        /// <summary>
        /// Type of the value of the extension.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.DataTypeDefXsd.String" />
        /// </remarks>
        public DataTypeDefXsd? ValueType { get; set; }

        /// <summary>
        /// Value of the extension
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to an element the extension refers to.
        /// </summary>
        public Reference? RefersTo { get; set; }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="Extension.ValueType" /> or the default value
        /// if it has not been set.
        /// </summary>
        public DataTypeDefXsd ValueTypeOrDefault()
        {
            return ValueType ?? DataTypeDefXsd.String;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (RefersTo != null)
            {
                yield return RefersTo;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (RefersTo != null)
            {
                yield return RefersTo;

                // Recurse
                foreach (var anItem in RefersTo.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Extension(
            string name,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            DataTypeDefXsd? valueType = null,
            string? value = null,
            Reference? refersTo = null)
        {
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Name = name;
            ValueType = valueType;
            Value = value;
            RefersTo = refersTo;
        }
    }

    /// <summary>
    /// Element that can be extended by proprietary extensions.
    /// </summary>
    /// <remarks>
    /// Extensions are proprietary, i.e. they do not support global interoperability.
    /// </remarks>
    public interface IHasExtensions : IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }
    }

    /// <summary>
    /// An element that is referable by its <see cref="Aas.IReferable.IdShort" />.
    /// </summary>
    /// <remarks>
    /// This ID is not globally unique.
    /// This ID is unique within the name space of the element.
    /// </remarks>
    public interface IReferable : IHasExtensions
    {
        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }
    }

    /// <summary>
    /// An element that has a globally unique identifier.
    /// </summary>
    public interface IIdentifiable : IReferable
    {
        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }
    }

    /// <summary>
    /// Enumeration for denoting whether an element is a template or an instance.
    /// </summary>
    public enum ModelingKind
    {
        /// <summary>
        /// Software element which specifies the common attributes shared by all instances of
        /// the template.
        /// </summary>
        /// <remarks>
        /// [SOURCE: IEC TR 62390:2005-01, 3.1.25] modified
        /// </remarks>
        [EnumMember(Value = "Template")]
        Template,

        /// <summary>
        /// Concrete, clearly identifiable component of a certain template.
        /// </summary>
        /// <remarks>
        /// It becomes an individual entity of a  template,  for example a
        /// device model, by defining specific property values.
        ///
        /// In an object oriented view,  an instance denotes an object of a
        /// template (class).
        ///
        /// [SOURCE: IEC 62890:2016, 3.1.16 65/617/CDV]  modified
        /// </remarks>
        [EnumMember(Value = "Instance")]
        Instance
    }

    /// <summary>
    /// An element with a kind is an element that can either represent a template or an
    /// instance.
    /// </summary>
    /// <remarks>
    /// Default for an element is that it is representing an instance.
    /// </remarks>
    public interface IHasKind : IClass
    {
        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        public ModelingKind KindOrDefault();
    }

    /// <summary>
    /// Element that can be extended by using data specification templates.
    /// </summary>
    /// <remarks>
    /// A data specification template defines a named set of additional attributes an
    /// element may or shall have. The data specifications used are explicitly specified
    /// with their global ID.
    /// </remarks>
    public interface IHasDataSpecification : IClass
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }
    }

    /// <summary>
    /// Administrative meta-information for an element like version
    /// information.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-005:
    ///     If <see cref="Aas.AdministrativeInformation.Version" /> is not specified then also <see cref="Aas.AdministrativeInformation.Revision" /> shall be
    ///     unspecified. This means, a revision requires a version. If there is no version
    ///     there is no revision neither. Revision is optional.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class AdministrativeInformation : IHasDataSpecification
    {
        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Version of the element.
        /// </summary>
        public string? Version { get; set; }

        /// <summary>
        /// Revision of the element.
        /// </summary>
        public string? Revision { get; set; }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public AdministrativeInformation(
            List<Reference>? dataSpecifications = null,
            string? version = null,
            string? revision = null)
        {
            DataSpecifications = dataSpecifications;
            Version = version;
            Revision = revision;
        }
    }

    /// <summary>
    /// The value of a qualifiable element may be further qualified by one or more
    /// qualifiers.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-119:
    ///     If any <see cref="Aas.Qualifier.Kind" /> value of <see cref="Aas.IQualifiable.Qualifiers" /> is
    ///     equal to <see cref="Aas.QualifierKind.TemplateQualifier" /> and the qualified element
    ///     inherits from <see cref="Aas.IHasKind" /> then the qualified element shell be of
    ///     kind Template (<see cref="Aas.IHasKind.Kind" /> = <see cref="Aas.ModelingKind.Template" />).
    ///     </li>
    /// </ul>
    /// </remarks>
    public interface IQualifiable : IClass
    {
        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }
    }

    /// <summary>
    /// Enumeration for kinds of qualifiers.
    /// </summary>
    public enum QualifierKind
    {
        /// <summary>
        /// qualifies the value of the element and can change during run-time.
        /// </summary>
        /// <remarks>
        /// Value qualifiers are only applicable to elements with kind
        /// <see cref="Aas.ModelingKind.Instance" />.
        /// </remarks>
        [EnumMember(Value = "ValueQualifier")]
        ValueQualifier,

        /// <summary>
        /// qualifies the semantic definition the element is referring to
        /// (<see cref="Aas.IHasSemantics.SemanticId" />)
        /// </summary>
        [EnumMember(Value = "ConceptQualifier")]
        ConceptQualifier,

        /// <summary>
        /// qualifies the elements within a specific submodel on concept level.
        /// </summary>
        /// <remarks>
        /// Template qualifiers are only applicable to elements with kind
        /// <see cref="Aas.ModelingKind.Template" />.
        /// </remarks>
        [EnumMember(Value = "TemplateQualifier")]
        TemplateQualifier
    }

    /// <summary>
    /// A qualifier is a type-value-pair that makes additional statements w.r.t. the value
    /// of the element.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-006:
    ///     If both the <see cref="Aas.Qualifier.Value" /> and the <see cref="Aas.Qualifier.ValueId" /> of
    ///     a <see cref="Aas.Qualifier" /> are present then the <see cref="Aas.Qualifier.Value" /> needs
    ///     to be identical to the value of the referenced coded value
    ///     in <see cref="Aas.Qualifier.ValueId" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-020:
    ///     The value of <see cref="Aas.Qualifier.Value" /> shall be consistent to the data type as
    ///     defined in <see cref="Aas.Qualifier.ValueType" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Qualifier : IHasSemantics
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// The qualifier kind describes the kind of the qualifier that is applied to the
        /// element.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.QualifierKind.ConceptQualifier" />
        /// </remarks>
        public QualifierKind? Kind { get; set; }

        /// <summary>
        /// The qualifier <em>type</em> describes the type of the qualifier that is applied to
        /// the element.
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Data type of the qualifier value.
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The qualifier value is the value of the qualifier.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? ValueId { get; set; }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="Qualifier.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public QualifierKind KindOrDefault()
        {
            return Kind ?? QualifierKind.ConceptQualifier;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Qualifier(
            string type,
            DataTypeDefXsd valueType,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            QualifierKind? kind = null,
            string? value = null,
            Reference? valueId = null)
        {
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Type = type;
            ValueType = valueType;
            Kind = kind;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// An asset administration shell.
    /// </summary>
    public class AssetAdministrationShell :
            IIdentifiable,
            IHasDataSpecification
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// The reference to the AAS the AAS was derived from.
        /// </summary>
        public Reference? DerivedFrom { get; set; }

        /// <summary>
        /// Meta-information about the asset the AAS is representing.
        /// </summary>
        public AssetInformation AssetInformation { get; set; }

        /// <summary>
        /// References to submodels of the AAS.
        /// </summary>
        /// <remarks>
        /// A submodel is a description of an aspect of the asset the AAS is representing.
        ///
        /// The asset of an AAS is typically described by one or more submodels.
        ///
        /// Temporarily no submodel might be assigned to the AAS.
        /// </remarks>
        public List<Reference>? Submodels { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Submodels, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSubmodelsOrEmpty()
        {
            return Submodels
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;
            }

            yield return AssetInformation;

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;

                // Recurse
                foreach (var anItem in DerivedFrom.Descend())
                {
                    yield return anItem;
                }
            }

            yield return AssetInformation;

            // Recurse
            foreach (var anItem in AssetInformation.Descend())
            {
                yield return anItem;
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public AssetAdministrationShell(
            string id,
            AssetInformation assetInformation,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            AdministrativeInformation? administration = null,
            List<Reference>? dataSpecifications = null,
            Reference? derivedFrom = null,
            List<Reference>? submodels = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Id = id;
            Administration = administration;
            DataSpecifications = dataSpecifications;
            DerivedFrom = derivedFrom;
            AssetInformation = assetInformation;
            Submodels = submodels;
        }
    }

    /// <summary>
    /// In <see cref="Aas.AssetInformation" /> identifying meta data of the asset that is
    /// represented by an AAS is defined.
    /// </summary>
    /// <remarks>
    /// The asset may either represent an asset type or an asset instance.
    ///
    /// The asset has a globally unique identifier plus – if needed – additional domain
    /// specific (proprietary) identifiers. However, to support the corner case of very
    /// first phase of lifecycle where a stabilised/constant global asset identifier does
    /// not already exist, the corresponding attribute <see cref="Aas.AssetInformation.GlobalAssetId" /> is optional.
    ///
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-116:
    ///     <c>globalAssetId</c> (case-insensitive) is a reserved key. If used as value for
    ///     <see cref="Aas.SpecificAssetId.Name" /> then <see cref="Aas.SpecificAssetId.Value" /> shall be
    ///     identical to <see cref="Aas.AssetInformation.GlobalAssetId" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class AssetInformation : IClass
    {
        /// <summary>
        /// Denotes whether the Asset is of kind <see cref="Aas.AssetKind.Type" /> or
        /// <see cref="Aas.AssetKind.Instance" />.
        /// </summary>
        public AssetKind AssetKind { get; set; }

        /// <summary>
        /// Global identifier of the asset the AAS is representing.
        /// </summary>
        /// <remarks>
        /// This attribute is required as soon as the AAS is exchanged via partners in the life
        /// cycle of the asset. In a first phase of the life cycle the asset might not yet have
        /// a global ID but already an internal identifier. The internal identifier would be
        /// modelled via <see cref="Aas.AssetInformation.SpecificAssetIds" />.
        ///
        /// This is a global reference.
        /// </remarks>
        public Reference? GlobalAssetId { get; set; }

        /// <summary>
        /// Additional domain-specific, typically proprietary identifier for the asset like
        /// e.g., serial number etc.
        /// </summary>
        public List<SpecificAssetId>? SpecificAssetIds { get; set; }

        /// <summary>
        /// Thumbnail of the asset represented by the Asset Administration Shell.
        /// </summary>
        /// <remarks>
        /// Used as default.
        /// </remarks>
        public Resource? DefaultThumbnail { get; set; }

        /// <summary>
        /// Iterate over SpecificAssetIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<SpecificAssetId> OverSpecificAssetIdsOrEmpty()
        {
            return SpecificAssetIds
                ?? System.Linq.Enumerable.Empty<SpecificAssetId>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;
            }

            if (SpecificAssetIds != null)
            {
                foreach (var anItem in SpecificAssetIds)
                {
                    yield return anItem;
                }
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;

                // Recurse
                foreach (var anItem in GlobalAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetIds != null)
            {
                foreach (var anItem in SpecificAssetIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;

                // Recurse
                foreach (var anItem in DefaultThumbnail.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public AssetInformation(
            AssetKind assetKind,
            Reference? globalAssetId = null,
            List<SpecificAssetId>? specificAssetIds = null,
            Resource? defaultThumbnail = null)
        {
            AssetKind = assetKind;
            GlobalAssetId = globalAssetId;
            SpecificAssetIds = specificAssetIds;
            DefaultThumbnail = defaultThumbnail;
        }
    }

    /// <summary>
    /// Resource represents an address to a file (a locator). The value is an URI that
    /// can represent an absolute or relative path
    /// </summary>
    public class Resource : IClass
    {
        /// <summary>
        /// Path and name of the resource (with file extension).
        /// </summary>
        /// <remarks>
        /// The path can be absolute or relative.
        /// </remarks>
        public string Path { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string? ContentType { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Resource(
            string path,
            string? contentType = null)
        {
            Path = path;
            ContentType = contentType;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an asset is a type asset or an instance asset.
    /// </summary>
    public enum AssetKind
    {
        /// <summary>
        /// hardware or software element which specifies the common attributes shared by all
        /// instances of the type
        /// </summary>
        /// <remarks>
        /// [SOURCE: IEC TR 62390:2005-01, 3.1.25]
        /// </remarks>
        [EnumMember(Value = "Type")]
        Type,

        /// <summary>
        /// concrete, clearly identifiable component of a certain type
        /// </summary>
        /// <remarks>
        /// It becomes an individual entity of a type, for example a device, by defining
        /// specific property values.
        ///
        /// In an object oriented view, an instance denotes an object of a class
        /// (of a type).
        ///
        /// [SOURCE: IEC 62890:2016, 3.1.16] 65/617/CDV
        /// </remarks>
        [EnumMember(Value = "Instance")]
        Instance
    }

    /// <summary>
    /// A specific asset ID describes a generic supplementary identifying attribute of the
    /// asset.
    /// </summary>
    /// <remarks>
    /// The specific asset ID is not necessarily globally unique.
    /// </remarks>
    public class SpecificAssetId : IHasSemantics
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Name of the identifier
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The value of the specific asset identifier with the corresponding name.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// The (external) subject the key belongs to or has meaning to.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public Reference ExternalSubjectId { get; set; }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            yield return ExternalSubjectId;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return ExternalSubjectId;

            // Recurse
            foreach (var anItem in ExternalSubjectId.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public SpecificAssetId(
            string name,
            string value,
            Reference externalSubjectId,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null)
        {
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Name = name;
            Value = value;
            ExternalSubjectId = externalSubjectId;
        }
    }

    /// <summary>
    /// A submodel defines a specific aspect of the asset represented by the AAS.
    /// </summary>
    /// <remarks>
    /// A submodel is used to structure the digital representation and technical
    /// functionality of an Administration Shell into distinguishable parts. Each submodel
    /// refers to a well-defined domain or subject matter. Submodels can become
    /// standardized and, thus, become submodels templates.
    /// </remarks>
    public class Submodel :
            IIdentifiable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// A submodel consists of zero or more submodel elements.
        /// </summary>
        public List<ISubmodelElement>? SubmodelElements { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over SubmodelElements, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverSubmodelElementsOrEmpty()
        {
            return SubmodelElements
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (SubmodelElements != null)
            {
                foreach (var anItem in SubmodelElements)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SubmodelElements != null)
            {
                foreach (var anItem in SubmodelElements)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Submodel(
            string id,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            AdministrativeInformation? administration = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            List<ISubmodelElement>? submodelElements = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Id = id;
            Administration = administration;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            SubmodelElements = submodelElements;
        }
    }

    /// <summary>
    /// A submodel element is an element suitable for the description and differentiation of
    /// assets.
    /// </summary>
    /// <remarks>
    /// It is recommended to add a <see cref="Aas.IHasSemantics.SemanticId" /> to a submodel element.
    /// </remarks>
    public interface ISubmodelElement :
            IReferable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification
    {
        // Intentionally empty.
    }

    /// <summary>
    /// A relationship element is used to define a relationship between two elements
    /// being either referable (model reference) or external (global reference).
    /// </summary>
    public interface IRelationshipElement : ISubmodelElement
    {
        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public Reference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public Reference Second { get; set; }
    }

    /// <summary>
    /// A relationship element is used to define a relationship between two elements
    /// being either referable (model reference) or external (global reference).
    /// </summary>
    public class RelationshipElement : IRelationshipElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public Reference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public Reference Second { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return First;

            yield return Second;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return First;

            // Recurse
            foreach (var anItem in First.Descend())
            {
                yield return anItem;
            }

            yield return Second;

            // Recurse
            foreach (var anItem in Second.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public RelationshipElement(
            Reference first,
            Reference second,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            First = first;
            Second = second;
        }
    }

    /// <summary>
    /// A submodel element list is an ordered list of submodel elements.
    /// </summary>
    /// <remarks>
    /// The numbering starts with zero (0).
    ///
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-107:
    ///     If a first level child element in a <see cref="Aas.SubmodelElementList" /> has
    ///     a <see cref="Aas.ISubmodelElement.SemanticId" /> it
    ///     shall be identical to <see cref="Aas.SubmodelElementList.SemanticIdListElement" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-114:
    ///     If two first level child elements in a <see cref="Aas.SubmodelElementList" /> have
    ///     a <see cref="Aas.ISubmodelElement.SemanticId" /> then they shall be identical.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-115:
    ///     If a first level child element in a <see cref="Aas.SubmodelElementList" /> does not
    ///     specify a <see cref="Aas.ISubmodelElement.SemanticId" /> then the value is assumed to be
    ///     identical to <see cref="Aas.SubmodelElementList.SemanticIdListElement" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-108:
    ///     All first level child elements in a <see cref="Aas.SubmodelElementList" /> shall have
    ///     the same submodel element type as specified in <see cref="Aas.SubmodelElementList.TypeValueListElement" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-109:
    ///     If <see cref="Aas.SubmodelElementList.TypeValueListElement" /> is equal to
    ///     <see cref="Aas.AasSubmodelElements.Property" /> or
    ///     <see cref="Aas.AasSubmodelElements.Range" />
    ///     <see cref="Aas.SubmodelElementList.ValueTypeListElement" /> shall be set and all first
    ///     level child elements in the <see cref="Aas.SubmodelElementList" /> shall have
    ///     the value type as specified in <see cref="Aas.SubmodelElementList.ValueTypeListElement" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class SubmodelElementList : ISubmodelElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Defines whether order in list is relevant. If <see cref="Aas.SubmodelElementList.OrderRelevant" /> = <c>False</c>
        /// then the list is representing a set or a bag.
        /// </summary>
        /// <remarks>
        /// Default: <c>True</c>
        /// </remarks>
        public bool? OrderRelevant { get; set; }

        /// <summary>
        /// Submodel element contained in the list.
        /// </summary>
        /// <remarks>
        /// The list is ordered.
        /// </remarks>
        public List<ISubmodelElement>? Value { get; set; }

        /// <summary>
        /// Semantic ID the submodel elements contained in the list match to.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticIdListElement { get; set; }

        /// <summary>
        /// The submodel element type of the submodel elements contained in the list.
        /// </summary>
        public AasSubmodelElements TypeValueListElement { get; set; }

        /// <summary>
        /// The value type of the submodel element contained in the list.
        /// </summary>
        public DataTypeDefXsd? ValueTypeListElement { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverValueOrEmpty()
        {
            return Value
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="SubmodelElementList.OrderRelevant" /> or the default value
        /// if it has not been set.
        /// </summary>
        public bool OrderRelevantOrDefault()
        {
            return OrderRelevant ?? true;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }

            if (SemanticIdListElement != null)
            {
                yield return SemanticIdListElement;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticIdListElement != null)
            {
                yield return SemanticIdListElement;

                // Recurse
                foreach (var anItem in SemanticIdListElement.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public SubmodelElementList(
            AasSubmodelElements typeValueListElement,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            bool? orderRelevant = null,
            List<ISubmodelElement>? value = null,
            Reference? semanticIdListElement = null,
            DataTypeDefXsd? valueTypeListElement = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            TypeValueListElement = typeValueListElement;
            OrderRelevant = orderRelevant;
            Value = value;
            SemanticIdListElement = semanticIdListElement;
            ValueTypeListElement = valueTypeListElement;
        }
    }

    /// <summary>
    /// A submodel element collection is a kind of struct, i.e. a a logical encapsulation
    /// of multiple named values. It has a fixed number of submodel elements.
    /// </summary>
    public class SubmodelElementCollection : ISubmodelElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Submodel element contained in the collection.
        /// </summary>
        public List<ISubmodelElement>? Value { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverValueOrEmpty()
        {
            return Value
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public SubmodelElementCollection(
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            List<ISubmodelElement>? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Value = value;
        }
    }

    /// <summary>
    /// A data element is a submodel element that is not further composed out of
    /// other submodel elements.
    /// </summary>
    /// <remarks>
    /// A data element is a submodel element that has a value. The type of value differs
    /// for different subtypes of data elements.
    ///
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-090:
    ///     For data elements <see cref="Aas.IDataElement.Category" /> (inherited by <see cref="Aas.IReferable" />) shall be
    ///     one of the following values: <c>CONSTANT</c>, <c>PARAMETER</c> or <c>VARIABLE</c>.
    ///
    ///     Default: <c>VARIABLE</c>
    ///     </li>
    /// </ul>
    /// </remarks>
    public interface IDataElement : ISubmodelElement
    {
        public string CategoryOrDefault();
        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty();
        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty();
        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty();
        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty();
    }

    /// <summary>
    /// A property is a data element that has a single value.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-007:
    ///     If both, the <see cref="Aas.Property.Value" /> and the <see cref="Aas.Property.ValueId" /> are
    ///     present then the value of <see cref="Aas.Property.Value" /> needs to be identical to
    ///     the value of the referenced coded value in <see cref="Aas.Property.ValueId" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Property : IDataElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Data type of the value
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? ValueId { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="IDataElement.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

        #if DEBUG
            if (!Verification.DataElementCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Property(
            DataTypeDefXsd valueType,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            string? value = null,
            Reference? valueId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ValueType = valueType;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A property is a data element that has a multi-language value.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-012:
    ///     If both the <see cref="Aas.MultiLanguageProperty.Value" /> and the <see cref="Aas.MultiLanguageProperty.ValueId" /> are present then for each
    ///     string in a specific language the meaning must be the same as specified in
    ///     <see cref="Aas.MultiLanguageProperty.ValueId" />.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class MultiLanguageProperty : IDataElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public LangStringSet? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? ValueId { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="IDataElement.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

        #if DEBUG
            if (!Verification.DataElementCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                yield return Value;
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public MultiLanguageProperty(
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            LangStringSet? value = null,
            Reference? valueId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A range data element is a data element that defines a range with min and max.
    /// </summary>
    public class Range : IDataElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Data type of the min und max
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The minimum value of the range.
        /// </summary>
        /// <remarks>
        /// If the min value is missing, then the value is assumed to be negative infinite.
        /// </remarks>
        public string? Min { get; set; }

        /// <summary>
        /// The maximum value of the range.
        /// </summary>
        /// <remarks>
        /// If the max value is missing,  then the value is assumed to be positive infinite.
        /// </remarks>
        public string? Max { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="IDataElement.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

        #if DEBUG
            if (!Verification.DataElementCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Range(
            DataTypeDefXsd valueType,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            string? min = null,
            string? max = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ValueType = valueType;
            Min = min;
            Max = max;
        }
    }

    /// <summary>
    /// A reference element is a data element that defines a logical reference to another
    /// element within the same or another AAS or a reference to an external object or
    /// entity.
    /// </summary>
    public class ReferenceElement : IDataElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Global reference to an external object or entity or a logical reference to
        /// another element within the same or another AAS (i.e. a model reference to
        /// a Referable).
        /// </summary>
        public Reference? Value { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="IDataElement.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

        #if DEBUG
            if (!Verification.DataElementCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                yield return Value;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public ReferenceElement(
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            Reference? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Value = value;
        }
    }

    /// <summary>
    /// A <see cref="Aas.Blob" /> is a data element that represents a file that is contained with its
    /// source code in the value attribute.
    /// </summary>
    public class Blob : IDataElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// The value of the <see cref="Aas.Blob" /> instance of a blob data element.
        /// </summary>
        /// <remarks>
        /// In contrast to the file property the file content is stored directly as value
        /// in the <see cref="Aas.Blob" /> data element.
        /// </remarks>
        public byte[]? Value { get; set; }

        /// <summary>
        /// Content type of the content of the <see cref="Aas.Blob" />.
        /// </summary>
        /// <remarks>
        /// The content type (MIME type) states which file extensions the file can have.
        ///
        /// Valid values are content types like e.g. <c>application/json</c>, <c>application/xls</c>,
        /// <c>image/jpg</c>.
        ///
        /// The allowed values are defined as in RFC2046.
        /// </remarks>
        public string ContentType { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="IDataElement.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

        #if DEBUG
            if (!Verification.DataElementCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Blob(
            string contentType,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            byte[]? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ContentType = contentType;
            Value = value;
        }
    }

    /// <summary>
    /// A File is a data element that represents an address to a file (a locator).
    /// </summary>
    /// <remarks>
    /// The value is an URI that can represent an absolute or relative path.
    /// </remarks>
    public class File : IDataElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Path and name of the referenced file (with file extension).
        /// </summary>
        /// <remarks>
        /// The path can be absolute or relative.
        /// </remarks>
        public string? Value { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string ContentType { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Return the <see cref="IDataElement.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

        #if DEBUG
            if (!Verification.DataElementCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public File(
            string contentType,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            string? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            ContentType = contentType;
            Value = value;
        }
    }

    /// <summary>
    /// An annotated relationship element is a relationship element that can be annotated
    /// with additional data elements.
    /// </summary>
    public class AnnotatedRelationshipElement : IRelationshipElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public Reference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public Reference Second { get; set; }

        /// <summary>
        /// A data element that represents an annotation that holds for the relationship
        /// between the two elements
        /// </summary>
        public List<IDataElement>? Annotations { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Annotations, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IDataElement> OverAnnotationsOrEmpty()
        {
            return Annotations
                ?? System.Linq.Enumerable.Empty<IDataElement>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return First;

            yield return Second;

            if (Annotations != null)
            {
                foreach (var anItem in Annotations)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return First;

            // Recurse
            foreach (var anItem in First.Descend())
            {
                yield return anItem;
            }

            yield return Second;

            // Recurse
            foreach (var anItem in Second.Descend())
            {
                yield return anItem;
            }

            if (Annotations != null)
            {
                foreach (var anItem in Annotations)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public AnnotatedRelationshipElement(
            Reference first,
            Reference second,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            List<IDataElement>? annotations = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            First = first;
            Second = second;
            Annotations = annotations;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an entity is a self-managed entity or a co-managed
    /// entity.
    /// </summary>
    public enum EntityType
    {
        /// <summary>
        /// For co-managed entities there is no separate AAS. Co-managed entities need to be
        /// part of a self-managed entity.
        /// </summary>
        [EnumMember(Value = "CoManagedEntity")]
        CoManagedEntity,

        /// <summary>
        /// Self-Managed Entities have their own AAS but can be part of the bill of material of
        /// a composite self-managed entity.
        /// </summary>
        /// <remarks>
        /// The asset of an I4.0 Component is a self-managed entity per definition."
        /// </remarks>
        [EnumMember(Value = "SelfManagedEntity")]
        SelfManagedEntity
    }

    /// <summary>
    /// An entity is a submodel element that is used to model entities.
    /// </summary>
    /// <remarks>
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-014:
    ///     Either the attribute <see cref="Aas.Entity.GlobalAssetId" /> or <see cref="Aas.Entity.SpecificAssetId" />
    ///     of an <see cref="Aas.Entity" /> must be set if <see cref="Aas.Entity.EntityType" /> is set to
    ///     <see cref="Aas.EntityType.SelfManagedEntity" />. They are not existing otherwise.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Entity : ISubmodelElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Describes statements applicable to the entity by a set of submodel elements,
        /// typically with a qualified value.
        /// </summary>
        public List<ISubmodelElement>? Statements { get; set; }

        /// <summary>
        /// Describes whether the entity is a co-managed entity or a self-managed entity.
        /// </summary>
        public EntityType EntityType { get; set; }

        /// <summary>
        /// Global identifier of the asset the entity is representing.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public Reference? GlobalAssetId { get; set; }

        /// <summary>
        /// Reference to a specific asset ID representing a supplementary identifier
        /// of the asset represented by the Asset Administration Shell.
        /// </summary>
        public SpecificAssetId? SpecificAssetId { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Statements, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverStatementsOrEmpty()
        {
            return Statements
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Statements != null)
            {
                foreach (var anItem in Statements)
                {
                    yield return anItem;
                }
            }

            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Statements != null)
            {
                foreach (var anItem in Statements)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (GlobalAssetId != null)
            {
                yield return GlobalAssetId;

                // Recurse
                foreach (var anItem in GlobalAssetId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetId != null)
            {
                yield return SpecificAssetId;

                // Recurse
                foreach (var anItem in SpecificAssetId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Entity(
            EntityType entityType,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            List<ISubmodelElement>? statements = null,
            Reference? globalAssetId = null,
            SpecificAssetId? specificAssetId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Statements = statements;
            EntityType = entityType;
            GlobalAssetId = globalAssetId;
            SpecificAssetId = specificAssetId;
        }
    }

    /// <summary>
    /// Direction
    /// </summary>
    public enum Direction
    {
        /// <summary>
        /// Input direction.
        /// </summary>
        [EnumMember(Value = "INPUT")]
        Input,

        /// <summary>
        /// Output direction
        /// </summary>
        [EnumMember(Value = "OUTPUT")]
        Output
    }

    /// <summary>
    /// State of an event
    /// </summary>
    public enum StateOfEvent
    {
        /// <summary>
        /// Event is on
        /// </summary>
        [EnumMember(Value = "ON")]
        On,

        /// <summary>
        /// Event is off.
        /// </summary>
        [EnumMember(Value = "OFF")]
        Off
    }

    /// <summary>
    /// Defines the necessary information of an event instance sent out or received.
    /// </summary>
    public class EventPayload : IClass
    {
        /// <summary>
        /// Reference to the source event element, including identification of
        /// <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" />,
        /// <see cref="Aas.ISubmodelElement" />'s.
        /// </summary>
        public Reference Source { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the source event element, if available
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SourceSemanticId { get; set; }

        /// <summary>
        /// Reference to the referable, which defines the scope of the event.
        /// </summary>
        /// <remarks>
        /// Can be <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" /> or
        /// <see cref="Aas.ISubmodelElement" />.
        /// </remarks>
        public Reference ObservableReference { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the referable which defines the scope of
        /// the event, if available.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? ObservableSemanticId { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to
        /// the respective communication channel.
        /// </summary>
        public string? Topic { get; set; }

        /// <summary>
        /// Subject, who/which initiated the creation.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public Reference? SubjectId { get; set; }

        /// <summary>
        /// Timestamp in UTC, when this event was triggered.
        /// </summary>
        public string TimeStamp { get; set; }

        /// <summary>
        /// Event specific payload.
        /// </summary>
        public string? Payload { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Source;

            if (SourceSemanticId != null)
            {
                yield return SourceSemanticId;
            }

            yield return ObservableReference;

            if (ObservableSemanticId != null)
            {
                yield return ObservableSemanticId;
            }

            if (SubjectId != null)
            {
                yield return SubjectId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Source;

            // Recurse
            foreach (var anItem in Source.Descend())
            {
                yield return anItem;
            }

            if (SourceSemanticId != null)
            {
                yield return SourceSemanticId;

                // Recurse
                foreach (var anItem in SourceSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            yield return ObservableReference;

            // Recurse
            foreach (var anItem in ObservableReference.Descend())
            {
                yield return anItem;
            }

            if (ObservableSemanticId != null)
            {
                yield return ObservableSemanticId;

                // Recurse
                foreach (var anItem in ObservableSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SubjectId != null)
            {
                yield return SubjectId;

                // Recurse
                foreach (var anItem in SubjectId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public EventPayload(
            Reference source,
            Reference observableReference,
            string timeStamp,
            Reference? sourceSemanticId = null,
            Reference? observableSemanticId = null,
            string? topic = null,
            Reference? subjectId = null,
            string? payload = null)
        {
            Source = source;
            ObservableReference = observableReference;
            TimeStamp = timeStamp;
            SourceSemanticId = sourceSemanticId;
            ObservableSemanticId = observableSemanticId;
            Topic = topic;
            SubjectId = subjectId;
            Payload = payload;
        }
    }

    /// <summary>
    /// An event element.
    /// </summary>
    public interface IEventElement : ISubmodelElement
    {
        // Intentionally empty.
    }

    /// <summary>
    /// A basic event element.
    /// </summary>
    public class BasicEventElement : IEventElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to the <see cref="Aas.IReferable" />, which defines the scope of the event.
        /// Can be <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" />, or
        /// <see cref="Aas.ISubmodelElement" />.
        /// </summary>
        /// <remarks>
        /// Reference to a referable, e.g., a data element or
        /// a submodel, that is being observed.
        /// </remarks>
        public Reference Observed { get; set; }

        /// <summary>
        /// Direction of event.
        /// </summary>
        /// <remarks>
        /// Can be <c>{ Input, Output }</c>.
        /// </remarks>
        public Direction Direction { get; set; }

        /// <summary>
        /// State of event.
        /// </summary>
        /// <remarks>
        /// Can be <c>{ On, Off }</c>.
        /// </remarks>
        public StateOfEvent State { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to the
        /// respective communication channel.
        /// </summary>
        public string? MessageTopic { get; set; }

        /// <summary>
        /// Information, which outer message infrastructure shall handle messages for
        /// the <see cref="Aas.IEventElement" />. Refers to a <see cref="Aas.Submodel" />,
        /// <see cref="Aas.SubmodelElementList" />, <see cref="Aas.SubmodelElementCollection" /> or
        /// <see cref="Aas.Entity" />, which contains <see cref="Aas.IDataElement" />'s describing
        /// the proprietary specification for the message broker.
        /// </summary>
        /// <remarks>
        /// For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
        /// proprietary specification could be standardized by having respective Submodels.
        /// </remarks>
        public Reference? MessageBroker { get; set; }

        /// <summary>
        /// Timestamp in UTC, when the last event was received (input direction) or sent
        /// (output direction).
        /// </summary>
        public string? LastUpdate { get; set; }

        /// <summary>
        /// For input direction, reports on the maximum frequency, the software entity behind
        /// the respective Referable can handle input events.
        /// </summary>
        /// <remarks>
        /// For output events, specifies the maximum frequency of outputting this event to
        /// an outer infrastructure.
        ///
        /// Might be not specified, that is, there is no minimum interval.
        /// </remarks>
        public string? MinInterval { get; set; }

        /// <summary>
        /// For input direction: not applicable.
        /// </summary>
        /// <remarks>
        /// For output direction: maximum interval in time, the respective Referable shall send
        /// an update of the status of the event, even if no other trigger condition for
        /// the event was not met.
        ///
        /// Might be not specified, that is, there is no maximum interval
        /// </remarks>
        public string? MaxInterval { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return Observed;

            if (MessageBroker != null)
            {
                yield return MessageBroker;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return Observed;

            // Recurse
            foreach (var anItem in Observed.Descend())
            {
                yield return anItem;
            }

            if (MessageBroker != null)
            {
                yield return MessageBroker;

                // Recurse
                foreach (var anItem in MessageBroker.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public BasicEventElement(
            Reference observed,
            Direction direction,
            StateOfEvent state,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            string? messageTopic = null,
            Reference? messageBroker = null,
            string? lastUpdate = null,
            string? minInterval = null,
            string? maxInterval = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            Observed = observed;
            Direction = direction;
            State = state;
            MessageTopic = messageTopic;
            MessageBroker = messageBroker;
            LastUpdate = lastUpdate;
            MinInterval = minInterval;
            MaxInterval = maxInterval;
        }
    }

    /// <summary>
    /// An operation is a submodel element with input and output variables.
    /// </summary>
    public class Operation : ISubmodelElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Input parameter of the operation.
        /// </summary>
        public List<OperationVariable>? InputVariables { get; set; }

        /// <summary>
        /// Output parameter of the operation.
        /// </summary>
        public List<OperationVariable>? OutputVariables { get; set; }

        /// <summary>
        /// Parameter that is input and output of the operation.
        /// </summary>
        public List<OperationVariable>? InoutputVariables { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over InputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<OperationVariable> OverInputVariablesOrEmpty()
        {
            return InputVariables
                ?? System.Linq.Enumerable.Empty<OperationVariable>();
        }

        /// <summary>
        /// Iterate over OutputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<OperationVariable> OverOutputVariablesOrEmpty()
        {
            return OutputVariables
                ?? System.Linq.Enumerable.Empty<OperationVariable>();
        }

        /// <summary>
        /// Iterate over InoutputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<OperationVariable> OverInoutputVariablesOrEmpty()
        {
            return InoutputVariables
                ?? System.Linq.Enumerable.Empty<OperationVariable>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (InputVariables != null)
            {
                foreach (var anItem in InputVariables)
                {
                    yield return anItem;
                }
            }

            if (OutputVariables != null)
            {
                foreach (var anItem in OutputVariables)
                {
                    yield return anItem;
                }
            }

            if (InoutputVariables != null)
            {
                foreach (var anItem in InoutputVariables)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (InputVariables != null)
            {
                foreach (var anItem in InputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (OutputVariables != null)
            {
                foreach (var anItem in OutputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (InoutputVariables != null)
            {
                foreach (var anItem in InoutputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Operation(
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null,
            List<OperationVariable>? inputVariables = null,
            List<OperationVariable>? outputVariables = null,
            List<OperationVariable>? inoutputVariables = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
            InputVariables = inputVariables;
            OutputVariables = outputVariables;
            InoutputVariables = inoutputVariables;
        }
    }

    /// <summary>
    /// The value of an operation variable is a submodel element that is used as input
    /// and/or output variable of an operation.
    /// </summary>
    public class OperationVariable : IClass
    {
        /// <summary>
        /// Describes an argument or result of an operation via a submodel element
        /// </summary>
        public ISubmodelElement Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Value;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Value;

            // Recurse
            foreach (var anItem in Value.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public OperationVariable(ISubmodelElement value)
        {
            Value = value;
        }
    }

    /// <summary>
    /// A capability is the implementation-independent description of the potential of an
    /// asset to achieve a certain effect in the physical or virtual world.
    /// </summary>
    /// <remarks>
    /// The <see cref="Aas.Capability.SemanticId" /> of a capability is typically an ontology.
    /// Thus, reasoning on capabilities is enabled.
    /// </remarks>
    public class Capability : ISubmodelElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModelingKind.Instance" />
        /// </remarks>
        public ModelingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<Reference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// Constraints:
        /// <ul>
        ///     <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///     </li>
        /// </ul>
        /// </remarks>
        public List<Qualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Qualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<Qualifier>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModelingKind KindOrDefault()
        {
            return Kind ?? ModelingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Capability(
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            ModelingKind? kind = null,
            Reference? semanticId = null,
            List<Reference>? supplementalSemanticIds = null,
            List<Qualifier>? qualifiers = null,
            List<Reference>? dataSpecifications = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            DataSpecifications = dataSpecifications;
        }
    }

    /// <summary>
    /// The semantics of a property or other elements that may have a semantic description
    /// is defined by a concept description.
    /// </summary>
    /// <remarks>
    /// The description of the concept should follow a standardized schema (realized as
    /// data specification template).
    ///
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-051:
    ///     A <see cref="Aas.ConceptDescription" /> shall have one of the following categories
    ///     <c>VALUE</c>, <c>PROPERTY</c>, <c>REFERENCE</c>, <c>DOCUMENT</c>, <c>CAPABILITY</c>,
    ///     <c>RELATIONSHIP</c>, <c>COLLECTION</c>, <c>FUNCTION</c>, <c>EVENT</c>, <c>ENTITY</c>,
    ///     <c>APPLICATION_CLASS</c>, <c>QUALIFIER</c>, <c>VIEW</c>.
    ///
    ///     Default: <c>PROPERTY</c>.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class ConceptDescription :
            IIdentifiable,
            IHasDataSpecification
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<Extension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        /// <remarks>
        /// If no display name is defined in the language requested by the application,
        /// then the display name is selected in the following order if available:
        ///
        /// <ul>
        /// <li>the preferred name in the requested language of the concept description defining
        /// the semantics of the element</li>
        /// <li>If there is a default language list defined in the application,
        /// then the corresponding preferred name in the language is chosen
        /// according to this order.</li>
        /// <li>the English preferred name of the concept description defining
        /// the semantics of the element</li>
        /// <li>the short name of the concept description</li>
        /// <li>the <see cref="Aas.IReferable.IdShort" /> of the element</li>
        /// </ul>
        /// </remarks>
        public LangStringSet? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// The description can be provided in several languages.
        ///
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        ///
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </remarks>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Checksum to be used to determine if an Referable (including its
        /// aggregated child elements) has changed.
        /// </summary>
        /// <remarks>
        /// The checksum is calculated by the user's tool environment.
        /// The checksum has no semantic meaning for an asset administration
        /// shell model and there is no requirement for asset administration
        /// shell tools to manage the checksum
        /// </remarks>
        public string? Checksum { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Global reference to the data specification template used by the element.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public List<Reference>? DataSpecifications { get; set; }

        /// <summary>
        /// Reference to an external definition the concept is compatible to or was derived
        /// from.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        ///
        /// Compare to is-case-of relationship in ISO 13584-32 &amp; IEC EN 61360"
        /// </remarks>
        public List<Reference>? IsCaseOf { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Extension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<Extension>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Iterate over IsCaseOf, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Reference> OverIsCaseOfOrEmpty()
        {
            return IsCaseOf
                ?? System.Linq.Enumerable.Empty<Reference>();
        }

        /// <summary>
        /// Return the <see cref="ConceptDescription.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "PROPERTY";

        #if DEBUG
            if (!Verification.ConceptDescriptionCategoryIsValid(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
        #endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;
            }

            if (Description != null)
            {
                yield return Description;
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (IsCaseOf != null)
            {
                foreach (var anItem in IsCaseOf)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                yield return DisplayName;

                // Recurse
                foreach (var anItem in DisplayName.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (IsCaseOf != null)
            {
                foreach (var anItem in IsCaseOf)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public ConceptDescription(
            string id,
            List<Extension>? extensions = null,
            string? category = null,
            string? idShort = null,
            LangStringSet? displayName = null,
            LangStringSet? description = null,
            string? checksum = null,
            AdministrativeInformation? administration = null,
            List<Reference>? dataSpecifications = null,
            List<Reference>? isCaseOf = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Checksum = checksum;
            Id = id;
            Administration = administration;
            DataSpecifications = dataSpecifications;
            IsCaseOf = isCaseOf;
        }
    }

    /// <summary>
    /// ReferenceTypes
    /// </summary>
    public enum ReferenceTypes
    {
        /// <summary>
        /// GlobalReference.
        /// </summary>
        [EnumMember(Value = "GlobalReference")]
        GlobalReference,

        /// <summary>
        /// ModelReference
        /// </summary>
        [EnumMember(Value = "ModelReference")]
        ModelReference
    }

    /// <summary>
    /// Reference to either a model element of the same or another AAS or to an external
    /// entity.
    /// </summary>
    /// <remarks>
    /// A reference is an ordered list of keys.
    ///
    /// A model reference is an ordered list of keys, each key referencing an element. The
    /// complete list of keys may for example be concatenated to a path that then gives
    /// unique access to an element.
    ///
    /// A global reference is a reference to an external entity.
    ///
    /// Constraints:
    /// <ul>
    ///     <li>
    ///     Constraint AASd-121:
    ///     For <see cref="Aas.Reference" />'s the <see cref="Aas.Key.Type" /> of the first key of
    ///     <see cref="Aas.Reference.Keys" /> shall be one of <see cref="Aas.GloballyIdentifiables" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-122:
    ///     For global references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.GlobalReference" />, the type
    ///     of the first key of <see cref="Aas.Reference.Keys" /> shall be one of
    ///     <see cref="Aas.GenericGloballyIdentifiables" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-123:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, the type
    ///     of the first key of <see cref="Aas.Reference.Keys" /> shall be one of
    ///     <see cref="Aas.AasIdentifiables" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-124:
    ///     For global references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.GlobalReference" />, the last
    ///     key of <see cref="Aas.Reference.Keys" /> shall be either one of
    ///     <see cref="Aas.GenericGloballyIdentifiables" /> or one of
    ///     <see cref="Aas.GenericFragmentKeys" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-125:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> the type of the keys following the first
    ///     key of  <see cref="Aas.Reference.Keys" /> shall be one of <see cref="Aas.FragmentKeys" />.
    ///
    ///     Constraint AASd-125 ensures that the shortest path is used.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-126:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> the type of the last key in the
    ///     reference key chain may be one of <see cref="Aas.GenericFragmentKeys" /> or no key
    ///     at all shall have a value out of <see cref="Aas.GenericFragmentKeys" />.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-127:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> a key with <see cref="Aas.Key.Type" />
    ///     <see cref="Aas.KeyTypes.FragmentReference" /> shall be preceded by a key with
    ///     <see cref="Aas.Key.Type" /> <see cref="Aas.KeyTypes.File" /> or <see cref="Aas.KeyTypes.Blob" />. All other
    ///     AAS fragments, i.e. type values out of <see cref="Aas.AasSubmodelElements" />, do not
    ///     support fragments.
    ///
    ///     Which kind of fragments are supported depends on the content type and the
    ///     specification of allowed fragment identifiers for the corrsponding resource
    ///     being referenced via the reference.
    ///     </li>
    ///     <li>
    ///     Constraint AASd-128:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, the
    ///     <see cref="Aas.Key.Value" /> of a <see cref="Aas.Key" /> preceded by a <see cref="Aas.Key" /> with
    ///     <see cref="Aas.Key.Type" /> = <see cref="Aas.KeyTypes.SubmodelElementList" /> is an integer
    ///     number denoting the position in the array of the submodel element list.
    ///     </li>
    /// </ul>
    /// </remarks>
    public class Reference : IClass
    {
        /// <summary>
        /// Type of the reference.
        /// </summary>
        /// <remarks>
        /// Denotes, whether reference is a global reference or a model reference.
        /// </remarks>
        public ReferenceTypes Type { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the referenced model element
        /// (<see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />).
        /// </summary>
        /// <remarks>
        /// For global references there typically is no semantic ID.
        ///
        /// It is recommended to use a global reference.
        /// </remarks>
        public Reference? ReferredSemanticId { get; set; }

        /// <summary>
        /// Unique references in their name space.
        /// </summary>
        public List<Key> Keys { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;
            }

            foreach (var anItem in Keys)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;

                // Recurse
                foreach (var anItem in ReferredSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Keys)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Reference(
            ReferenceTypes type,
            List<Key> keys,
            Reference? referredSemanticId = null)
        {
            Type = type;
            Keys = keys;
            ReferredSemanticId = referredSemanticId;
        }
    }

    /// <summary>
    /// A key is a reference to an element by its ID.
    /// </summary>
    public class Key : IClass
    {
        /// <summary>
        /// Denotes which kind of entity is referenced.
        /// </summary>
        /// <remarks>
        /// In case <see cref="Aas.Key.Type" /> = <see cref="Aas.KeyTypes.FragmentReference" /> the key represents
        /// a bookmark or a similar local identifier within its parent element as specified
        /// by the key that precedes this key.
        ///
        /// In all other cases the key references a model element of the same or of another AAS.
        /// The name of the model element is explicitly listed.
        /// </remarks>
        public KeyTypes Type { get; set; }

        /// <summary>
        /// The key value, for example an IRDI or an URI
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Key(
            KeyTypes type,
            string value)
        {
            Type = type;
            Value = value;
        }
    }

    /// <summary>
    /// Enumeration of all identifiable elements within an asset administration shell.
    /// </summary>
    public enum GenericFragmentKeys
    {
        /// <summary>
        /// Bookmark or a similar local identifier of a subordinate part of a primary resource
        /// </summary>
        [EnumMember(Value = "FragmentReference")]
        FragmentReference
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum GenericGloballyIdentifiables
    {
        [EnumMember(Value = "GlobalReference")]
        GlobalReference
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum AasIdentifiables
    {
        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        [EnumMember(Value = "Submodel")]
        Submodel
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell.
    /// </summary>
    public enum AasSubmodelElements
    {
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        /// <summary>
        /// Data Element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.AasSubmodelElements.DataElement" />
        /// the reference may be a <see cref="Aas.Property" />, a <see cref="Aas.File" /> etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event element
        /// </summary>
        /// <remarks>
        /// <see cref="Aas.IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, i.e. if a key uses
        /// <see cref="Aas.AasSubmodelElements.SubmodelElement" /> the reference may be a <see cref="Aas.Property" />,
        /// a <see cref="Aas.SubmodelElementList" />, an <see cref="Aas.Operation" /> etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementCollection")]
        SubmodelElementCollection
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell.
    /// </summary>
    public enum AasReferableNonIdentifiables
    {
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        /// <summary>
        /// Data Element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.AasReferableNonIdentifiables.DataElement" />
        /// the reference may be a <see cref="Aas.Property" />, a <see cref="Aas.File" /> etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event element
        /// </summary>
        /// <remarks>
        /// <see cref="Aas.IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, i.e. if a key uses
        /// <see cref="Aas.AasReferableNonIdentifiables.SubmodelElement" /> the reference may be a <see cref="Aas.Property" />,
        /// a <see cref="Aas.SubmodelElementList" />, an <see cref="Aas.Operation" /> etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementCollection")]
        SubmodelElementCollection,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList
    }

    /// <summary>
    /// Enumeration of all referable elements within an asset administration shell
    /// </summary>
    public enum GloballyIdentifiables
    {
        [EnumMember(Value = "GlobalReference")]
        GlobalReference,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        [EnumMember(Value = "Submodel")]
        Submodel
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum FragmentKeys
    {
        /// <summary>
        /// Bookmark or a similar local identifier of a subordinate part of
        /// a primary resource
        /// </summary>
        [EnumMember(Value = "FragmentReference")]
        FragmentReference,

        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.FragmentKeys.DataElement" />
        /// the reference may be a Property, a File etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// <see cref="Aas.IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.FragmentKeys.SubmodelElement" />
        /// the reference may be a <see cref="Aas.Property" />, an <see cref="Aas.Operation" /> etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementCollection")]
        SubmodelElementCollection
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum KeyTypes
    {
        /// <summary>
        /// Bookmark or a similar local identifier of a subordinate part of
        /// a primary resource
        /// </summary>
        [EnumMember(Value = "FragmentReference")]
        FragmentReference,

        [EnumMember(Value = "GlobalReference")]
        GlobalReference,

        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.KeyTypes.DataElement" />
        /// the reference may be a Property, a File etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// <see cref="Aas.IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        [EnumMember(Value = "Referable")]
        Referable,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.KeyTypes.SubmodelElement" />
        /// the reference may be a <see cref="Aas.Property" />, an <see cref="Aas.Operation" /> etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementCollection")]
        SubmodelElementCollection
    }

    /// <summary>
    /// Enumeration listing all xsd anySimpleTypes
    /// </summary>
    public enum DataTypeDefXsd
    {
        [EnumMember(Value = "xs:anyURI")]
        AnyUri,

        [EnumMember(Value = "xs:base64Binary")]
        Base64Binary,

        [EnumMember(Value = "xs:boolean")]
        Boolean,

        [EnumMember(Value = "xs:date")]
        Date,

        [EnumMember(Value = "xs:dateTime")]
        DateTime,

        [EnumMember(Value = "xs:dateTimeStamp")]
        DateTimeStamp,

        [EnumMember(Value = "xs:decimal")]
        Decimal,

        [EnumMember(Value = "xs:double")]
        Double,

        [EnumMember(Value = "xs:duration")]
        Duration,

        [EnumMember(Value = "xs:float")]
        Float,

        [EnumMember(Value = "xs:gDay")]
        GDay,

        [EnumMember(Value = "xs:gMonth")]
        GMonth,

        [EnumMember(Value = "xs:gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "xs:gYear")]
        GYear,

        [EnumMember(Value = "xs:gYearMonth")]
        GYearMonth,

        [EnumMember(Value = "xs:hexBinary")]
        HexBinary,

        [EnumMember(Value = "xs:string")]
        String,

        [EnumMember(Value = "xs:time")]
        Time,

        [EnumMember(Value = "xs:dayTimeDuration")]
        DayTimeDuration,

        [EnumMember(Value = "xs:yearMonthDuration")]
        YearMonthDuration,

        [EnumMember(Value = "xs:integer")]
        Integer,

        [EnumMember(Value = "xs:long")]
        Long,

        [EnumMember(Value = "xs:int")]
        Int,

        [EnumMember(Value = "xs:short")]
        Short,

        [EnumMember(Value = "xs:byte")]
        Byte,

        [EnumMember(Value = "xs:NonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "xs:positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "xs:unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "xs:unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "xs:unsignedShort")]
        UnsignedShort,

        [EnumMember(Value = "xs:unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "xs:nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "xs:negativeInteger")]
        NegativeInteger
    }

    /// <summary>
    /// Enumeration listing all RDF types
    /// </summary>
    public enum DataTypeDefRdf
    {
        /// <summary>
        /// String with a language tag
        /// </summary>
        /// <remarks>
        /// RDF requires IETF BCP 47  language tags, i.e. simple two-letter language tags
        /// for Locales like “de” conformant to ISO 639-1 are allowed as well as language
        /// tags plus extension like “de-DE” for country code, dialect etc. like in “en-US”
        /// or “en-GB” for English (United Kingdom) and English (United States).
        /// IETF language tags are referencing ISO 639, ISO 3166 and ISO 15924.
        /// </remarks>
        [EnumMember(Value = "rdf:langString")]
        LangString
    }

    /// <summary>
    /// string with values of enumerations <see cref="Aas.DataTypeDefXsd" />,
    /// <see cref="Aas.DataTypeDefRdf" />
    /// </summary>
    public enum DataTypeDef
    {
        [EnumMember(Value = "xs:anyURI")]
        AnyUri,

        [EnumMember(Value = "xs:base64Binary")]
        Base64Binary,

        [EnumMember(Value = "xs:boolean")]
        Boolean,

        [EnumMember(Value = "xs:date")]
        Date,

        [EnumMember(Value = "xs:dateTime")]
        DateTime,

        [EnumMember(Value = "xs:dateTimeStamp")]
        DateTimeStamp,

        [EnumMember(Value = "xs:decimal")]
        Decimal,

        [EnumMember(Value = "xs:double")]
        Double,

        [EnumMember(Value = "xs:duration")]
        Duration,

        [EnumMember(Value = "xs:float")]
        Float,

        [EnumMember(Value = "xs:gDay")]
        GDay,

        [EnumMember(Value = "xs:gMonth")]
        GMonth,

        [EnumMember(Value = "xs:gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "xs:gYear")]
        GYear,

        [EnumMember(Value = "xs:gYearMonth")]
        GYearMonth,

        [EnumMember(Value = "xs:hexBinary")]
        HexBinary,

        [EnumMember(Value = "xs:string")]
        String,

        [EnumMember(Value = "xs:time")]
        Time,

        [EnumMember(Value = "xs:dayTimeDuration")]
        DayTimeDuration,

        [EnumMember(Value = "xs:yearMonthDuration")]
        YearMonthDuration,

        [EnumMember(Value = "xs:integer")]
        Integer,

        [EnumMember(Value = "xs:long")]
        Long,

        [EnumMember(Value = "xs:int")]
        Int,

        [EnumMember(Value = "xs:short")]
        Short,

        [EnumMember(Value = "xs:byte")]
        Byte,

        [EnumMember(Value = "xs:NonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "xs:positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "xs:unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "xs:unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "xs:unsignedShort")]
        UnsignedShort,

        [EnumMember(Value = "xs:unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "xs:nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "xs:negativeInteger")]
        NegativeInteger,

        [EnumMember(Value = "rdf:langString")]
        LangString
    }

    /// <summary>
    /// Strings with language tags
    /// </summary>
    public class LangString : IClass
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.LangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public LangString(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// Array of elements of type langString
    /// </summary>
    /// <remarks>
    /// langString is a RDF data type.
    ///
    /// A langString is a string value tagged with a language code.
    /// It depends on the serialization rules for a technology how
    /// this is realized.
    /// </remarks>
    public class LangStringSet : IClass
    {
        /// <summary>
        /// Strings in different languages
        /// </summary>
        public List<LangString> LangStrings { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in LangStrings)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in LangStrings)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public LangStringSet(List<LangString> langStrings)
        {
            LangStrings = langStrings;
        }
    }

    /// <summary>
    /// Data specification content is part of a data specification template and defines
    /// which additional attributes shall be added to the element instance that references
    /// the data specification template and meta information about the template itself.
    /// </summary>
    public class DataSpecificationContent : IClass
    {
        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }
    }

    /// <summary>
    /// Data Specification Template
    /// </summary>
    public class DataSpecification : IClass
    {
        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// The content of the template without meta data
        /// </summary>
        public DataSpecificationContent DataSpecificationContent { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public AdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// Description how and in which context the data specification template is applicable.
        /// The description can be provided in several languages.
        /// </summary>
        public LangStringSet? Description { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return DataSpecificationContent;

            if (Administration != null)
            {
                yield return Administration;
            }

            if (Description != null)
            {
                yield return Description;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return DataSpecificationContent;

            // Recurse
            foreach (var anItem in DataSpecificationContent.Descend())
            {
                yield return anItem;
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                yield return Description;

                // Recurse
                foreach (var anItem in Description.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public DataSpecification(
            string id,
            DataSpecificationContent dataSpecificationContent,
            AdministrativeInformation? administration,
            LangStringSet? description)
        {
            Id = id;
            DataSpecificationContent = dataSpecificationContent;
            Administration = administration;
            Description = description;
        }
    }

    /// <summary>
    /// Container for the sets of different identifiables.
    /// </summary>
    /// <remarks>
    /// w.r.t. file exchange: There is exactly one environment independent on how many
    /// files the contained elements are split. If the file is split then there
    /// shall be no element with the same identifier in two different files.
    /// </remarks>
    public class Environment : IClass
    {
        /// <summary>
        /// Asset administration shell
        /// </summary>
        public List<AssetAdministrationShell>? AssetAdministrationShells { get; set; }

        /// <summary>
        /// Submodel
        /// </summary>
        public List<Submodel>? Submodels { get; set; }

        /// <summary>
        /// Concept description
        /// </summary>
        public List<ConceptDescription>? ConceptDescriptions { get; set; }

        /// <summary>
        /// Data specification
        /// </summary>
        public List<DataSpecification>? DataSpecifications { get; set; }

        /// <summary>
        /// Iterate over AssetAdministrationShells, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<AssetAdministrationShell> OverAssetAdministrationShellsOrEmpty()
        {
            return AssetAdministrationShells
                ?? System.Linq.Enumerable.Empty<AssetAdministrationShell>();
        }

        /// <summary>
        /// Iterate over Submodels, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<Submodel> OverSubmodelsOrEmpty()
        {
            return Submodels
                ?? System.Linq.Enumerable.Empty<Submodel>();
        }

        /// <summary>
        /// Iterate over ConceptDescriptions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ConceptDescription> OverConceptDescriptionsOrEmpty()
        {
            return ConceptDescriptions
                ?? System.Linq.Enumerable.Empty<ConceptDescription>();
        }

        /// <summary>
        /// Iterate over DataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<DataSpecification> OverDataSpecificationsOrEmpty()
        {
            return DataSpecifications
                ?? System.Linq.Enumerable.Empty<DataSpecification>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (AssetAdministrationShells != null)
            {
                foreach (var anItem in AssetAdministrationShells)
                {
                    yield return anItem;
                }
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;
                }
            }

            if (ConceptDescriptions != null)
            {
                foreach (var anItem in ConceptDescriptions)
                {
                    yield return anItem;
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (AssetAdministrationShells != null)
            {
                foreach (var anItem in AssetAdministrationShells)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ConceptDescriptions != null)
            {
                foreach (var anItem in ConceptDescriptions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DataSpecifications != null)
            {
                foreach (var anItem in DataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.Visit(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.Visit(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.Transform(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.Transform(this, context);
        }

        public Environment(
            List<AssetAdministrationShell>? assetAdministrationShells = null,
            List<Submodel>? submodels = null,
            List<ConceptDescription>? conceptDescriptions = null,
            List<DataSpecification>? dataSpecifications = null)
        {
            AssetAdministrationShells = assetAdministrationShells;
            Submodels = submodels;
            ConceptDescriptions = conceptDescriptions;
            DataSpecifications = dataSpecifications;
        }
    }

}  // namespace AasCore.Aas3_0_RC02

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
