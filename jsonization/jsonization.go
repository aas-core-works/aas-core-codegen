// De/serialize instances of AAS classes to and from JSON.
//
// We can not use one-pass deserialization for JSON since the object
// properties do not have fixed order, and hence we can not read
// `modelType` property ahead of the remaining properties.
//
// To de-serialize, call one of the `*FromJsonable` functions.
//
// To serialize, call [ToJsonable] function.

package jsonization

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	"fmt"
	"math"
	b64 "encoding/base64"
	aasreporting "github.com/aas-core-works/aas-core3.0-golang/reporting"
	aasstringification "github.com/aas-core-works/aas-core3.0-golang/stringification"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
)

// region De-serialization

// Represent an error during the de-serialization.
//
// Implements `error`.
type DeserializationError struct{
	Path *aasreporting.Path,
	Message string
}

func newDeserializationError(message string) *DeserializationError {
	return &DeserializationError{
		Path &aasreporting.Path{},
		Message message
	}
}

func (de *DeserializationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		de.PathString(),
		de.Message
	)
}

// Render the path as a string.
func (de *DeserializationError) PathString() string {
	return aasreporting.ToJSONPath(de.Path)
}

// Parse `jsonable` as a boolean, or return an error.
func boolFromJsonable(
	jsonable interface{}
) (result bool, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a boolean, but got null"
		)
		return
	}

	var ok bool
	result, ok = jsonable.(bool)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf("Expected a boolean, but got %T", jsonable)
		)

		return    
	}
}

// Parse `jsonable` as a 64-bit integer, or return an error.
func int64FromJsonable(
	jsonable interface{}
) (result int64, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected an integer number, but got null"
		)
		return
	}

	var ok bool
	f, ok = jsonable.(float64)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected an integer number, but got %T", 
				jsonable
			)
		)
		return
	}

	if math.IsNaN(f) {
		err = newDeserializationError(
			"Expected an integer number, but got a NaN"
		)
		return
	}

	if math.IsInf(f, 0) {
		err = newDeserializationError(
			"Expected an integer number, but got an infinity"
		)
		return
	}

	if f != math.Trunc(f) {
		err = newDeserializationError(
			fmt.Printf(
				"Expected an integer number, but got a non-integer: %v", 
				f
			)
		)
		return
	}

	result = int64(f) 
	if f != float64(result) {
		err = newDeserializationError(
			fmt.Printf(
				"Expected an integer number fitting into int64, but got: %v", 
				jsonable
			)
		)
		return
	}

	return
}

// Parse `jsonable` as a 64-bit float, or return an error.
func float64FromJsonable(
	jsonable interface{}
) (result float64, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a number, but got null"
		)
		return
	}

	var ok bool
	result, ok = jsonable.(float64)
	if !ok {
		error = newDeserializationError(
			fmt.Sprintf(
				"Expected a number, but got %T", 
				jsonable
			)
		)
		return    
	}

	return
}

// Parse `jsonable` as a string, or return an error.
func stringFromJsonable(
	jsonable interface{}
) (result string, error *DeserializationError) {
	if jsonable == nil {
		error = newDeserializationError(
			"Expected a string, but got null"
		)
		return
	}

	var ok bool
	result, ok = jsonable.(string)
	if ok {
		return
	} else {
		error = newDeserializationError(
			fmt.Sprintf("Expected a boolean, but got %T", jsonable)
		)
		return    
	}
}

// Parse `jsonable` as a byte array, or return an error.
func bytesFromJsonable(
	jsonable interface{}
) (result []byte, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a base64-encoded string, but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a base64-encoded string, but got %T", 
				jsonable
			)
		)
		return
	}

	var decodingErr error
	result, decodingErr = b64.StdEncoding.DecodeString(text)
	if decodingErr != nil {
		err = newDeserializationError(
			fmt.Sprintf(
				"String could not be decoded as base64: %s", 
				decodingErr.Error()
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasSemantics],
// or return an error.
func HasSemanticsFromJsonable(
	jsonable interface{}
) (
	result aastypes.IHasSemantics,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IHasSemantics, 
		&DeserializationError)
		fromMap, ok = DispatchHasSemanticsFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IHasSemantics: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IExtension],
// or return an error.
func ExtensionFromJsonable(
	jsonable interface{}
) (
	result aastypes.IExtension,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = extensionFromMap(m)
}

// Parse [aastypes.IExtension] from a map,
// or return an error, if any.
func extensionFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IExtension,
	err *DeserializationError,
) {
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theName string
	var theValueType *DataTypeDefXSD
	var theValue *string
	var theRefersTo []IReference

	foundName := false

	for k, v := range jsonable {
		switch k {
		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "name":
			theName, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "name"
					}
				)
				return
			}
			foundName = true

		case "valueType":
			theValueType, err := DataTypeDefXSDFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType"
					}
				)
				return
			}
			theValueType = &theValueType

		case "value":
			theValue, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			theValue = &theValue

		case "refersTo":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "refersTo"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "refersTo"
						}
					)

					return
				}

				array = append(array, item)
			}
			theRefersTo = array

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundName {
		err = newDeserializationError(
			"The required property 'name' is missing"
		)
		return
	}

	result = NewExtension(
		theName
	)
	result.name = theName

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasExtensions],
// or return an error.
func HasExtensionsFromJsonable(
	jsonable interface{}
) (
	result aastypes.IHasExtensions,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IHasExtensions, 
		&DeserializationError)
		fromMap, ok = DispatchHasExtensionsFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IHasExtensions: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IReferable],
// or return an error.
func ReferableFromJsonable(
	jsonable interface{}
) (
	result aastypes.IReferable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IReferable, 
		&DeserializationError)
		fromMap, ok = DispatchReferableFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IReferable: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IIdentifiable],
// or return an error.
func IdentifiableFromJsonable(
	jsonable interface{}
) (
	result aastypes.IIdentifiable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IIdentifiable, 
		&DeserializationError)
		fromMap, ok = DispatchIdentifiableFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IIdentifiable: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as a literal of [aastypes.ModellingKind],
// or return an error.
func ModellingKindFromJsonable(
	jsonable interface{}
) (result aastypes.ModellingKind, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of ModellingKind, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ModellingKind, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.ModellingKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ModellingKind, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IHasKind],
// or return an error.
func HasKindFromJsonable(
	jsonable interface{}
) (
	result aastypes.IHasKind,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IHasKind, 
		&DeserializationError)
		fromMap, ok = DispatchHasKindFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IHasKind: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IHasDataSpecification],
// or return an error.
func HasDataSpecificationFromJsonable(
	jsonable interface{}
) (
	result aastypes.IHasDataSpecification,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IHasDataSpecification, 
		&DeserializationError)
		fromMap, ok = DispatchHasDataSpecificationFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IHasDataSpecification: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IAdministrativeInformation],
// or return an error.
func AdministrativeInformationFromJsonable(
	jsonable interface{}
) (
	result aastypes.IAdministrativeInformation,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = administrativeInformationFromMap(m)
}

// Parse [aastypes.IAdministrativeInformation] from a map,
// or return an error, if any.
func administrativeInformationFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IAdministrativeInformation,
	err *DeserializationError,
) {
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theVersion *string
	var theRevision *string
	var theCreator IReference
	var theTemplateID *string



	for k, v := range jsonable {
		switch k {
		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "version":
			theVersion, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "version"
					}
				)
				return
			}
			theVersion = &theVersion

		case "revision":
			theRevision, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "revision"
					}
				)
				return
			}
			theRevision = &theRevision

		case "creator":
			theCreator, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "creator"
					}
				)
				return
			}

		case "templateId":
			theTemplateID, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "templateId"
					}
				)
				return
			}
			theTemplateID = &theTemplateID

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewAdministrativeInformation()

	return
}

// Parse `jsonable` as an instance of [aastypes.IQualifiable],
// or return an error.
func QualifiableFromJsonable(
	jsonable interface{}
) (
	result aastypes.IQualifiable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IQualifiable, 
		&DeserializationError)
		fromMap, ok = DispatchQualifiableFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IQualifiable: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as a literal of [aastypes.QualifierKind],
// or return an error.
func QualifierKindFromJsonable(
	jsonable interface{}
) (result aastypes.QualifierKind, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of QualifierKind, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of QualifierKind, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.QualifierKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of QualifierKind, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IQualifier],
// or return an error.
func QualifierFromJsonable(
	jsonable interface{}
) (
	result aastypes.IQualifier,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = qualifierFromMap(m)
}

// Parse [aastypes.IQualifier] from a map,
// or return an error, if any.
func qualifierFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IQualifier,
	err *DeserializationError,
) {
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theKind *QualifierKind
	var theType string
	var theValueType DataTypeDefXSD
	var theValue *string
	var theValueID IReference

	foundType := false
	foundValueType := false

	for k, v := range jsonable {
		switch k {
		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "kind":
			theKind, err := QualifierKindFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "kind"
					}
				)
				return
			}
			theKind = &theKind

		case "type":
			theType, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "type"
					}
				)
				return
			}
			foundType = true

		case "valueType":
			theValueType, err = DataTypeDefXSDFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType"
					}
				)
				return
			}
			foundValueType = true

		case "value":
			theValue, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			theValue = &theValue

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId"
					}
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing"
		)
		return
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing"
		)
		return
	}

	result = NewQualifier(
		theType,
		theValueType
	)
	result.typE = theType
	result.valueType = theValueType

	return
}

// Parse `jsonable` as an instance of [aastypes.IAssetAdministrationShell],
// or return an error.
func AssetAdministrationShellFromJsonable(
	jsonable interface{}
) (
	result aastypes.IAssetAdministrationShell,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = assetAdministrationShellFromMap(m)
}

// Parse [aastypes.IAssetAdministrationShell] from a map,
// or return an error, if any.
func assetAdministrationShellFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IAssetAdministrationShell,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theAdministration IAdministrativeInformation
	var theID string
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theDerivedFrom IReference
	var theAssetInformation IAssetInformation
	var theSubmodels []IReference

	foundID := false
	foundAssetInformation := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "administration":
			theAdministration, err = AdministrativeInformationFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "administration"
					}
				)
				return
			}

		case "id":
			theID, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "id"
					}
				)
				return
			}
			foundID = true

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "derivedFrom":
			theDerivedFrom, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "derivedFrom"
					}
				)
				return
			}

		case "assetInformation":
			theAssetInformation, err = AssetInformationFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetInformation"
					}
				)
				return
			}
			foundAssetInformation = true

		case "submodels":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "submodels"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "submodels"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSubmodels = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing"
		)
		return
	}

	if !foundAssetInformation {
		err = newDeserializationError(
			"The required property 'assetInformation' is missing"
		)
		return
	}

	result = NewAssetAdministrationShell(
		theID,
		theAssetInformation
	)
	result.id = theID
	result.assetInformation = theAssetInformation

	return
}

// Parse `jsonable` as an instance of [aastypes.IAssetInformation],
// or return an error.
func AssetInformationFromJsonable(
	jsonable interface{}
) (
	result aastypes.IAssetInformation,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = assetInformationFromMap(m)
}

// Parse [aastypes.IAssetInformation] from a map,
// or return an error, if any.
func assetInformationFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IAssetInformation,
	err *DeserializationError,
) {
	var theAssetKind AssetKind
	var theGlobalAssetID *string
	var theSpecificAssetIDs []ISpecificAssetID
	var theAssetType *string
	var theDefaultThumbnail IResource

	foundAssetKind := false

	for k, v := range jsonable {
		switch k {
		case "assetKind":
			theAssetKind, err = AssetKindFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetKind"
					}
				)
				return
			}
			foundAssetKind = true

		case "globalAssetId":
			theGlobalAssetID, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "globalAssetId"
					}
				)
				return
			}
			theGlobalAssetID = &theGlobalAssetID

		case "specificAssetIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "specificAssetIds"
					}
				)

				return
			}

			array := make(
				[]ISpecificAssetID,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISpecificAssetID
				item, err = SpecificAssetIDFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "specificAssetIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSpecificAssetIDs = array

		case "assetType":
			theAssetType, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetType"
					}
				)
				return
			}
			theAssetType = &theAssetType

		case "defaultThumbnail":
			theDefaultThumbnail, err = ResourceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "defaultThumbnail"
					}
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundAssetKind {
		err = newDeserializationError(
			"The required property 'assetKind' is missing"
		)
		return
	}

	result = NewAssetInformation(
		theAssetKind
	)
	result.assetKind = theAssetKind

	return
}

// Parse `jsonable` as an instance of [aastypes.IResource],
// or return an error.
func ResourceFromJsonable(
	jsonable interface{}
) (
	result aastypes.IResource,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = resourceFromMap(m)
}

// Parse [aastypes.IResource] from a map,
// or return an error, if any.
func resourceFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IResource,
	err *DeserializationError,
) {
	var thePath string
	var theContentType *string

	foundPath := false

	for k, v := range jsonable {
		switch k {
		case "path":
			thePath, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "path"
					}
				)
				return
			}
			foundPath = true

		case "contentType":
			theContentType, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "contentType"
					}
				)
				return
			}
			theContentType = &theContentType

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundPath {
		err = newDeserializationError(
			"The required property 'path' is missing"
		)
		return
	}

	result = NewResource(
		thePath
	)
	result.path = thePath

	return
}

// Parse `jsonable` as a literal of [aastypes.AssetKind],
// or return an error.
func AssetKindFromJsonable(
	jsonable interface{}
) (result aastypes.AssetKind, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of AssetKind, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AssetKind, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.AssetKindFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AssetKind, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.ISpecificAssetID],
// or return an error.
func SpecificAssetIDFromJsonable(
	jsonable interface{}
) (
	result aastypes.ISpecificAssetID,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = specificAssetIDFromMap(m)
}

// Parse [aastypes.ISpecificAssetID] from a map,
// or return an error, if any.
func specificAssetIDFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ISpecificAssetID,
	err *DeserializationError,
) {
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theName string
	var theValue string
	var theExternalSubjectID IReference

	foundName := false
	foundValue := false

	for k, v := range jsonable {
		switch k {
		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "name":
			theName, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "name"
					}
				)
				return
			}
			foundName = true

		case "value":
			theValue, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			foundValue = true

		case "externalSubjectId":
			theExternalSubjectID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "externalSubjectId"
					}
				)
				return
			}

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundName {
		err = newDeserializationError(
			"The required property 'name' is missing"
		)
		return
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing"
		)
		return
	}

	result = NewSpecificAssetID(
		theName,
		theValue
	)
	result.name = theName
	result.value = theValue

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodel],
// or return an error.
func SubmodelFromJsonable(
	jsonable interface{}
) (
	result aastypes.ISubmodel,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = submodelFromMap(m)
}

// Parse [aastypes.ISubmodel] from a map,
// or return an error, if any.
func submodelFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ISubmodel,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theAdministration IAdministrativeInformation
	var theID string
	var theKind *ModellingKind
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theSubmodelElements []ISubmodelElement

	foundID := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "administration":
			theAdministration, err = AdministrativeInformationFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "administration"
					}
				)
				return
			}

		case "id":
			theID, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "id"
					}
				)
				return
			}
			foundID = true

		case "kind":
			theKind, err := ModellingKindFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "kind"
					}
				)
				return
			}
			theKind = &theKind

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "submodelElements":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "submodelElements"
					}
				)

				return
			}

			array := make(
				[]ISubmodelElement,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "submodelElements"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSubmodelElements = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing"
		)
		return
	}

	result = NewSubmodel(
		theID
	)
	result.id = theID

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodelElement],
// or return an error.
func SubmodelElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.ISubmodelElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.ISubmodelElement, 
		&DeserializationError)
		fromMap, ok = DispatchSubmodelElementFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for ISubmodelElement: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IRelationshipElement],
// or return an error.
func RelationshipElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.IRelationshipElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IRelationshipElement, 
		&DeserializationError)
		fromMap, ok = DispatchRelationshipElementFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IRelationshipElement: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse [aastypes.IRelationshipElement] from a map,
// or return an error, if any.
//
// This function performs no dispatch! It is used to parse the properties
// as-are, and already assumes the exact model type. Usually, this function
// is called from within a from-jsonable function, and you never call it
// directly. If you want to de-serialize an instance of
// [aastypes.IRelationshipElement], call
// [RelationshipElementFromJsonable].
func relationshipElementFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IRelationshipElement,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theFirst IReference
	var theSecond IReference

	foundFirst := false
	foundSecond := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "first":
			theFirst, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "first"
					}
				)
				return
			}
			foundFirst = true

		case "second":
			theSecond, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "second"
					}
				)
				return
			}
			foundSecond = true

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundFirst {
		err = newDeserializationError(
			"The required property 'first' is missing"
		)
		return
	}

	if !foundSecond {
		err = newDeserializationError(
			"The required property 'second' is missing"
		)
		return
	}

	result = NewRelationshipElement(
		theFirst,
		theSecond
	)
	result.first = theFirst
	result.second = theSecond

	return
}

// Parse `jsonable` as a literal of [aastypes.AASSubmodelElements],
// or return an error.
func AASSubmodelElementsFromJsonable(
	jsonable interface{}
) (result aastypes.AASSubmodelElements, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of AASSubmodelElements, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AASSubmodelElements, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.AASSubmodelElementsFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of AASSubmodelElements, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodelElementList],
// or return an error.
func SubmodelElementListFromJsonable(
	jsonable interface{}
) (
	result aastypes.ISubmodelElementList,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = submodelElementListFromMap(m)
}

// Parse [aastypes.ISubmodelElementList] from a map,
// or return an error, if any.
func submodelElementListFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ISubmodelElementList,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theOrderRelevant *bool
	var theSemanticIDListElement IReference
	var theTypeValueListElement AASSubmodelElements
	var theValueTypeListElement *DataTypeDefXSD
	var theValue []ISubmodelElement

	foundTypeValueListElement := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "orderRelevant":
			theOrderRelevant, err := boolFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "orderRelevant"
					}
				)
				return
			}
			theOrderRelevant = &theOrderRelevant

		case "semanticIdListElement":
			theSemanticIDListElement, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticIdListElement"
					}
				)
				return
			}

		case "typeValueListElement":
			theTypeValueListElement, err = AASSubmodelElementsFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "typeValueListElement"
					}
				)
				return
			}
			foundTypeValueListElement = true

		case "valueTypeListElement":
			theValueTypeListElement, err := DataTypeDefXSDFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueTypeListElement"
					}
				)
				return
			}
			theValueTypeListElement = &theValueTypeListElement

		case "value":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)

				return
			}

			array := make(
				[]ISubmodelElement,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "value"
						}
					)

					return
				}

				array = append(array, item)
			}
			theValue = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundTypeValueListElement {
		err = newDeserializationError(
			"The required property 'typeValueListElement' is missing"
		)
		return
	}

	result = NewSubmodelElementList(
		theTypeValueListElement
	)
	result.typeValueListElement = theTypeValueListElement

	return
}

// Parse `jsonable` as an instance of [aastypes.ISubmodelElementCollection],
// or return an error.
func SubmodelElementCollectionFromJsonable(
	jsonable interface{}
) (
	result aastypes.ISubmodelElementCollection,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = submodelElementCollectionFromMap(m)
}

// Parse [aastypes.ISubmodelElementCollection] from a map,
// or return an error, if any.
func submodelElementCollectionFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ISubmodelElementCollection,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValue []ISubmodelElement



	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "value":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)

				return
			}

			array := make(
				[]ISubmodelElement,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "value"
						}
					)

					return
				}

				array = append(array, item)
			}
			theValue = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewSubmodelElementCollection()

	return
}

// Parse `jsonable` as an instance of [aastypes.IDataElement],
// or return an error.
func DataElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.IDataElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IDataElement, 
		&DeserializationError)
		fromMap, ok = DispatchDataElementFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IDataElement: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IProperty],
// or return an error.
func PropertyFromJsonable(
	jsonable interface{}
) (
	result aastypes.IProperty,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = propertyFromMap(m)
}

// Parse [aastypes.IProperty] from a map,
// or return an error, if any.
func propertyFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IProperty,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValueType DataTypeDefXSD
	var theValue *string
	var theValueID IReference

	foundValueType := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "valueType":
			theValueType, err = DataTypeDefXSDFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType"
					}
				)
				return
			}
			foundValueType = true

		case "value":
			theValue, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			theValue = &theValue

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId"
					}
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing"
		)
		return
	}

	result = NewProperty(
		theValueType
	)
	result.valueType = theValueType

	return
}

// Parse `jsonable` as an instance of [aastypes.IMultiLanguageProperty],
// or return an error.
func MultiLanguagePropertyFromJsonable(
	jsonable interface{}
) (
	result aastypes.IMultiLanguageProperty,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = multiLanguagePropertyFromMap(m)
}

// Parse [aastypes.IMultiLanguageProperty] from a map,
// or return an error, if any.
func multiLanguagePropertyFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IMultiLanguageProperty,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValue []ILangStringTextType
	var theValueID IReference



	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "value":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "value"
						}
					)

					return
				}

				array = append(array, item)
			}
			theValue = array

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId"
					}
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewMultiLanguageProperty()

	return
}

// Parse `jsonable` as an instance of [aastypes.IRange],
// or return an error.
func RangeFromJsonable(
	jsonable interface{}
) (
	result aastypes.IRange,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = rangeFromMap(m)
}

// Parse [aastypes.IRange] from a map,
// or return an error, if any.
func rangeFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IRange,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValueType DataTypeDefXSD
	var theMin *string
	var theMax *string

	foundValueType := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "valueType":
			theValueType, err = DataTypeDefXSDFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueType"
					}
				)
				return
			}
			foundValueType = true

		case "min":
			theMin, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "min"
					}
				)
				return
			}
			theMin = &theMin

		case "max":
			theMax, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "max"
					}
				)
				return
			}
			theMax = &theMax

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundValueType {
		err = newDeserializationError(
			"The required property 'valueType' is missing"
		)
		return
	}

	result = NewRange(
		theValueType
	)
	result.valueType = theValueType

	return
}

// Parse `jsonable` as an instance of [aastypes.IReferenceElement],
// or return an error.
func ReferenceElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.IReferenceElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = referenceElementFromMap(m)
}

// Parse [aastypes.IReferenceElement] from a map,
// or return an error, if any.
func referenceElementFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IReferenceElement,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValue IReference



	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "value":
			theValue, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewReferenceElement()

	return
}

// Parse `jsonable` as an instance of [aastypes.IBlob],
// or return an error.
func BlobFromJsonable(
	jsonable interface{}
) (
	result aastypes.IBlob,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = blobFromMap(m)
}

// Parse [aastypes.IBlob] from a map,
// or return an error, if any.
func blobFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IBlob,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValue []byte
	var theContentType string

	foundContentType := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "value":
			theValue, err := bytesFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			theValue = &theValue

		case "contentType":
			theContentType, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "contentType"
					}
				)
				return
			}
			foundContentType = true

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundContentType {
		err = newDeserializationError(
			"The required property 'contentType' is missing"
		)
		return
	}

	result = NewBlob(
		theContentType
	)
	result.contentType = theContentType

	return
}

// Parse `jsonable` as an instance of [aastypes.IFile],
// or return an error.
func FileFromJsonable(
	jsonable interface{}
) (
	result aastypes.IFile,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = fileFromMap(m)
}

// Parse [aastypes.IFile] from a map,
// or return an error, if any.
func fileFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IFile,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theValue *string
	var theContentType string

	foundContentType := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "value":
			theValue, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			theValue = &theValue

		case "contentType":
			theContentType, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "contentType"
					}
				)
				return
			}
			foundContentType = true

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundContentType {
		err = newDeserializationError(
			"The required property 'contentType' is missing"
		)
		return
	}

	result = NewFile(
		theContentType
	)
	result.contentType = theContentType

	return
}

// Parse `jsonable` as an instance of [aastypes.IAnnotatedRelationshipElement],
// or return an error.
func AnnotatedRelationshipElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.IAnnotatedRelationshipElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = annotatedRelationshipElementFromMap(m)
}

// Parse [aastypes.IAnnotatedRelationshipElement] from a map,
// or return an error, if any.
func annotatedRelationshipElementFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IAnnotatedRelationshipElement,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theFirst IReference
	var theSecond IReference
	var theAnnotations []IDataElement

	foundFirst := false
	foundSecond := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "first":
			theFirst, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "first"
					}
				)
				return
			}
			foundFirst = true

		case "second":
			theSecond, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "second"
					}
				)
				return
			}
			foundSecond = true

		case "annotations":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "annotations"
					}
				)

				return
			}

			array := make(
				[]IDataElement,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IDataElement
				item, err = DataElementFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "annotations"
						}
					)

					return
				}

				array = append(array, item)
			}
			theAnnotations = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundFirst {
		err = newDeserializationError(
			"The required property 'first' is missing"
		)
		return
	}

	if !foundSecond {
		err = newDeserializationError(
			"The required property 'second' is missing"
		)
		return
	}

	result = NewAnnotatedRelationshipElement(
		theFirst,
		theSecond
	)
	result.first = theFirst
	result.second = theSecond

	return
}

// Parse `jsonable` as an instance of [aastypes.IEntity],
// or return an error.
func EntityFromJsonable(
	jsonable interface{}
) (
	result aastypes.IEntity,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = entityFromMap(m)
}

// Parse [aastypes.IEntity] from a map,
// or return an error, if any.
func entityFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IEntity,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theStatements []ISubmodelElement
	var theEntityType EntityType
	var theGlobalAssetID *string
	var theSpecificAssetIDs []ISpecificAssetID

	foundEntityType := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "statements":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "statements"
					}
				)

				return
			}

			array := make(
				[]ISubmodelElement,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISubmodelElement
				item, err = SubmodelElementFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "statements"
						}
					)

					return
				}

				array = append(array, item)
			}
			theStatements = array

		case "entityType":
			theEntityType, err = EntityTypeFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "entityType"
					}
				)
				return
			}
			foundEntityType = true

		case "globalAssetId":
			theGlobalAssetID, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "globalAssetId"
					}
				)
				return
			}
			theGlobalAssetID = &theGlobalAssetID

		case "specificAssetIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "specificAssetIds"
					}
				)

				return
			}

			array := make(
				[]ISpecificAssetID,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISpecificAssetID
				item, err = SpecificAssetIDFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "specificAssetIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSpecificAssetIDs = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundEntityType {
		err = newDeserializationError(
			"The required property 'entityType' is missing"
		)
		return
	}

	result = NewEntity(
		theEntityType
	)
	result.entityType = theEntityType

	return
}

// Parse `jsonable` as a literal of [aastypes.EntityType],
// or return an error.
func EntityTypeFromJsonable(
	jsonable interface{}
) (result aastypes.EntityType, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of EntityType, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of EntityType, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.EntityTypeFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of EntityType, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as a literal of [aastypes.Direction],
// or return an error.
func DirectionFromJsonable(
	jsonable interface{}
) (result aastypes.Direction, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of Direction, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of Direction, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.DirectionFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of Direction, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as a literal of [aastypes.StateOfEvent],
// or return an error.
func StateOfEventFromJsonable(
	jsonable interface{}
) (result aastypes.StateOfEvent, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of StateOfEvent, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of StateOfEvent, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.StateOfEventFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of StateOfEvent, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IEventPayload],
// or return an error.
func EventPayloadFromJsonable(
	jsonable interface{}
) (
	result aastypes.IEventPayload,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = eventPayloadFromMap(m)
}

// Parse [aastypes.IEventPayload] from a map,
// or return an error, if any.
func eventPayloadFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IEventPayload,
	err *DeserializationError,
) {
	var theSource IReference
	var theSourceSemanticID IReference
	var theObservableReference IReference
	var theObservableSemanticID IReference
	var theTopic *string
	var theSubjectID IReference
	var theTimeStamp string
	var thePayload []byte

	foundSource := false
	foundObservableReference := false
	foundTimeStamp := false

	for k, v := range jsonable {
		switch k {
		case "source":
			theSource, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "source"
					}
				)
				return
			}
			foundSource = true

		case "sourceSemanticId":
			theSourceSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "sourceSemanticId"
					}
				)
				return
			}

		case "observableReference":
			theObservableReference, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "observableReference"
					}
				)
				return
			}
			foundObservableReference = true

		case "observableSemanticId":
			theObservableSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "observableSemanticId"
					}
				)
				return
			}

		case "topic":
			theTopic, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "topic"
					}
				)
				return
			}
			theTopic = &theTopic

		case "subjectId":
			theSubjectID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "subjectId"
					}
				)
				return
			}

		case "timeStamp":
			theTimeStamp, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "timeStamp"
					}
				)
				return
			}
			foundTimeStamp = true

		case "payload":
			thePayload, err := bytesFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "payload"
					}
				)
				return
			}
			thePayload = &thePayload

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundSource {
		err = newDeserializationError(
			"The required property 'source' is missing"
		)
		return
	}

	if !foundObservableReference {
		err = newDeserializationError(
			"The required property 'observableReference' is missing"
		)
		return
	}

	if !foundTimeStamp {
		err = newDeserializationError(
			"The required property 'timeStamp' is missing"
		)
		return
	}

	result = NewEventPayload(
		theSource,
		theObservableReference,
		theTimeStamp
	)
	result.source = theSource
	result.observableReference = theObservableReference
	result.timeStamp = theTimeStamp

	return
}

// Parse `jsonable` as an instance of [aastypes.IEventElement],
// or return an error.
func EventElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.IEventElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IEventElement, 
		&DeserializationError)
		fromMap, ok = DispatchEventElementFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IEventElement: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IBasicEventElement],
// or return an error.
func BasicEventElementFromJsonable(
	jsonable interface{}
) (
	result aastypes.IBasicEventElement,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = basicEventElementFromMap(m)
}

// Parse [aastypes.IBasicEventElement] from a map,
// or return an error, if any.
func basicEventElementFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IBasicEventElement,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theObserved IReference
	var theDirection Direction
	var theState StateOfEvent
	var theMessageTopic *string
	var theMessageBroker IReference
	var theLastUpdate *string
	var theMinInterval *string
	var theMaxInterval *string

	foundObserved := false
	foundDirection := false
	foundState := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "observed":
			theObserved, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "observed"
					}
				)
				return
			}
			foundObserved = true

		case "direction":
			theDirection, err = DirectionFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "direction"
					}
				)
				return
			}
			foundDirection = true

		case "state":
			theState, err = StateOfEventFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "state"
					}
				)
				return
			}
			foundState = true

		case "messageTopic":
			theMessageTopic, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "messageTopic"
					}
				)
				return
			}
			theMessageTopic = &theMessageTopic

		case "messageBroker":
			theMessageBroker, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "messageBroker"
					}
				)
				return
			}

		case "lastUpdate":
			theLastUpdate, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "lastUpdate"
					}
				)
				return
			}
			theLastUpdate = &theLastUpdate

		case "minInterval":
			theMinInterval, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "minInterval"
					}
				)
				return
			}
			theMinInterval = &theMinInterval

		case "maxInterval":
			theMaxInterval, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "maxInterval"
					}
				)
				return
			}
			theMaxInterval = &theMaxInterval

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundObserved {
		err = newDeserializationError(
			"The required property 'observed' is missing"
		)
		return
	}

	if !foundDirection {
		err = newDeserializationError(
			"The required property 'direction' is missing"
		)
		return
	}

	if !foundState {
		err = newDeserializationError(
			"The required property 'state' is missing"
		)
		return
	}

	result = NewBasicEventElement(
		theObserved,
		theDirection,
		theState
	)
	result.observed = theObserved
	result.direction = theDirection
	result.state = theState

	return
}

// Parse `jsonable` as an instance of [aastypes.IOperation],
// or return an error.
func OperationFromJsonable(
	jsonable interface{}
) (
	result aastypes.IOperation,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = operationFromMap(m)
}

// Parse [aastypes.IOperation] from a map,
// or return an error, if any.
func operationFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IOperation,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theInputVariables []IOperationVariable
	var theOutputVariables []IOperationVariable
	var theInoutputVariables []IOperationVariable



	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "inputVariables":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "inputVariables"
					}
				)

				return
			}

			array := make(
				[]IOperationVariable,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IOperationVariable
				item, err = OperationVariableFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "inputVariables"
						}
					)

					return
				}

				array = append(array, item)
			}
			theInputVariables = array

		case "outputVariables":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "outputVariables"
					}
				)

				return
			}

			array := make(
				[]IOperationVariable,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IOperationVariable
				item, err = OperationVariableFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "outputVariables"
						}
					)

					return
				}

				array = append(array, item)
			}
			theOutputVariables = array

		case "inoutputVariables":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "inoutputVariables"
					}
				)

				return
			}

			array := make(
				[]IOperationVariable,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IOperationVariable
				item, err = OperationVariableFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "inoutputVariables"
						}
					)

					return
				}

				array = append(array, item)
			}
			theInoutputVariables = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewOperation()

	return
}

// Parse `jsonable` as an instance of [aastypes.IOperationVariable],
// or return an error.
func OperationVariableFromJsonable(
	jsonable interface{}
) (
	result aastypes.IOperationVariable,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = operationVariableFromMap(m)
}

// Parse [aastypes.IOperationVariable] from a map,
// or return an error, if any.
func operationVariableFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IOperationVariable,
	err *DeserializationError,
) {
	var theValue ISubmodelElement

	foundValue := false

	for k, v := range jsonable {
		switch k {
		case "value":
			theValue, err = SubmodelElementFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			foundValue = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing"
		)
		return
	}

	result = NewOperationVariable(
		theValue
	)
	result.value = theValue

	return
}

// Parse `jsonable` as an instance of [aastypes.ICapability],
// or return an error.
func CapabilityFromJsonable(
	jsonable interface{}
) (
	result aastypes.ICapability,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = capabilityFromMap(m)
}

// Parse [aastypes.ICapability] from a map,
// or return an error, if any.
func capabilityFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ICapability,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theSemanticID IReference
	var theSupplementalSemanticIDs []IReference
	var theQualifiers []IQualifier
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification



	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "semanticId":
			theSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "semanticId"
					}
				)
				return
			}

		case "supplementalSemanticIds":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "supplementalSemanticIds"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "supplementalSemanticIds"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSupplementalSemanticIDs = array

		case "qualifiers":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "qualifiers"
					}
				)

				return
			}

			array := make(
				[]IQualifier,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IQualifier
				item, err = QualifierFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "qualifiers"
						}
					)

					return
				}

				array = append(array, item)
			}
			theQualifiers = array

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewCapability()

	return
}

// Parse `jsonable` as an instance of [aastypes.IConceptDescription],
// or return an error.
func ConceptDescriptionFromJsonable(
	jsonable interface{}
) (
	result aastypes.IConceptDescription,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = conceptDescriptionFromMap(m)
}

// Parse [aastypes.IConceptDescription] from a map,
// or return an error, if any.
func conceptDescriptionFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IConceptDescription,
	err *DeserializationError,
) {
	var theExtensions []IExtension
	var theCategory *string
	var theIDShort *string
	var theDisplayName []ILangStringNameType
	var theDescription []ILangStringTextType
	var theAdministration IAdministrativeInformation
	var theID string
	var theEmbeddedDataSpecifications []IEmbeddedDataSpecification
	var theIsCaseOf []IReference

	foundID := false

	for k, v := range jsonable {
		switch k {
		case "extensions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "extensions"
					}
				)

				return
			}

			array := make(
				[]IExtension,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IExtension
				item, err = ExtensionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "extensions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theExtensions = array

		case "category":
			theCategory, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "category"
					}
				)
				return
			}
			theCategory = &theCategory

		case "idShort":
			theIDShort, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "idShort"
					}
				)
				return
			}
			theIDShort = &theIDShort

		case "displayName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "displayName"
					}
				)

				return
			}

			array := make(
				[]ILangStringNameType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringNameType
				item, err = LangStringNameTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "displayName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDisplayName = array

		case "description":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "description"
					}
				)

				return
			}

			array := make(
				[]ILangStringTextType,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringTextType
				item, err = LangStringTextTypeFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "description"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDescription = array

		case "administration":
			theAdministration, err = AdministrativeInformationFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "administration"
					}
				)
				return
			}

		case "id":
			theID, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "id"
					}
				)
				return
			}
			foundID = true

		case "embeddedDataSpecifications":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "embeddedDataSpecifications"
					}
				)

				return
			}

			array := make(
				[]IEmbeddedDataSpecification,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IEmbeddedDataSpecification
				item, err = EmbeddedDataSpecificationFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "embeddedDataSpecifications"
						}
					)

					return
				}

				array = append(array, item)
			}
			theEmbeddedDataSpecifications = array

		case "isCaseOf":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "isCaseOf"
					}
				)

				return
			}

			array := make(
				[]IReference,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IReference
				item, err = ReferenceFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "isCaseOf"
						}
					)

					return
				}

				array = append(array, item)
			}
			theIsCaseOf = array

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundID {
		err = newDeserializationError(
			"The required property 'id' is missing"
		)
		return
	}

	result = NewConceptDescription(
		theID
	)
	result.id = theID

	return
}

// Parse `jsonable` as a literal of [aastypes.ReferenceTypes],
// or return an error.
func ReferenceTypesFromJsonable(
	jsonable interface{}
) (result aastypes.ReferenceTypes, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of ReferenceTypes, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ReferenceTypes, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.ReferenceTypesFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of ReferenceTypes, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IReference],
// or return an error.
func ReferenceFromJsonable(
	jsonable interface{}
) (
	result aastypes.IReference,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = referenceFromMap(m)
}

// Parse [aastypes.IReference] from a map,
// or return an error, if any.
func referenceFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IReference,
	err *DeserializationError,
) {
	var theType ReferenceTypes
	var theReferredSemanticID IReference
	var theKeys []IKey

	foundType := false
	foundKeys := false

	for k, v := range jsonable {
		switch k {
		case "type":
			theType, err = ReferenceTypesFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "type"
					}
				)
				return
			}
			foundType = true

		case "referredSemanticId":
			theReferredSemanticID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "referredSemanticId"
					}
				)
				return
			}

		case "keys":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "keys"
					}
				)

				return
			}

			array := make(
				[]IKey,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IKey
				item, err = KeyFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "keys"
						}
					)

					return
				}

				array = append(array, item)
			}
			theKeys = array
			foundKeys = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing"
		)
		return
	}

	if !foundKeys {
		err = newDeserializationError(
			"The required property 'keys' is missing"
		)
		return
	}

	result = NewReference(
		theType,
		theKeys
	)
	result.typE = theType
	result.keys = theKeys

	return
}

// Parse `jsonable` as an instance of [aastypes.IKey],
// or return an error.
func KeyFromJsonable(
	jsonable interface{}
) (
	result aastypes.IKey,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = keyFromMap(m)
}

// Parse [aastypes.IKey] from a map,
// or return an error, if any.
func keyFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IKey,
	err *DeserializationError,
) {
	var theType KeyTypes
	var theValue string

	foundType := false
	foundValue := false

	for k, v := range jsonable {
		switch k {
		case "type":
			theType, err = KeyTypesFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "type"
					}
				)
				return
			}
			foundType = true

		case "value":
			theValue, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			foundValue = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundType {
		err = newDeserializationError(
			"The required property 'type' is missing"
		)
		return
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing"
		)
		return
	}

	result = NewKey(
		theType,
		theValue
	)
	result.typE = theType
	result.value = theValue

	return
}

// Parse `jsonable` as a literal of [aastypes.KeyTypes],
// or return an error.
func KeyTypesFromJsonable(
	jsonable interface{}
) (result aastypes.KeyTypes, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of KeyTypes, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of KeyTypes, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.KeyTypesFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of KeyTypes, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as a literal of [aastypes.DataTypeDefXSD],
// or return an error.
func DataTypeDefXSDFromJsonable(
	jsonable interface{}
) (result aastypes.DataTypeDefXSD, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of DataTypeDefXSD, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeDefXSD, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.DataTypeDefXSDFromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeDefXSD, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.IAbstractLangString],
// or return an error.
func AbstractLangStringFromJsonable(
	jsonable interface{}
) (
	result aastypes.IAbstractLangString,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IAbstractLangString, 
		&DeserializationError)
		fromMap, ok = DispatchAbstractLangStringFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IAbstractLangString: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringNameType],
// or return an error.
func LangStringNameTypeFromJsonable(
	jsonable interface{}
) (
	result aastypes.ILangStringNameType,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = langStringNameTypeFromMap(m)
}

// Parse [aastypes.ILangStringNameType] from a map,
// or return an error, if any.
func langStringNameTypeFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ILangStringNameType,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range jsonable {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language"
					}
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text"
					}
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing"
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing"
		)
		return
	}

	result = NewLangStringNameType(
		theLanguage,
		theText
	)
	result.language = theLanguage
	result.text = theText

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringTextType],
// or return an error.
func LangStringTextTypeFromJsonable(
	jsonable interface{}
) (
	result aastypes.ILangStringTextType,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = langStringTextTypeFromMap(m)
}

// Parse [aastypes.ILangStringTextType] from a map,
// or return an error, if any.
func langStringTextTypeFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ILangStringTextType,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range jsonable {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language"
					}
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text"
					}
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing"
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing"
		)
		return
	}

	result = NewLangStringTextType(
		theLanguage,
		theText
	)
	result.language = theLanguage
	result.text = theText

	return
}

// Parse `jsonable` as an instance of [aastypes.IEnvironment],
// or return an error.
func EnvironmentFromJsonable(
	jsonable interface{}
) (
	result aastypes.IEnvironment,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = environmentFromMap(m)
}

// Parse [aastypes.IEnvironment] from a map,
// or return an error, if any.
func environmentFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IEnvironment,
	err *DeserializationError,
) {
	var theAssetAdministrationShells []IAssetAdministrationShell
	var theSubmodels []ISubmodel
	var theConceptDescriptions []IConceptDescription



	for k, v := range jsonable {
		switch k {
		case "assetAdministrationShells":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "assetAdministrationShells"
					}
				)

				return
			}

			array := make(
				[]IAssetAdministrationShell,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IAssetAdministrationShell
				item, err = AssetAdministrationShellFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "assetAdministrationShells"
						}
					)

					return
				}

				array = append(array, item)
			}
			theAssetAdministrationShells = array

		case "submodels":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "submodels"
					}
				)

				return
			}

			array := make(
				[]ISubmodel,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ISubmodel
				item, err = SubmodelFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "submodels"
						}
					)

					return
				}

				array = append(array, item)
			}
			theSubmodels = array

		case "conceptDescriptions":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "conceptDescriptions"
					}
				)

				return
			}

			array := make(
				[]IConceptDescription,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IConceptDescription
				item, err = ConceptDescriptionFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "conceptDescriptions"
						}
					)

					return
				}

				array = append(array, item)
			}
			theConceptDescriptions = array

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	NewEnvironment()

	return
}

// Parse `jsonable` as an instance of [aastypes.IDataSpecificationContent],
// or return an error.
func DataSpecificationContentFromJsonable(
	jsonable interface{}
) (
	result aastypes.IDataSpecificationContent,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	var modelTypeAny interface{}
	modelTypeAny, ok = m["modelType"];
	if !ok {
		err = newDeserializationError(
			"Expected the property modelType, but got none"
		)
		return
	}

	var modelType string
	modelType, ok = modelTypeAny.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected the property modelType to be a string, " +
				"but got %T", 
				modelTypeAny
			)
		)
		return
	}

	var dispatch func(
		map[string]interface{}) (
		aastypes.IDataSpecificationContent, 
		&DeserializationError)
		fromMap, ok = DispatchDataSpecificationContentFromMap[modelType]
		if !ok {
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected model type " +
					"for IDataSpecificationContent: %s", 
					modelType
				)
			)
			return
		}

	result, err = fromMap(m)
	return
}

// Parse `jsonable` as an instance of [aastypes.IEmbeddedDataSpecification],
// or return an error.
func EmbeddedDataSpecificationFromJsonable(
	jsonable interface{}
) (
	result aastypes.IEmbeddedDataSpecification,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = embeddedDataSpecificationFromMap(m)
}

// Parse [aastypes.IEmbeddedDataSpecification] from a map,
// or return an error, if any.
func embeddedDataSpecificationFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IEmbeddedDataSpecification,
	err *DeserializationError,
) {
	var theDataSpecification IReference
	var theDataSpecificationContent IDataSpecificationContent

	foundDataSpecification := false
	foundDataSpecificationContent := false

	for k, v := range jsonable {
		switch k {
		case "dataSpecification":
			theDataSpecification, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "dataSpecification"
					}
				)
				return
			}
			foundDataSpecification = true

		case "dataSpecificationContent":
			theDataSpecificationContent, err = DataSpecificationContentFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "dataSpecificationContent"
					}
				)
				return
			}
			foundDataSpecificationContent = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundDataSpecification {
		err = newDeserializationError(
			"The required property 'dataSpecification' is missing"
		)
		return
	}

	if !foundDataSpecificationContent {
		err = newDeserializationError(
			"The required property 'dataSpecificationContent' is missing"
		)
		return
	}

	result = NewEmbeddedDataSpecification(
		theDataSpecification,
		theDataSpecificationContent
	)
	result.dataSpecification = theDataSpecification
	result.dataSpecificationContent = theDataSpecificationContent

	return
}

// Parse `jsonable` as a literal of [aastypes.DataTypeIEC61360],
// or return an error.
func DataTypeIEC61360FromJsonable(
	jsonable interface{}
) (result aastypes.DataTypeIEC61360, err *DeserializationError) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a string representation of DataTypeIEC61360, " +
			"but got null"
		)
		return
	}

	var ok bool
	text, ok = jsonable.(string)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeIEC61360, " +
				"but got %T", 
				jsonable
			)
		)
		return
	}

	result, ok = aasstringification.DataTypeIEC61360FromString(text)
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a string representation of DataTypeIEC61360, " +
				"but got %v", 
				text
			)
		)
		return
	}

	return
}

// Parse `jsonable` as an instance of [aastypes.ILevelType],
// or return an error.
func LevelTypeFromJsonable(
	jsonable interface{}
) (
	result aastypes.ILevelType,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = levelTypeFromMap(m)
}

// Parse [aastypes.ILevelType] from a map,
// or return an error, if any.
func levelTypeFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ILevelType,
	err *DeserializationError,
) {
	var theMin bool
	var theNom bool
	var theTyp bool
	var theMax bool

	foundMin := false
	foundNom := false
	foundTyp := false
	foundMax := false

	for k, v := range jsonable {
		switch k {
		case "min":
			theMin, err = boolFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "min"
					}
				)
				return
			}
			foundMin = true

		case "nom":
			theNom, err = boolFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "nom"
					}
				)
				return
			}
			foundNom = true

		case "typ":
			theTyp, err = boolFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "typ"
					}
				)
				return
			}
			foundTyp = true

		case "max":
			theMax, err = boolFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "max"
					}
				)
				return
			}
			foundMax = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundMin {
		err = newDeserializationError(
			"The required property 'min' is missing"
		)
		return
	}

	if !foundNom {
		err = newDeserializationError(
			"The required property 'nom' is missing"
		)
		return
	}

	if !foundTyp {
		err = newDeserializationError(
			"The required property 'typ' is missing"
		)
		return
	}

	if !foundMax {
		err = newDeserializationError(
			"The required property 'max' is missing"
		)
		return
	}

	result = NewLevelType(
		theMin,
		theNom,
		theTyp,
		theMax
	)
	result.min = theMin
	result.nom = theNom
	result.typ = theTyp
	result.max = theMax

	return
}

// Parse `jsonable` as an instance of [aastypes.IValueReferencePair],
// or return an error.
func ValueReferencePairFromJsonable(
	jsonable interface{}
) (
	result aastypes.IValueReferencePair,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = valueReferencePairFromMap(m)
}

// Parse [aastypes.IValueReferencePair] from a map,
// or return an error, if any.
func valueReferencePairFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IValueReferencePair,
	err *DeserializationError,
) {
	var theValue string
	var theValueID IReference

	foundValue := false
	foundValueID := false

	for k, v := range jsonable {
		switch k {
		case "value":
			theValue, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			foundValue = true

		case "valueId":
			theValueID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueId"
					}
				)
				return
			}
			foundValueID = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundValue {
		err = newDeserializationError(
			"The required property 'value' is missing"
		)
		return
	}

	if !foundValueID {
		err = newDeserializationError(
			"The required property 'valueId' is missing"
		)
		return
	}

	result = NewValueReferencePair(
		theValue,
		theValueID
	)
	result.value = theValue
	result.valueID = theValueID

	return
}

// Parse `jsonable` as an instance of [aastypes.IValueList],
// or return an error.
func ValueListFromJsonable(
	jsonable interface{}
) (
	result aastypes.IValueList,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = valueListFromMap(m)
}

// Parse [aastypes.IValueList] from a map,
// or return an error, if any.
func valueListFromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IValueList,
	err *DeserializationError,
) {
	var theValueReferencePairs []IValueReferencePair

	foundValueReferencePairs := false

	for k, v := range jsonable {
		switch k {
		case "valueReferencePairs":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueReferencePairs"
					}
				)

				return
			}

			array := make(
				[]IValueReferencePair,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item IValueReferencePair
				item, err = ValueReferencePairFromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "valueReferencePairs"
						}
					)

					return
				}

				array = append(array, item)
			}
			theValueReferencePairs = array
			foundValueReferencePairs = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundValueReferencePairs {
		err = newDeserializationError(
			"The required property 'valueReferencePairs' is missing"
		)
		return
	}

	result = NewValueList(
		theValueReferencePairs
	)
	result.valueReferencePairs = theValueReferencePairs

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringPreferredNameTypeIEC61360],
// or return an error.
func LangStringPreferredNameTypeIEC61360FromJsonable(
	jsonable interface{}
) (
	result aastypes.ILangStringPreferredNameTypeIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = langStringPreferredNameTypeIEC61360FromMap(m)
}

// Parse [aastypes.ILangStringPreferredNameTypeIEC61360] from a map,
// or return an error, if any.
func langStringPreferredNameTypeIEC61360FromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ILangStringPreferredNameTypeIEC61360,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range jsonable {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language"
					}
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text"
					}
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing"
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing"
		)
		return
	}

	result = NewLangStringPreferredNameTypeIEC61360(
		theLanguage,
		theText
	)
	result.language = theLanguage
	result.text = theText

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringShortNameTypeIEC61360],
// or return an error.
func LangStringShortNameTypeIEC61360FromJsonable(
	jsonable interface{}
) (
	result aastypes.ILangStringShortNameTypeIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = langStringShortNameTypeIEC61360FromMap(m)
}

// Parse [aastypes.ILangStringShortNameTypeIEC61360] from a map,
// or return an error, if any.
func langStringShortNameTypeIEC61360FromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ILangStringShortNameTypeIEC61360,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range jsonable {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language"
					}
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text"
					}
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing"
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing"
		)
		return
	}

	result = NewLangStringShortNameTypeIEC61360(
		theLanguage,
		theText
	)
	result.language = theLanguage
	result.text = theText

	return
}

// Parse `jsonable` as an instance of [aastypes.ILangStringDefinitionTypeIEC61360],
// or return an error.
func LangStringDefinitionTypeIEC61360FromJsonable(
	jsonable interface{}
) (
	result aastypes.ILangStringDefinitionTypeIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = langStringDefinitionTypeIEC61360FromMap(m)
}

// Parse [aastypes.ILangStringDefinitionTypeIEC61360] from a map,
// or return an error, if any.
func langStringDefinitionTypeIEC61360FromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.ILangStringDefinitionTypeIEC61360,
	err *DeserializationError,
) {
	var theLanguage string
	var theText string

	foundLanguage := false
	foundText := false

	for k, v := range jsonable {
		switch k {
		case "language":
			theLanguage, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "language"
					}
				)
				return
			}
			foundLanguage = true

		case "text":
			theText, err = stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "text"
					}
				)
				return
			}
			foundText = true

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundLanguage {
		err = newDeserializationError(
			"The required property 'language' is missing"
		)
		return
	}

	if !foundText {
		err = newDeserializationError(
			"The required property 'text' is missing"
		)
		return
	}

	result = NewLangStringDefinitionTypeIEC61360(
		theLanguage,
		theText
	)
	result.language = theLanguage
	result.text = theText

	return
}

// Parse `jsonable` as an instance of [aastypes.IDataSpecificationIEC61360],
// or return an error.
func DataSpecificationIEC61360FromJsonable(
	jsonable interface{}
) (
	result aastypes.IDataSpecificationIEC61360,
	err *DeserializationError,
) {
	if jsonable == nil {
		err = newDeserializationError(
			"Expected a JSON object, but got null"
		)
		return
	}

	m, ok := jsonable.(map[string]interface{})
	if !ok {
		err = newDeserializationError(
			fmt.Sprintf(
				"Expected a JSON object, but got %T", 
				jsonable
			)
		)
		return
	}

	result, err = dataSpecificationIEC61360FromMap(m)
}

// Parse [aastypes.IDataSpecificationIEC61360] from a map,
// or return an error, if any.
func dataSpecificationIEC61360FromMapWithoutDispatch(
	m map[string]interface{}
) (
	result aastypes.IDataSpecificationIEC61360,
	err *DeserializationError,
) {
	var thePreferredName []ILangStringPreferredNameTypeIEC61360
	var theShortName []ILangStringShortNameTypeIEC61360
	var theUnit *string
	var theUnitID IReference
	var theSourceOfDefinition *string
	var theSymbol *string
	var theDataType *DataTypeIEC61360
	var theDefinition []ILangStringDefinitionTypeIEC61360
	var theValueFormat *string
	var theValueList IValueList
	var theValue *string
	var theLevelType ILevelType

	foundPreferredName := false

	for k, v := range jsonable {
		switch k {
		case "preferredName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "preferredName"
					}
				)

				return
			}

			array := make(
				[]ILangStringPreferredNameTypeIEC61360,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringPreferredNameTypeIEC61360
				item, err = LangStringPreferredNameTypeIEC61360FromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "preferredName"
						}
					)

					return
				}

				array = append(array, item)
			}
			thePreferredName = array
			foundPreferredName = true

		case "shortName":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "shortName"
					}
				)

				return
			}

			array := make(
				[]ILangStringShortNameTypeIEC61360,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringShortNameTypeIEC61360
				item, err = LangStringShortNameTypeIEC61360FromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "shortName"
						}
					)

					return
				}

				array = append(array, item)
			}
			theShortName = array

		case "unit":
			theUnit, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "unit"
					}
				)
				return
			}
			theUnit = &theUnit

		case "unitId":
			theUnitID, err = ReferenceFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "unitId"
					}
				)
				return
			}

		case "sourceOfDefinition":
			theSourceOfDefinition, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "sourceOfDefinition"
					}
				)
				return
			}
			theSourceOfDefinition = &theSourceOfDefinition

		case "symbol":
			theSymbol, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "symbol"
					}
				)
				return
			}
			theSymbol = &theSymbol

		case "dataType":
			theDataType, err := DataTypeIEC61360FromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "dataType"
					}
				)
				return
			}
			theDataType = &theDataType

		case "definition":
			var jsonableArray []interface{}
			jsonableArray, ok = v.([]interface{})
			if !ok {
				err = new DeserializationError(
					fmt.Sprintf(
						"Expected an array, but got %T",
						v
					)
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "definition"
					}
				)

				return
			}

			array := make(
				[]ILangStringDefinitionTypeIEC61360,
				len(jsonableArray)
			)
			for i, itemJsonable := range jsonableArray {
				var item ILangStringDefinitionTypeIEC61360
				item, err = LangStringDefinitionTypeIEC61360FromJsonable(
					itemJsonable
				)
				if err != nil {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "definition"
						}
					)

					return
				}

				array = append(array, item)
			}
			theDefinition = array

		case "valueFormat":
			theValueFormat, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueFormat"
					}
				)
				return
			}
			theValueFormat = &theValueFormat

		case "valueList":
			theValueList, err = ValueListFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "valueList"
					}
				)
				return
			}

		case "value":
			theValue, err := stringFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "value"
					}
				)
				return
			}
			theValue = &theValue

		case "levelType":
			theLevelType, err = LevelTypeFromJsonable(
				v
			)
			if err != nil {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "levelType"
					}
				)
				return
			}

		case "modelType":
			// We ignore the model type as we intentionally dispatched
			// to this function.

		default:
			err = newDeserializationError(
				fmt.Sprintf(
					"Unexpected property: %s",
					k
				)
			)
			return
		}
	}

	if !foundPreferredName {
		err = newDeserializationError(
			"The required property 'preferredName' is missing"
		)
		return
	}

	result = NewDataSpecificationIEC61360(
		thePreferredName
	)
	result.preferredName = thePreferredName

	return
}

dispatchHasSemanticsFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IHasSemantics, 
	&DeserializationError) {
	"RelationshipElement":
	RelationshipElementFromMap,
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"BasicEventElement":
	BasicEventElementFromMap,
	"Blob":
	BlobFromMap,
	"Capability":
	CapabilityFromMap,
	"Entity":
	EntityFromMap,
	"Extension":
	ExtensionFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Operation":
	OperationFromMap,
	"Property":
	PropertyFromMap,
	"Qualifier":
	QualifierFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
	"SpecificAssetId":
	SpecificAssetIDFromMap,
	"Submodel":
	SubmodelFromMap,
	"SubmodelElementCollection":
	SubmodelElementCollectionFromMap,
	"SubmodelElementList":
	SubmodelElementListFromMap,
}

dispatchHasExtensionsFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IHasExtensions, 
	&DeserializationError) {
	"RelationshipElement":
	RelationshipElementFromMap,
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"AssetAdministrationShell":
	AssetAdministrationShellFromMap,
	"BasicEventElement":
	BasicEventElementFromMap,
	"Blob":
	BlobFromMap,
	"Capability":
	CapabilityFromMap,
	"ConceptDescription":
	ConceptDescriptionFromMap,
	"Entity":
	EntityFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Operation":
	OperationFromMap,
	"Property":
	PropertyFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
	"Submodel":
	SubmodelFromMap,
	"SubmodelElementCollection":
	SubmodelElementCollectionFromMap,
	"SubmodelElementList":
	SubmodelElementListFromMap,
}

dispatchReferableFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IReferable, 
	&DeserializationError) {
	"RelationshipElement":
	RelationshipElementFromMap,
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"AssetAdministrationShell":
	AssetAdministrationShellFromMap,
	"BasicEventElement":
	BasicEventElementFromMap,
	"Blob":
	BlobFromMap,
	"Capability":
	CapabilityFromMap,
	"ConceptDescription":
	ConceptDescriptionFromMap,
	"Entity":
	EntityFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Operation":
	OperationFromMap,
	"Property":
	PropertyFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
	"Submodel":
	SubmodelFromMap,
	"SubmodelElementCollection":
	SubmodelElementCollectionFromMap,
	"SubmodelElementList":
	SubmodelElementListFromMap,
}

dispatchIdentifiableFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IIdentifiable, 
	&DeserializationError) {
	"AssetAdministrationShell":
	AssetAdministrationShellFromMap,
	"ConceptDescription":
	ConceptDescriptionFromMap,
	"Submodel":
	SubmodelFromMap,
}

dispatchHasKindFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IHasKind, 
	&DeserializationError) {
	"Submodel":
	SubmodelFromMap,
}

dispatchHasDataSpecificationFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IHasDataSpecification, 
	&DeserializationError) {
	"AdministrativeInformation":
	AdministrativeInformationFromMap,
	"RelationshipElement":
	RelationshipElementFromMap,
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"AssetAdministrationShell":
	AssetAdministrationShellFromMap,
	"BasicEventElement":
	BasicEventElementFromMap,
	"Blob":
	BlobFromMap,
	"Capability":
	CapabilityFromMap,
	"ConceptDescription":
	ConceptDescriptionFromMap,
	"Entity":
	EntityFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Operation":
	OperationFromMap,
	"Property":
	PropertyFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
	"Submodel":
	SubmodelFromMap,
	"SubmodelElementCollection":
	SubmodelElementCollectionFromMap,
	"SubmodelElementList":
	SubmodelElementListFromMap,
}

dispatchQualifiableFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IQualifiable, 
	&DeserializationError) {
	"RelationshipElement":
	RelationshipElementFromMap,
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"BasicEventElement":
	BasicEventElementFromMap,
	"Blob":
	BlobFromMap,
	"Capability":
	CapabilityFromMap,
	"Entity":
	EntityFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Operation":
	OperationFromMap,
	"Property":
	PropertyFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
	"Submodel":
	SubmodelFromMap,
	"SubmodelElementCollection":
	SubmodelElementCollectionFromMap,
	"SubmodelElementList":
	SubmodelElementListFromMap,
}

dispatchSubmodelElementFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.ISubmodelElement, 
	&DeserializationError) {
	"RelationshipElement":
	RelationshipElementFromMap,
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"BasicEventElement":
	BasicEventElementFromMap,
	"Blob":
	BlobFromMap,
	"Capability":
	CapabilityFromMap,
	"Entity":
	EntityFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Operation":
	OperationFromMap,
	"Property":
	PropertyFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
	"SubmodelElementCollection":
	SubmodelElementCollectionFromMap,
	"SubmodelElementList":
	SubmodelElementListFromMap,
}

dispatchRelationshipElementFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IRelationshipElement, 
	&DeserializationError) {
	"AnnotatedRelationshipElement":
	AnnotatedRelationshipElementFromMap,
	"RelationshipElement":
	RelationshipElementFromMap,
}

dispatchDataElementFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IDataElement, 
	&DeserializationError) {
	"Blob":
	BlobFromMap,
	"File":
	FileFromMap,
	"MultiLanguageProperty":
	MultiLanguagePropertyFromMap,
	"Property":
	PropertyFromMap,
	"Range":
	RangeFromMap,
	"ReferenceElement":
	ReferenceElementFromMap,
}

dispatchEventElementFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IEventElement, 
	&DeserializationError) {
	"BasicEventElement":
	BasicEventElementFromMap,
}

dispatchAbstractLangStringFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IAbstractLangString, 
	&DeserializationError) {
	"LangStringDefinitionTypeIec61360":
	LangStringDefinitionTypeIEC61360FromMap,
	"LangStringNameType":
	LangStringNameTypeFromMap,
	"LangStringPreferredNameTypeIec61360":
	LangStringPreferredNameTypeIEC61360FromMap,
	"LangStringShortNameTypeIec61360":
	LangStringShortNameTypeIEC61360FromMap,
	"LangStringTextType":
	LangStringTextTypeFromMap,
}

dispatchDataSpecificationContentFromMap := map[string]func(
	map[string]interface{}) (
	aastypes.IDataSpecificationContent, 
	&DeserializationError) {
	"DataSpecificationIec61360":
	DataSpecificationIEC61360FromMap,
}

// endregion

// region Serialization

// Represent an error during the serialization.
//
// Implements `error`.
type SerializationError struct{
	Path *aasreporting.Path,
	Message string
}

func newSerializationError(message string) *SerializationError {
	return &SerializationError{
		Path &aasreporting.Path{},
		Message message
	}
}

func (se *SerializationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		se.PathString(),
		se.Message
	)
}

// Render the path as a string.
func (se *SerializationError) PathString() string {
	return aasreporting.ToGolangPath(se.Path)
}

// Try to cast `that` to a float64, or return an error.
func int64ToJsonable(
	that int64
) (result float64, err *SerializationError) {
	if that > 9007199254740991 or that < -9007199254740991 {
		err = newSerializationError(
			fmt.Sprintf(
				"64-bit integer can not be represented as 64-bit float in JSON: %v",
				that
			)
		)
		return
	}

	result = float64(that);
	return
}

// Encode `bytes` to a base64 string.
func bytesToJsonable(
	bytes []byte
) (result string, err *SerializationError) {
	if bytes == nil {
		err = newSerializationError(
			"Expected an array of bytes, but got nil"
		)
		return
	}

	result = b64.StdEncoding.EncodeToString(
		bytes
	)
	return
}

// Serialize `that` to a string,
// or return an error.
func ModellingKindToJsonable(
	that aastypes.ModellingKind
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.ModellingKindToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of ModellingKind: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func QualifierKindToJsonable(
	that aastypes.QualifierKind
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.QualifierKindToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of QualifierKind: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func AssetKindToJsonable(
	that aastypes.AssetKind
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.AssetKindToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of AssetKind: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func AASSubmodelElementsToJsonable(
	that aastypes.AASSubmodelElements
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.AASSubmodelElementsToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of AASSubmodelElements: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func EntityTypeToJsonable(
	that aastypes.EntityType
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.EntityTypeToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of EntityType: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func DirectionToJsonable(
	that aastypes.Direction
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.DirectionToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of Direction: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func StateOfEventToJsonable(
	that aastypes.StateOfEvent
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.StateOfEventToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of StateOfEvent: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func ReferenceTypesToJsonable(
	that aastypes.ReferenceTypes
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.ReferenceTypesToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of ReferenceTypes: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func KeyTypesToJsonable(
	that aastypes.KeyTypes
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.KeyTypesToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of KeyTypes: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func DataTypeDefXSDToJsonable(
	that aastypes.DataTypeDefXSD
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.DataTypeDefXSDToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of DataTypeDefXSD: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize `that` to a string,
// or return an error.
func DataTypeIEC61360ToJsonable(
	that aastypes.DataTypeIEC61360
) (result string, err *SerializationError) {
	var ok bool
	result, ok = aasstringification.DataTypeIEC61360ToString(
		that
	)
	if !ok {
		err = &SerializationError{
			fmt.Sprintf(
				"Got an invalid literal of DataTypeIEC61360: %v",
				that
			)
		)
		return
	}

	return
}

// Serialize [aastypes.IExtension] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IExtension] with proper dispatch, call
// [ToJsonable].
func extensionToMap(
	that: aastypes.IExtension
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theName = that.Name()
	result["Name"] = *theName

	theValueType = that.ValueType()
	if theValueType != nil {
		var jsonableValueType interface{}
		jsonableValueType, err = DataTypeDefXSDToJsonable(
			theValueType,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueType"
				}
			)

			return
		}
		result["ValueType"] = jsonableValueType
	}

	theValue = that.Value()
	if theValue != nil {
		result["Value"] = *theValue
	}

	theRefersTo = that.RefersTo()
	if theRefersTo != nil {
		jsonableRefersTo := make(
			interface{},
			len(theRefersTo)
		)
		for i, v := range theRefersTo {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "RefersTo"
					}
				)

				return
			}
			jsonableRefersTo = append(
				jsonableRefersTo,
				jsonable
			)   
		}
		result["RefersTo"] = jsonableRefersTo
	}
}

// Serialize [aastypes.IAdministrativeInformation] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAdministrativeInformation] with proper dispatch, call
// [ToJsonable].
func administrativeInformationToMap(
	that: aastypes.IAdministrativeInformation
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theVersion = that.Version()
	if theVersion != nil {
		result["Version"] = *theVersion
	}

	theRevision = that.Revision()
	if theRevision != nil {
		result["Revision"] = *theRevision
	}

	theCreator = that.Creator()
	if theCreator != nil {
		var jsonableCreator interface{}
		jsonableCreator, err = ReferenceToJsonable(
			theCreator,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Creator"
				}
			)

			return
		}
		result["Creator"] = jsonableCreator
	}

	theTemplateID = that.TemplateID()
	if theTemplateID != nil {
		result["TemplateID"] = *theTemplateID
	}
}

// Serialize [aastypes.IQualifier] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IQualifier] with proper dispatch, call
// [ToJsonable].
func qualifierToMap(
	that: aastypes.IQualifier
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theKind = that.Kind()
	if theKind != nil {
		var jsonableKind interface{}
		jsonableKind, err = QualifierKindToJsonable(
			theKind,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Kind"
				}
			)

			return
		}
		result["Kind"] = jsonableKind
	}

	theType = that.Type()
	result["Type"] = *theType

	theValueType = that.ValueType()
	var jsonableValueType interface{}
	jsonableValueType, err = DataTypeDefXSDToJsonable(
		theValueType,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType"
			}
		)

		return
	}
	result["ValueType"] = jsonableValueType

	theValue = that.Value()
	if theValue != nil {
		result["Value"] = *theValue
	}

	theValueID = that.ValueID()
	if theValueID != nil {
		var jsonableValueID interface{}
		jsonableValueID, err = ReferenceToJsonable(
			theValueID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID"
				}
			)

			return
		}
		result["ValueID"] = jsonableValueID
	}
}

// Serialize [aastypes.IAssetAdministrationShell] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAssetAdministrationShell] with proper dispatch, call
// [ToJsonable].
func assetAdministrationShellToMap(
	that: aastypes.IAssetAdministrationShell
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theAdministration = that.Administration()
	if theAdministration != nil {
		var jsonableAdministration interface{}
		jsonableAdministration, err = AdministrativeInformationToJsonable(
			theAdministration,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Administration"
				}
			)

			return
		}
		result["Administration"] = jsonableAdministration
	}

	theID = that.ID()
	result["ID"] = *theID

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theDerivedFrom = that.DerivedFrom()
	if theDerivedFrom != nil {
		var jsonableDerivedFrom interface{}
		jsonableDerivedFrom, err = ReferenceToJsonable(
			theDerivedFrom,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DerivedFrom"
				}
			)

			return
		}
		result["DerivedFrom"] = jsonableDerivedFrom
	}

	theAssetInformation = that.AssetInformation()
	var jsonableAssetInformation interface{}
	jsonableAssetInformation, err = AssetInformationToJsonable(
		theAssetInformation,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "AssetInformation"
			}
		)

		return
	}
	result["AssetInformation"] = jsonableAssetInformation

	theSubmodels = that.Submodels()
	if theSubmodels != nil {
		jsonableSubmodels := make(
			interface{},
			len(theSubmodels)
		)
		for i, v := range theSubmodels {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Submodels"
					}
				)

				return
			}
			jsonableSubmodels = append(
				jsonableSubmodels,
				jsonable
			)   
		}
		result["Submodels"] = jsonableSubmodels
	}
}

// Serialize [aastypes.IAssetInformation] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAssetInformation] with proper dispatch, call
// [ToJsonable].
func assetInformationToMap(
	that: aastypes.IAssetInformation
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theAssetKind = that.AssetKind()
	var jsonableAssetKind interface{}
	jsonableAssetKind, err = AssetKindToJsonable(
		theAssetKind,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "AssetKind"
			}
		)

		return
	}
	result["AssetKind"] = jsonableAssetKind

	theGlobalAssetID = that.GlobalAssetID()
	if theGlobalAssetID != nil {
		result["GlobalAssetID"] = *theGlobalAssetID
	}

	theSpecificAssetIDs = that.SpecificAssetIDs()
	if theSpecificAssetIDs != nil {
		jsonableSpecificAssetIDs := make(
			interface{},
			len(theSpecificAssetIDs)
		)
		for i, v := range theSpecificAssetIDs {
			var jsonable interface{}
			jsonable, err = SpecificAssetIDToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SpecificAssetIDs"
					}
				)

				return
			}
			jsonableSpecificAssetIDs = append(
				jsonableSpecificAssetIDs,
				jsonable
			)   
		}
		result["SpecificAssetIDs"] = jsonableSpecificAssetIDs
	}

	theAssetType = that.AssetType()
	if theAssetType != nil {
		result["AssetType"] = *theAssetType
	}

	theDefaultThumbnail = that.DefaultThumbnail()
	if theDefaultThumbnail != nil {
		var jsonableDefaultThumbnail interface{}
		jsonableDefaultThumbnail, err = ResourceToJsonable(
			theDefaultThumbnail,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DefaultThumbnail"
				}
			)

			return
		}
		result["DefaultThumbnail"] = jsonableDefaultThumbnail
	}
}

// Serialize [aastypes.IResource] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IResource] with proper dispatch, call
// [ToJsonable].
func resourceToMap(
	that: aastypes.IResource
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	thePath = that.Path()
	result["Path"] = *thePath

	theContentType = that.ContentType()
	if theContentType != nil {
		result["ContentType"] = *theContentType
	}
}

// Serialize [aastypes.ISpecificAssetID] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISpecificAssetID] with proper dispatch, call
// [ToJsonable].
func specificAssetIDToMap(
	that: aastypes.ISpecificAssetID
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theName = that.Name()
	result["Name"] = *theName

	theValue = that.Value()
	result["Value"] = *theValue

	theExternalSubjectID = that.ExternalSubjectID()
	if theExternalSubjectID != nil {
		var jsonableExternalSubjectID interface{}
		jsonableExternalSubjectID, err = ReferenceToJsonable(
			theExternalSubjectID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ExternalSubjectID"
				}
			)

			return
		}
		result["ExternalSubjectID"] = jsonableExternalSubjectID
	}
}

// Serialize [aastypes.ISubmodel] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISubmodel] with proper dispatch, call
// [ToJsonable].
func submodelToMap(
	that: aastypes.ISubmodel
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theAdministration = that.Administration()
	if theAdministration != nil {
		var jsonableAdministration interface{}
		jsonableAdministration, err = AdministrativeInformationToJsonable(
			theAdministration,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Administration"
				}
			)

			return
		}
		result["Administration"] = jsonableAdministration
	}

	theID = that.ID()
	result["ID"] = *theID

	theKind = that.Kind()
	if theKind != nil {
		var jsonableKind interface{}
		jsonableKind, err = ModellingKindToJsonable(
			theKind,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Kind"
				}
			)

			return
		}
		result["Kind"] = jsonableKind
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theSubmodelElements = that.SubmodelElements()
	if theSubmodelElements != nil {
		jsonableSubmodelElements := make(
			interface{},
			len(theSubmodelElements)
		)
		for i, v := range theSubmodelElements {
			var jsonable interface{}
			jsonable, err = SubmodelElementToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SubmodelElements"
					}
				)

				return
			}
			jsonableSubmodelElements = append(
				jsonableSubmodelElements,
				jsonable
			)   
		}
		result["SubmodelElements"] = jsonableSubmodelElements
	}
}

// Serialize [aastypes.IRelationshipElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IRelationshipElement] with proper dispatch, call
// [ToJsonable].
func relationshipElementToMap(
	that: aastypes.IRelationshipElement
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theFirst = that.First()
	var jsonableFirst interface{}
	jsonableFirst, err = ReferenceToJsonable(
		theFirst,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "First"
			}
		)

		return
	}
	result["First"] = jsonableFirst

	theSecond = that.Second()
	var jsonableSecond interface{}
	jsonableSecond, err = ReferenceToJsonable(
		theSecond,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Second"
			}
		)

		return
	}
	result["Second"] = jsonableSecond
}

// Serialize [aastypes.ISubmodelElementList] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISubmodelElementList] with proper dispatch, call
// [ToJsonable].
func submodelElementListToMap(
	that: aastypes.ISubmodelElementList
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theOrderRelevant = that.OrderRelevant()
	if theOrderRelevant != nil {
		result["OrderRelevant"] = *theOrderRelevant
	}

	theSemanticIDListElement = that.SemanticIDListElement()
	if theSemanticIDListElement != nil {
		var jsonableSemanticIDListElement interface{}
		jsonableSemanticIDListElement, err = ReferenceToJsonable(
			theSemanticIDListElement,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticIDListElement"
				}
			)

			return
		}
		result["SemanticIDListElement"] = jsonableSemanticIDListElement
	}

	theTypeValueListElement = that.TypeValueListElement()
	var jsonableTypeValueListElement interface{}
	jsonableTypeValueListElement, err = AASSubmodelElementsToJsonable(
		theTypeValueListElement,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "TypeValueListElement"
			}
		)

		return
	}
	result["TypeValueListElement"] = jsonableTypeValueListElement

	theValueTypeListElement = that.ValueTypeListElement()
	if theValueTypeListElement != nil {
		var jsonableValueTypeListElement interface{}
		jsonableValueTypeListElement, err = DataTypeDefXSDToJsonable(
			theValueTypeListElement,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueTypeListElement"
				}
			)

			return
		}
		result["ValueTypeListElement"] = jsonableValueTypeListElement
	}

	theValue = that.Value()
	if theValue != nil {
		jsonableValue := make(
			interface{},
			len(theValue)
		)
		for i, v := range theValue {
			var jsonable interface{}
			jsonable, err = SubmodelElementToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)

				return
			}
			jsonableValue = append(
				jsonableValue,
				jsonable
			)   
		}
		result["Value"] = jsonableValue
	}
}

// Serialize [aastypes.ISubmodelElementCollection] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ISubmodelElementCollection] with proper dispatch, call
// [ToJsonable].
func submodelElementCollectionToMap(
	that: aastypes.ISubmodelElementCollection
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValue = that.Value()
	if theValue != nil {
		jsonableValue := make(
			interface{},
			len(theValue)
		)
		for i, v := range theValue {
			var jsonable interface{}
			jsonable, err = SubmodelElementToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)

				return
			}
			jsonableValue = append(
				jsonableValue,
				jsonable
			)   
		}
		result["Value"] = jsonableValue
	}
}

// Serialize [aastypes.IProperty] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IProperty] with proper dispatch, call
// [ToJsonable].
func propertyToMap(
	that: aastypes.IProperty
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValueType = that.ValueType()
	var jsonableValueType interface{}
	jsonableValueType, err = DataTypeDefXSDToJsonable(
		theValueType,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType"
			}
		)

		return
	}
	result["ValueType"] = jsonableValueType

	theValue = that.Value()
	if theValue != nil {
		result["Value"] = *theValue
	}

	theValueID = that.ValueID()
	if theValueID != nil {
		var jsonableValueID interface{}
		jsonableValueID, err = ReferenceToJsonable(
			theValueID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID"
				}
			)

			return
		}
		result["ValueID"] = jsonableValueID
	}
}

// Serialize [aastypes.IMultiLanguageProperty] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IMultiLanguageProperty] with proper dispatch, call
// [ToJsonable].
func multiLanguagePropertyToMap(
	that: aastypes.IMultiLanguageProperty
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValue = that.Value()
	if theValue != nil {
		jsonableValue := make(
			interface{},
			len(theValue)
		)
		for i, v := range theValue {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)

				return
			}
			jsonableValue = append(
				jsonableValue,
				jsonable
			)   
		}
		result["Value"] = jsonableValue
	}

	theValueID = that.ValueID()
	if theValueID != nil {
		var jsonableValueID interface{}
		jsonableValueID, err = ReferenceToJsonable(
			theValueID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueID"
				}
			)

			return
		}
		result["ValueID"] = jsonableValueID
	}
}

// Serialize [aastypes.IRange] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IRange] with proper dispatch, call
// [ToJsonable].
func rangeToMap(
	that: aastypes.IRange
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValueType = that.ValueType()
	var jsonableValueType interface{}
	jsonableValueType, err = DataTypeDefXSDToJsonable(
		theValueType,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueType"
			}
		)

		return
	}
	result["ValueType"] = jsonableValueType

	theMin = that.Min()
	if theMin != nil {
		result["Min"] = *theMin
	}

	theMax = that.Max()
	if theMax != nil {
		result["Max"] = *theMax
	}
}

// Serialize [aastypes.IReferenceElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IReferenceElement] with proper dispatch, call
// [ToJsonable].
func referenceElementToMap(
	that: aastypes.IReferenceElement
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValue = that.Value()
	if theValue != nil {
		var jsonableValue interface{}
		jsonableValue, err = ReferenceToJsonable(
			theValue,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value"
				}
			)

			return
		}
		result["Value"] = jsonableValue
	}
}

// Serialize [aastypes.IBlob] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IBlob] with proper dispatch, call
// [ToJsonable].
func blobToMap(
	that: aastypes.IBlob
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValue = that.Value()
	if theValue != nil {
		var jsonableValue interface{}
		jsonableValue, err = bytesToJsonable(
			theValue,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value"
				}
			)

			return
		}
		result["Value"] = jsonableValue
	}

	theContentType = that.ContentType()
	result["ContentType"] = *theContentType
}

// Serialize [aastypes.IFile] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IFile] with proper dispatch, call
// [ToJsonable].
func fileToMap(
	that: aastypes.IFile
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theValue = that.Value()
	if theValue != nil {
		result["Value"] = *theValue
	}

	theContentType = that.ContentType()
	result["ContentType"] = *theContentType
}

// Serialize [aastypes.IAnnotatedRelationshipElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IAnnotatedRelationshipElement] with proper dispatch, call
// [ToJsonable].
func annotatedRelationshipElementToMap(
	that: aastypes.IAnnotatedRelationshipElement
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theFirst = that.First()
	var jsonableFirst interface{}
	jsonableFirst, err = ReferenceToJsonable(
		theFirst,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "First"
			}
		)

		return
	}
	result["First"] = jsonableFirst

	theSecond = that.Second()
	var jsonableSecond interface{}
	jsonableSecond, err = ReferenceToJsonable(
		theSecond,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Second"
			}
		)

		return
	}
	result["Second"] = jsonableSecond

	theAnnotations = that.Annotations()
	if theAnnotations != nil {
		jsonableAnnotations := make(
			interface{},
			len(theAnnotations)
		)
		for i, v := range theAnnotations {
			var jsonable interface{}
			jsonable, err = DataElementToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Annotations"
					}
				)

				return
			}
			jsonableAnnotations = append(
				jsonableAnnotations,
				jsonable
			)   
		}
		result["Annotations"] = jsonableAnnotations
	}
}

// Serialize [aastypes.IEntity] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEntity] with proper dispatch, call
// [ToJsonable].
func entityToMap(
	that: aastypes.IEntity
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theStatements = that.Statements()
	if theStatements != nil {
		jsonableStatements := make(
			interface{},
			len(theStatements)
		)
		for i, v := range theStatements {
			var jsonable interface{}
			jsonable, err = SubmodelElementToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Statements"
					}
				)

				return
			}
			jsonableStatements = append(
				jsonableStatements,
				jsonable
			)   
		}
		result["Statements"] = jsonableStatements
	}

	theEntityType = that.EntityType()
	var jsonableEntityType interface{}
	jsonableEntityType, err = EntityTypeToJsonable(
		theEntityType,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "EntityType"
			}
		)

		return
	}
	result["EntityType"] = jsonableEntityType

	theGlobalAssetID = that.GlobalAssetID()
	if theGlobalAssetID != nil {
		result["GlobalAssetID"] = *theGlobalAssetID
	}

	theSpecificAssetIDs = that.SpecificAssetIDs()
	if theSpecificAssetIDs != nil {
		jsonableSpecificAssetIDs := make(
			interface{},
			len(theSpecificAssetIDs)
		)
		for i, v := range theSpecificAssetIDs {
			var jsonable interface{}
			jsonable, err = SpecificAssetIDToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SpecificAssetIDs"
					}
				)

				return
			}
			jsonableSpecificAssetIDs = append(
				jsonableSpecificAssetIDs,
				jsonable
			)   
		}
		result["SpecificAssetIDs"] = jsonableSpecificAssetIDs
	}
}

// Serialize [aastypes.IEventPayload] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEventPayload] with proper dispatch, call
// [ToJsonable].
func eventPayloadToMap(
	that: aastypes.IEventPayload
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theSource = that.Source()
	var jsonableSource interface{}
	jsonableSource, err = ReferenceToJsonable(
		theSource,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Source"
			}
		)

		return
	}
	result["Source"] = jsonableSource

	theSourceSemanticID = that.SourceSemanticID()
	if theSourceSemanticID != nil {
		var jsonableSourceSemanticID interface{}
		jsonableSourceSemanticID, err = ReferenceToJsonable(
			theSourceSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SourceSemanticID"
				}
			)

			return
		}
		result["SourceSemanticID"] = jsonableSourceSemanticID
	}

	theObservableReference = that.ObservableReference()
	var jsonableObservableReference interface{}
	jsonableObservableReference, err = ReferenceToJsonable(
		theObservableReference,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ObservableReference"
			}
		)

		return
	}
	result["ObservableReference"] = jsonableObservableReference

	theObservableSemanticID = that.ObservableSemanticID()
	if theObservableSemanticID != nil {
		var jsonableObservableSemanticID interface{}
		jsonableObservableSemanticID, err = ReferenceToJsonable(
			theObservableSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ObservableSemanticID"
				}
			)

			return
		}
		result["ObservableSemanticID"] = jsonableObservableSemanticID
	}

	theTopic = that.Topic()
	if theTopic != nil {
		result["Topic"] = *theTopic
	}

	theSubjectID = that.SubjectID()
	if theSubjectID != nil {
		var jsonableSubjectID interface{}
		jsonableSubjectID, err = ReferenceToJsonable(
			theSubjectID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SubjectID"
				}
			)

			return
		}
		result["SubjectID"] = jsonableSubjectID
	}

	theTimeStamp = that.TimeStamp()
	result["TimeStamp"] = *theTimeStamp

	thePayload = that.Payload()
	if thePayload != nil {
		var jsonablePayload interface{}
		jsonablePayload, err = bytesToJsonable(
			thePayload,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Payload"
				}
			)

			return
		}
		result["Payload"] = jsonablePayload
	}
}

// Serialize [aastypes.IBasicEventElement] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IBasicEventElement] with proper dispatch, call
// [ToJsonable].
func basicEventElementToMap(
	that: aastypes.IBasicEventElement
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theObserved = that.Observed()
	var jsonableObserved interface{}
	jsonableObserved, err = ReferenceToJsonable(
		theObserved,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Observed"
			}
		)

		return
	}
	result["Observed"] = jsonableObserved

	theDirection = that.Direction()
	var jsonableDirection interface{}
	jsonableDirection, err = DirectionToJsonable(
		theDirection,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Direction"
			}
		)

		return
	}
	result["Direction"] = jsonableDirection

	theState = that.State()
	var jsonableState interface{}
	jsonableState, err = StateOfEventToJsonable(
		theState,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "State"
			}
		)

		return
	}
	result["State"] = jsonableState

	theMessageTopic = that.MessageTopic()
	if theMessageTopic != nil {
		result["MessageTopic"] = *theMessageTopic
	}

	theMessageBroker = that.MessageBroker()
	if theMessageBroker != nil {
		var jsonableMessageBroker interface{}
		jsonableMessageBroker, err = ReferenceToJsonable(
			theMessageBroker,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "MessageBroker"
				}
			)

			return
		}
		result["MessageBroker"] = jsonableMessageBroker
	}

	theLastUpdate = that.LastUpdate()
	if theLastUpdate != nil {
		result["LastUpdate"] = *theLastUpdate
	}

	theMinInterval = that.MinInterval()
	if theMinInterval != nil {
		result["MinInterval"] = *theMinInterval
	}

	theMaxInterval = that.MaxInterval()
	if theMaxInterval != nil {
		result["MaxInterval"] = *theMaxInterval
	}
}

// Serialize [aastypes.IOperation] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IOperation] with proper dispatch, call
// [ToJsonable].
func operationToMap(
	that: aastypes.IOperation
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theInputVariables = that.InputVariables()
	if theInputVariables != nil {
		jsonableInputVariables := make(
			interface{},
			len(theInputVariables)
		)
		for i, v := range theInputVariables {
			var jsonable interface{}
			jsonable, err = OperationVariableToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "InputVariables"
					}
				)

				return
			}
			jsonableInputVariables = append(
				jsonableInputVariables,
				jsonable
			)   
		}
		result["InputVariables"] = jsonableInputVariables
	}

	theOutputVariables = that.OutputVariables()
	if theOutputVariables != nil {
		jsonableOutputVariables := make(
			interface{},
			len(theOutputVariables)
		)
		for i, v := range theOutputVariables {
			var jsonable interface{}
			jsonable, err = OperationVariableToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "OutputVariables"
					}
				)

				return
			}
			jsonableOutputVariables = append(
				jsonableOutputVariables,
				jsonable
			)   
		}
		result["OutputVariables"] = jsonableOutputVariables
	}

	theInoutputVariables = that.InoutputVariables()
	if theInoutputVariables != nil {
		jsonableInoutputVariables := make(
			interface{},
			len(theInoutputVariables)
		)
		for i, v := range theInoutputVariables {
			var jsonable interface{}
			jsonable, err = OperationVariableToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "InoutputVariables"
					}
				)

				return
			}
			jsonableInoutputVariables = append(
				jsonableInoutputVariables,
				jsonable
			)   
		}
		result["InoutputVariables"] = jsonableInoutputVariables
	}
}

// Serialize [aastypes.IOperationVariable] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IOperationVariable] with proper dispatch, call
// [ToJsonable].
func operationVariableToMap(
	that: aastypes.IOperationVariable
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theValue = that.Value()
	var jsonableValue interface{}
	jsonableValue, err = SubmodelElementToJsonable(
		theValue,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Value"
			}
		)

		return
	}
	result["Value"] = jsonableValue
}

// Serialize [aastypes.ICapability] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ICapability] with proper dispatch, call
// [ToJsonable].
func capabilityToMap(
	that: aastypes.ICapability
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theSemanticID = that.SemanticID()
	if theSemanticID != nil {
		var jsonableSemanticID interface{}
		jsonableSemanticID, err = ReferenceToJsonable(
			theSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "SemanticID"
				}
			)

			return
		}
		result["SemanticID"] = jsonableSemanticID
	}

	theSupplementalSemanticIDs = that.SupplementalSemanticIDs()
	if theSupplementalSemanticIDs != nil {
		jsonableSupplementalSemanticIDs := make(
			interface{},
			len(theSupplementalSemanticIDs)
		)
		for i, v := range theSupplementalSemanticIDs {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SupplementalSemanticIDs"
					}
				)

				return
			}
			jsonableSupplementalSemanticIDs = append(
				jsonableSupplementalSemanticIDs,
				jsonable
			)   
		}
		result["SupplementalSemanticIDs"] = jsonableSupplementalSemanticIDs
	}

	theQualifiers = that.Qualifiers()
	if theQualifiers != nil {
		jsonableQualifiers := make(
			interface{},
			len(theQualifiers)
		)
		for i, v := range theQualifiers {
			var jsonable interface{}
			jsonable, err = QualifierToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Qualifiers"
					}
				)

				return
			}
			jsonableQualifiers = append(
				jsonableQualifiers,
				jsonable
			)   
		}
		result["Qualifiers"] = jsonableQualifiers
	}

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}
}

// Serialize [aastypes.IConceptDescription] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IConceptDescription] with proper dispatch, call
// [ToJsonable].
func conceptDescriptionToMap(
	that: aastypes.IConceptDescription
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theExtensions = that.Extensions()
	if theExtensions != nil {
		jsonableExtensions := make(
			interface{},
			len(theExtensions)
		)
		for i, v := range theExtensions {
			var jsonable interface{}
			jsonable, err = ExtensionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Extensions"
					}
				)

				return
			}
			jsonableExtensions = append(
				jsonableExtensions,
				jsonable
			)   
		}
		result["Extensions"] = jsonableExtensions
	}

	theCategory = that.Category()
	if theCategory != nil {
		result["Category"] = *theCategory
	}

	theIDShort = that.IDShort()
	if theIDShort != nil {
		result["IDShort"] = *theIDShort
	}

	theDisplayName = that.DisplayName()
	if theDisplayName != nil {
		jsonableDisplayName := make(
			interface{},
			len(theDisplayName)
		)
		for i, v := range theDisplayName {
			var jsonable interface{}
			jsonable, err = LangStringNameTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DisplayName"
					}
				)

				return
			}
			jsonableDisplayName = append(
				jsonableDisplayName,
				jsonable
			)   
		}
		result["DisplayName"] = jsonableDisplayName
	}

	theDescription = that.Description()
	if theDescription != nil {
		jsonableDescription := make(
			interface{},
			len(theDescription)
		)
		for i, v := range theDescription {
			var jsonable interface{}
			jsonable, err = LangStringTextTypeToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Description"
					}
				)

				return
			}
			jsonableDescription = append(
				jsonableDescription,
				jsonable
			)   
		}
		result["Description"] = jsonableDescription
	}

	theAdministration = that.Administration()
	if theAdministration != nil {
		var jsonableAdministration interface{}
		jsonableAdministration, err = AdministrativeInformationToJsonable(
			theAdministration,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Administration"
				}
			)

			return
		}
		result["Administration"] = jsonableAdministration
	}

	theID = that.ID()
	result["ID"] = *theID

	theEmbeddedDataSpecifications = that.EmbeddedDataSpecifications()
	if theEmbeddedDataSpecifications != nil {
		jsonableEmbeddedDataSpecifications := make(
			interface{},
			len(theEmbeddedDataSpecifications)
		)
		for i, v := range theEmbeddedDataSpecifications {
			var jsonable interface{}
			jsonable, err = EmbeddedDataSpecificationToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "EmbeddedDataSpecifications"
					}
				)

				return
			}
			jsonableEmbeddedDataSpecifications = append(
				jsonableEmbeddedDataSpecifications,
				jsonable
			)   
		}
		result["EmbeddedDataSpecifications"] = jsonableEmbeddedDataSpecifications
	}

	theIsCaseOf = that.IsCaseOf()
	if theIsCaseOf != nil {
		jsonableIsCaseOf := make(
			interface{},
			len(theIsCaseOf)
		)
		for i, v := range theIsCaseOf {
			var jsonable interface{}
			jsonable, err = ReferenceToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IsCaseOf"
					}
				)

				return
			}
			jsonableIsCaseOf = append(
				jsonableIsCaseOf,
				jsonable
			)   
		}
		result["IsCaseOf"] = jsonableIsCaseOf
	}
}

// Serialize [aastypes.IReference] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IReference] with proper dispatch, call
// [ToJsonable].
func referenceToMap(
	that: aastypes.IReference
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theType = that.Type()
	var jsonableType interface{}
	jsonableType, err = ReferenceTypesToJsonable(
		theType,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Type"
			}
		)

		return
	}
	result["Type"] = jsonableType

	theReferredSemanticID = that.ReferredSemanticID()
	if theReferredSemanticID != nil {
		var jsonableReferredSemanticID interface{}
		jsonableReferredSemanticID, err = ReferenceToJsonable(
			theReferredSemanticID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ReferredSemanticID"
				}
			)

			return
		}
		result["ReferredSemanticID"] = jsonableReferredSemanticID
	}

	theKeys = that.Keys()
	jsonableKeys := make(
		interface{},
		len(theKeys)
	)
	for i, v := range theKeys {
		var jsonable interface{}
		jsonable, err = KeyToJsonable(
		v,
	)
		if err != nil {
			err.Path.PrependIndex(
				&aasreporting.IndexSegment{
					Index: i
				}
			)

			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Keys"
				}
			)

			return
		}
		jsonableKeys = append(
			jsonableKeys,
			jsonable
		)   
	}
	result["Keys"] = jsonableKeys
}

// Serialize [aastypes.IKey] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IKey] with proper dispatch, call
// [ToJsonable].
func keyToMap(
	that: aastypes.IKey
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theType = that.Type()
	var jsonableType interface{}
	jsonableType, err = KeyTypesToJsonable(
		theType,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "Type"
			}
		)

		return
	}
	result["Type"] = jsonableType

	theValue = that.Value()
	result["Value"] = *theValue
}

// Serialize [aastypes.ILangStringNameType] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringNameType] with proper dispatch, call
// [ToJsonable].
func langStringNameTypeToMap(
	that: aastypes.ILangStringNameType
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theLanguage = that.Language()
	result["Language"] = *theLanguage

	theText = that.Text()
	result["Text"] = *theText
}

// Serialize [aastypes.ILangStringTextType] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringTextType] with proper dispatch, call
// [ToJsonable].
func langStringTextTypeToMap(
	that: aastypes.ILangStringTextType
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theLanguage = that.Language()
	result["Language"] = *theLanguage

	theText = that.Text()
	result["Text"] = *theText
}

// Serialize [aastypes.IEnvironment] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEnvironment] with proper dispatch, call
// [ToJsonable].
func environmentToMap(
	that: aastypes.IEnvironment
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theAssetAdministrationShells = that.AssetAdministrationShells()
	if theAssetAdministrationShells != nil {
		jsonableAssetAdministrationShells := make(
			interface{},
			len(theAssetAdministrationShells)
		)
		for i, v := range theAssetAdministrationShells {
			var jsonable interface{}
			jsonable, err = AssetAdministrationShellToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetAdministrationShells"
					}
				)

				return
			}
			jsonableAssetAdministrationShells = append(
				jsonableAssetAdministrationShells,
				jsonable
			)   
		}
		result["AssetAdministrationShells"] = jsonableAssetAdministrationShells
	}

	theSubmodels = that.Submodels()
	if theSubmodels != nil {
		jsonableSubmodels := make(
			interface{},
			len(theSubmodels)
		)
		for i, v := range theSubmodels {
			var jsonable interface{}
			jsonable, err = SubmodelToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Submodels"
					}
				)

				return
			}
			jsonableSubmodels = append(
				jsonableSubmodels,
				jsonable
			)   
		}
		result["Submodels"] = jsonableSubmodels
	}

	theConceptDescriptions = that.ConceptDescriptions()
	if theConceptDescriptions != nil {
		jsonableConceptDescriptions := make(
			interface{},
			len(theConceptDescriptions)
		)
		for i, v := range theConceptDescriptions {
			var jsonable interface{}
			jsonable, err = ConceptDescriptionToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ConceptDescriptions"
					}
				)

				return
			}
			jsonableConceptDescriptions = append(
				jsonableConceptDescriptions,
				jsonable
			)   
		}
		result["ConceptDescriptions"] = jsonableConceptDescriptions
	}
}

// Serialize [aastypes.IEmbeddedDataSpecification] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IEmbeddedDataSpecification] with proper dispatch, call
// [ToJsonable].
func embeddedDataSpecificationToMap(
	that: aastypes.IEmbeddedDataSpecification
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theDataSpecification = that.DataSpecification()
	var jsonableDataSpecification interface{}
	jsonableDataSpecification, err = ReferenceToJsonable(
		theDataSpecification,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "DataSpecification"
			}
		)

		return
	}
	result["DataSpecification"] = jsonableDataSpecification

	theDataSpecificationContent = that.DataSpecificationContent()
	var jsonableDataSpecificationContent interface{}
	jsonableDataSpecificationContent, err = DataSpecificationContentToJsonable(
		theDataSpecificationContent,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "DataSpecificationContent"
			}
		)

		return
	}
	result["DataSpecificationContent"] = jsonableDataSpecificationContent
}

// Serialize [aastypes.ILevelType] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILevelType] with proper dispatch, call
// [ToJsonable].
func levelTypeToMap(
	that: aastypes.ILevelType
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theMin = that.Min()
	result["Min"] = *theMin

	theNom = that.Nom()
	result["Nom"] = *theNom

	theTyp = that.Typ()
	result["Typ"] = *theTyp

	theMax = that.Max()
	result["Max"] = *theMax
}

// Serialize [aastypes.IValueReferencePair] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IValueReferencePair] with proper dispatch, call
// [ToJsonable].
func valueReferencePairToMap(
	that: aastypes.IValueReferencePair
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theValue = that.Value()
	result["Value"] = *theValue

	theValueID = that.ValueID()
	var jsonableValueID interface{}
	jsonableValueID, err = ReferenceToJsonable(
		theValueID,
	)
	if err != nil {
		err.Path.PrependName(
			&aasreporting.NameSegment{
				Name: "ValueID"
			}
		)

		return
	}
	result["ValueID"] = jsonableValueID
}

// Serialize [aastypes.IValueList] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IValueList] with proper dispatch, call
// [ToJsonable].
func valueListToMap(
	that: aastypes.IValueList
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theValueReferencePairs = that.ValueReferencePairs()
	jsonableValueReferencePairs := make(
		interface{},
		len(theValueReferencePairs)
	)
	for i, v := range theValueReferencePairs {
		var jsonable interface{}
		jsonable, err = ValueReferencePairToJsonable(
		v,
	)
		if err != nil {
			err.Path.PrependIndex(
				&aasreporting.IndexSegment{
					Index: i
				}
			)

			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueReferencePairs"
				}
			)

			return
		}
		jsonableValueReferencePairs = append(
			jsonableValueReferencePairs,
			jsonable
		)   
	}
	result["ValueReferencePairs"] = jsonableValueReferencePairs
}

// Serialize [aastypes.ILangStringPreferredNameTypeIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringPreferredNameTypeIEC61360] with proper dispatch, call
// [ToJsonable].
func langStringPreferredNameTypeIEC61360ToMap(
	that: aastypes.ILangStringPreferredNameTypeIEC61360
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theLanguage = that.Language()
	result["Language"] = *theLanguage

	theText = that.Text()
	result["Text"] = *theText
}

// Serialize [aastypes.ILangStringShortNameTypeIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringShortNameTypeIEC61360] with proper dispatch, call
// [ToJsonable].
func langStringShortNameTypeIEC61360ToMap(
	that: aastypes.ILangStringShortNameTypeIEC61360
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theLanguage = that.Language()
	result["Language"] = *theLanguage

	theText = that.Text()
	result["Text"] = *theText
}

// Serialize [aastypes.ILangStringDefinitionTypeIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.ILangStringDefinitionTypeIEC61360] with proper dispatch, call
// [ToJsonable].
func langStringDefinitionTypeIEC61360ToMap(
	that: aastypes.ILangStringDefinitionTypeIEC61360
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	theLanguage = that.Language()
	result["Language"] = *theLanguage

	theText = that.Text()
	result["Text"] = *theText
}

// Serialize [aastypes.IDataSpecificationIEC61360] as a JSON-able map.
//
// This function performs no dispatch! It is only used to serialize
// the properties. If you want to serialize an instance of
// [aastypes.IDataSpecificationIEC61360] with proper dispatch, call
// [ToJsonable].
func dataSpecificationIEC61360ToMap(
	that: aastypes.IDataSpecificationIEC61360
) (result map[string]interface{}, err *SerializationError) {
	result = make(map[string]interface{})

	thePreferredName = that.PreferredName()
	jsonablePreferredName := make(
		interface{},
		len(thePreferredName)
	)
	for i, v := range thePreferredName {
		var jsonable interface{}
		jsonable, err = LangStringPreferredNameTypeIEC61360ToJsonable(
		v,
	)
		if err != nil {
			err.Path.PrependIndex(
				&aasreporting.IndexSegment{
					Index: i
				}
			)

			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "PreferredName"
				}
			)

			return
		}
		jsonablePreferredName = append(
			jsonablePreferredName,
			jsonable
		)   
	}
	result["PreferredName"] = jsonablePreferredName

	theShortName = that.ShortName()
	if theShortName != nil {
		jsonableShortName := make(
			interface{},
			len(theShortName)
		)
		for i, v := range theShortName {
			var jsonable interface{}
			jsonable, err = LangStringShortNameTypeIEC61360ToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ShortName"
					}
				)

				return
			}
			jsonableShortName = append(
				jsonableShortName,
				jsonable
			)   
		}
		result["ShortName"] = jsonableShortName
	}

	theUnit = that.Unit()
	if theUnit != nil {
		result["Unit"] = *theUnit
	}

	theUnitID = that.UnitID()
	if theUnitID != nil {
		var jsonableUnitID interface{}
		jsonableUnitID, err = ReferenceToJsonable(
			theUnitID,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "UnitID"
				}
			)

			return
		}
		result["UnitID"] = jsonableUnitID
	}

	theSourceOfDefinition = that.SourceOfDefinition()
	if theSourceOfDefinition != nil {
		result["SourceOfDefinition"] = *theSourceOfDefinition
	}

	theSymbol = that.Symbol()
	if theSymbol != nil {
		result["Symbol"] = *theSymbol
	}

	theDataType = that.DataType()
	if theDataType != nil {
		var jsonableDataType interface{}
		jsonableDataType, err = DataTypeIEC61360ToJsonable(
			theDataType,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "DataType"
				}
			)

			return
		}
		result["DataType"] = jsonableDataType
	}

	theDefinition = that.Definition()
	if theDefinition != nil {
		jsonableDefinition := make(
			interface{},
			len(theDefinition)
		)
		for i, v := range theDefinition {
			var jsonable interface{}
			jsonable, err = LangStringDefinitionTypeIEC61360ToJsonable(
			v,
		)
			if err != nil {
				err.Path.PrependIndex(
					&aasreporting.IndexSegment{
						Index: i
					}
				)

				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Definition"
					}
				)

				return
			}
			jsonableDefinition = append(
				jsonableDefinition,
				jsonable
			)   
		}
		result["Definition"] = jsonableDefinition
	}

	theValueFormat = that.ValueFormat()
	if theValueFormat != nil {
		result["ValueFormat"] = *theValueFormat
	}

	theValueList = that.ValueList()
	if theValueList != nil {
		var jsonableValueList interface{}
		jsonableValueList, err = ValueListToJsonable(
			theValueList,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ValueList"
				}
			)

			return
		}
		result["ValueList"] = jsonableValueList
	}

	theValue = that.Value()
	if theValue != nil {
		result["Value"] = *theValue
	}

	theLevelType = that.LevelType()
	if theLevelType != nil {
		var jsonableLevelType interface{}
		jsonableLevelType, err = LevelTypeToJsonable(
			theLevelType,
		)
		if err != nil {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "LevelType"
				}
			)

			return
		}
		result["LevelType"] = jsonableLevelType
	}
}

// Serialize ``that`` instance to a JSON-able representation.
//
// Return a structure which can be readily converted to JSON,
// or an error if some value could not be converted.
func ToJsonable(
	that: aastypes.IClass
) (result map[string]interface{}, err *SerializationError) {
	switch that.ModelType() {
	case aastypes.ModelTypeExtension:
		result, err = extensionToMap(
			that
		)
	case aastypes.ModelTypeAdministrativeInformation:
		result, err = administrativeInformationToMap(
			that
		)
	case aastypes.ModelTypeQualifier:
		result, err = qualifierToMap(
			that
		)
	case aastypes.ModelTypeAssetAdministrationShell:
		result, err = assetAdministrationShellToMap(
			that
		)
	case aastypes.ModelTypeAssetInformation:
		result, err = assetInformationToMap(
			that
		)
	case aastypes.ModelTypeResource:
		result, err = resourceToMap(
			that
		)
	case aastypes.ModelTypeSpecificAssetID:
		result, err = specificAssetIDToMap(
			that
		)
	case aastypes.ModelTypeSubmodel:
		result, err = submodelToMap(
			that
		)
	case aastypes.ModelTypeRelationshipElement:
		result, err = relationshipElementToMap(
			that
		)
	case aastypes.ModelTypeSubmodelElementList:
		result, err = submodelElementListToMap(
			that
		)
	case aastypes.ModelTypeSubmodelElementCollection:
		result, err = submodelElementCollectionToMap(
			that
		)
	case aastypes.ModelTypeProperty:
		result, err = propertyToMap(
			that
		)
	case aastypes.ModelTypeMultiLanguageProperty:
		result, err = multiLanguagePropertyToMap(
			that
		)
	case aastypes.ModelTypeRange:
		result, err = rangeToMap(
			that
		)
	case aastypes.ModelTypeReferenceElement:
		result, err = referenceElementToMap(
			that
		)
	case aastypes.ModelTypeBlob:
		result, err = blobToMap(
			that
		)
	case aastypes.ModelTypeFile:
		result, err = fileToMap(
			that
		)
	case aastypes.ModelTypeAnnotatedRelationshipElement:
		result, err = annotatedRelationshipElementToMap(
			that
		)
	case aastypes.ModelTypeEntity:
		result, err = entityToMap(
			that
		)
	case aastypes.ModelTypeEventPayload:
		result, err = eventPayloadToMap(
			that
		)
	case aastypes.ModelTypeBasicEventElement:
		result, err = basicEventElementToMap(
			that
		)
	case aastypes.ModelTypeOperation:
		result, err = operationToMap(
			that
		)
	case aastypes.ModelTypeOperationVariable:
		result, err = operationVariableToMap(
			that
		)
	case aastypes.ModelTypeCapability:
		result, err = capabilityToMap(
			that
		)
	case aastypes.ModelTypeConceptDescription:
		result, err = conceptDescriptionToMap(
			that
		)
	case aastypes.ModelTypeReference:
		result, err = referenceToMap(
			that
		)
	case aastypes.ModelTypeKey:
		result, err = keyToMap(
			that
		)
	case aastypes.ModelTypeLangStringNameType:
		result, err = langStringNameTypeToMap(
			that
		)
	case aastypes.ModelTypeLangStringTextType:
		result, err = langStringTextTypeToMap(
			that
		)
	case aastypes.ModelTypeEnvironment:
		result, err = environmentToMap(
			that
		)
	case aastypes.ModelTypeEmbeddedDataSpecification:
		result, err = embeddedDataSpecificationToMap(
			that
		)
	case aastypes.ModelTypeLevelType:
		result, err = levelTypeToMap(
			that
		)
	case aastypes.ModelTypeValueReferencePair:
		result, err = valueReferencePairToMap(
			that
		)
	case aastypes.ModelTypeValueList:
		result, err = valueListToMap(
			that
		)
	case aastypes.ModelTypeLangStringPreferredNameTypeIEC61360:
		result, err = langStringPreferredNameTypeIEC61360ToMap(
			that
		)
	case aastypes.ModelTypeLangStringShortNameTypeIEC61360:
		result, err = langStringShortNameTypeIEC61360ToMap(
			that
		)
	case aastypes.ModelTypeLangStringDefinitionTypeIEC61360:
		result, err = langStringDefinitionTypeIEC61360ToMap(
			that
		)
	case aastypes.ModelTypeDataSpecificationIEC61360:
		result, err = dataSpecificationIEC61360ToMap(
			that
		)
	default:
		err = newSerializationError(
			fmt.Sprintf(
				"Unexpected model type literal: %v",
				modelType
		)
	}
	return
}

// endregion

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
